diff --git a/ConstructorCodeForLateBindingfft.cpp b/ConstructorCodeForLateBindingfft.cpp
index b87a4a8..1412854 100644
--- a/ConstructorCodeForLateBindingfft.cpp
+++ b/ConstructorCodeForLateBindingfft.cpp
@@ -1,67 +1,147 @@
-
 // late binding
+#ifdef _WIN32
+#include <windows.h>
+#else
+#include <dlfcn.h>
+#endif
 
 bool ok = true;
-HINSTANCE hinstLib = LoadLibrary(TEXT("libfftw3f-3.dll"));
-
-if (hinstLib == NULL)
-hinstLib = LoadLibrary(TEXT("fftw3.dll"));
-
-if (hinstLib == NULL)
-hinstLib = LoadLibrary(TEXT("fftw.dll"));
 
-if (hinstLib != NULL)
-{
-	d->hinstLib = hinstLib;
-	d->fftwf_free = (fftwf_free_proc)GetProcAddress(d->hinstLib, "fftwf_free");
-	d->fftwf_malloc = (fftwf_malloc_proc)GetProcAddress(d->hinstLib, "fftwf_malloc");
-	// for 1 d fft
-	d->fftwf_plan_dft_r2c_1d = (fftwf_plan_dft_r2c_1d_proc)GetProcAddress(d->hinstLib, "fftwf_plan_dft_r2c_1d");
-	d->fftwf_plan_dft_c2r_1d = (fftwf_plan_dft_c2r_1d_proc)GetProcAddress(d->hinstLib, "fftwf_plan_dft_c2r_1d");
-	// for 2d fft
-	d->fftwf_plan_dft_r2c_2d = (fftwf_plan_dft_r2c_2d_proc)GetProcAddress(d->hinstLib, "fftwf_plan_dft_r2c_2d");
-	d->fftwf_plan_dft_c2r_2d = (fftwf_plan_dft_c2r_2d_proc)GetProcAddress(d->hinstLib, "fftwf_plan_dft_c2r_2d");
+// Error
+// HINSTANCE hinstLib = LoadLibrary(TEXT("libfftw3f-3.dll"));
+// Fix
+void *hinstLib = nullptr;
 
-	
-
-	d->fftwf_destroy_plan = (fftwf_destroy_plan_proc)GetProcAddress(d->hinstLib, "fftwf_destroy_plan");
-	d->fftwf_execute = (fftwf_execute_proc)GetProcAddress(d->hinstLib, "fftwf_execute");
+#ifdef _WIN32
+// Windows: LoadLibrary
+hinstLib = LoadLibraryA("libfftw3f-3.dll");
+if(!hinstLib) {
+    hinstLib = LoadLibraryA("fftw3.dll");
+    if(!hinstLib) {
+        hinstLib = LoadLibraryA("fftw.dll");
+    }
+}
+#else
+// Linux: dlopen
+hinstLib = dlopen("libfftw3f.so", RTLD_LAZY);
+if(!hinstLib) {
+    hinstLib = dlopen("libfftw3f-3.so", RTLD_LAZY);
+    if(!hinstLib) {
+        hinstLib = dlopen("libfftw3f.so.3", RTLD_LAZY);
+    }
+}
+#endif
 
-	d->fftwf_execute_dft_r2c = (fftwf_execute_dft_r2c_proc)GetProcAddress(d->hinstLib, "fftwf_execute_dft_r2c");
-	d->fftwf_execute_dft_c2r = (fftwf_execute_dft_c2r_proc)GetProcAddress(d->hinstLib, "fftwf_execute_dft_c2r");
-	// required for internal threading
-//	fftwf_init_threads = (fftwf_init_threads_proc)GetProcAddress(hinstLib, "fftwf_init_threads");
-//	fftwf_plan_with_nthreads = (fftwf_plan_with_nthreads_proc)GetProcAddress(hinstLib, "fftwf_plan_with_nthreads");
-//	fftwf_cleanup_threads = (fftwf_cleanup_threads_proc)GetProcAddress(hinstLib, "fftwf_cleanup_threads");
-//	fftwf_cleanup = (fftwf_cleanup_proc)GetProcAddress(hinstLib, "fftwf_cleanup");
+// Error
+// if (hinstLib == NULL)
+//   hinstLib = LoadLibrary(TEXT("fftw3.dll"));
+//   etc...
+// Fix
+if(hinstLib != nullptr) {
+    // Fix: expliziter Cast fÃ¼r Windows
+#ifdef _WIN32
+    d->hinstLib = (HINSTANCE) hinstLib;
+#else
+    d->hinstLib = hinstLib;
+#endif
 
+    // Error
+    // d->fftwf_free = (fftwf_free_proc)GetProcAddress(d->hinstLib,
+    // "fftwf_free"); etc... alle GetProcAddress Calls Fix
+#ifdef _WIN32
+    d->fftwf_free =
+        (fftwf_free_proc) GetProcAddress((HINSTANCE) d->hinstLib, "fftwf_free");
+    d->fftwf_malloc = (fftwf_malloc_proc) GetProcAddress(
+        (HINSTANCE) d->hinstLib, "fftwf_malloc");
+    // for 1 d fft
+    d->fftwf_plan_dft_r2c_1d = (fftwf_plan_dft_r2c_1d_proc) GetProcAddress(
+        (HINSTANCE) d->hinstLib, "fftwf_plan_dft_r2c_1d");
+    d->fftwf_plan_dft_c2r_1d = (fftwf_plan_dft_c2r_1d_proc) GetProcAddress(
+        (HINSTANCE) d->hinstLib, "fftwf_plan_dft_c2r_1d");
+    // for 2d fft
+    d->fftwf_plan_dft_r2c_2d = (fftwf_plan_dft_r2c_2d_proc) GetProcAddress(
+        (HINSTANCE) d->hinstLib, "fftwf_plan_dft_r2c_2d");
+    d->fftwf_plan_dft_c2r_2d = (fftwf_plan_dft_c2r_2d_proc) GetProcAddress(
+        (HINSTANCE) d->hinstLib, "fftwf_plan_dft_c2r_2d");
+    d->fftwf_destroy_plan = (fftwf_destroy_plan_proc) GetProcAddress(
+        (HINSTANCE) d->hinstLib, "fftwf_destroy_plan");
+    d->fftwf_execute = (fftwf_execute_proc) GetProcAddress(
+        (HINSTANCE) d->hinstLib, "fftwf_execute");
+    d->fftwf_execute_dft_r2c = (fftwf_execute_dft_r2c_proc) GetProcAddress(
+        (HINSTANCE) d->hinstLib, "fftwf_execute_dft_r2c");
+    d->fftwf_execute_dft_c2r = (fftwf_execute_dft_c2r_proc) GetProcAddress(
+        (HINSTANCE) d->hinstLib, "fftwf_execute_dft_c2r");
+    // required for internal threading
+    // fftwf_init_threads = (fftwf_init_threads_proc)GetProcAddress(hinstLib,
+    // "fftwf_init_threads"); fftwf_plan_with_nthreads =
+    // (fftwf_plan_with_nthreads_proc)GetProcAddress(hinstLib,
+    // "fftwf_plan_with_nthreads"); fftwf_cleanup_threads =
+    // (fftwf_cleanup_threads_proc)GetProcAddress(hinstLib,
+    // "fftwf_cleanup_threads"); fftwf_cleanup =
+    // (fftwf_cleanup_proc)GetProcAddress(hinstLib, "fftwf_cleanup");
+#else
+    // Linux: dlsym
+    d->fftwf_free = (fftwf_free_proc) dlsym(hinstLib, "fftwf_free");
+    d->fftwf_malloc = (fftwf_malloc_proc) dlsym(hinstLib, "fftwf_malloc");
+    // for 1 d fft
+    d->fftwf_plan_dft_r2c_1d =
+        (fftwf_plan_dft_r2c_1d_proc) dlsym(hinstLib, "fftwf_plan_dft_r2c_1d");
+    d->fftwf_plan_dft_c2r_1d =
+        (fftwf_plan_dft_c2r_1d_proc) dlsym(hinstLib, "fftwf_plan_dft_c2r_1d");
+    // for 2d fft
+    d->fftwf_plan_dft_r2c_2d =
+        (fftwf_plan_dft_r2c_2d_proc) dlsym(hinstLib, "fftwf_plan_dft_r2c_2d");
+    d->fftwf_plan_dft_c2r_2d =
+        (fftwf_plan_dft_c2r_2d_proc) dlsym(hinstLib, "fftwf_plan_dft_c2r_2d");
+    d->fftwf_destroy_plan =
+        (fftwf_destroy_plan_proc) dlsym(hinstLib, "fftwf_destroy_plan");
+    d->fftwf_execute = (fftwf_execute_proc) dlsym(hinstLib, "fftwf_execute");
+    d->fftwf_execute_dft_r2c =
+        (fftwf_execute_dft_r2c_proc) dlsym(hinstLib, "fftwf_execute_dft_r2c");
+    d->fftwf_execute_dft_c2r =
+        (fftwf_execute_dft_c2r_proc) dlsym(hinstLib, "fftwf_execute_dft_c2r");
+    // required for internal threading
+    // fftwf_init_threads = (fftwf_init_threads_proc)dlsym(hinstLib,
+    // "fftwf_init_threads"); fftwf_plan_with_nthreads =
+    // (fftwf_plan_with_nthreads_proc)dlsym(hinstLib,
+    // "fftwf_plan_with_nthreads"); fftwf_cleanup_threads =
+    // (fftwf_cleanup_threads_proc)dlsym(hinstLib, "fftwf_cleanup_threads");
+    // fftwf_cleanup = (fftwf_cleanup_proc)dlsym(hinstLib, "fftwf_cleanup");
+#endif
 }
-if (d->hinstLib == NULL || d->fftwf_free == NULL || d->fftwf_malloc == NULL
-	|| d->fftwf_plan_dft_r2c_1d == NULL || d->fftwf_plan_dft_c2r_1d == NULL
-	|| d->fftwf_plan_dft_r2c_2d == NULL || d->fftwf_plan_dft_c2r_2d == NULL
-	|| d->fftwf_destroy_plan == NULL || d->fftwf_execute == NULL
-	|| d->fftwf_execute_dft_r2c == NULL || d->fftwf_execute_dft_c2r == NULL
-	// required for internal threading
-//	|| d->fftwf_init_threads == NULL || d->fftwf_plan_with_nthreads == NULL
-//	|| d->fftwf_cleanup_threads == NULL || d->fftwf_cleanup == NULL
-
 
+if(d->hinstLib == nullptr || d->fftwf_free == nullptr ||
+   d->fftwf_malloc == nullptr || d->fftwf_plan_dft_r2c_1d == nullptr ||
+   d->fftwf_plan_dft_c2r_1d == nullptr || d->fftwf_plan_dft_r2c_2d == nullptr ||
+   d->fftwf_plan_dft_c2r_2d == nullptr || d->fftwf_destroy_plan == nullptr ||
+   d->fftwf_execute == nullptr || d->fftwf_execute_dft_r2c == nullptr ||
+   d->fftwf_execute_dft_c2r == nullptr
+   // required for internal threading
+   //|| d->fftwf_init_threads == nullptr || d->fftwf_plan_with_nthreads ==
+   //nullptr
+   //|| d->fftwf_cleanup_threads == nullptr || d->fftwf_cleanup == nullptr
 )
-ok = false;
-	
-// 
-/*
-code for fft dll internal threading
-numCPU = 1;
-int nThreadMult = 1;	// one thread per cpu
-
-SYSTEM_INFO sysinfo;
-GetSystemInfo(&sysinfo);
-
-numCPU = sysinfo.dwNumberOfProcessors;
-// check number of processors
-
-d->fftwf_init_threads();
+    ok = false;
 
-d->fftwf_plan_with_nthreads(nThreadMult * numCPU);
-*/
\ No newline at end of file
+// Error
+// /*
+// code for fft dll internal threading
+// numCPU = 1;
+// int nThreadMult = 1;// one thread per cpu
+// SYSTEM_INFO sysinfo;
+// GetSystemInfo(&sysinfo);
+// numCPU = sysinfo.dwNumberOfProcessors;// check number of processors
+// d->fftwf_init_threads();
+// d->fftwf_plan_with_nthreads(nThreadMult * numCPU);
+// */
+// Fix
+#ifdef _WIN32
+// code for fft dll internal threading
+// numCPU = 1;
+// int nThreadMult = 1;// one thread per cpu
+// SYSTEM_INFO sysinfo;
+// GetSystemInfo(&sysinfo);
+// numCPU = sysinfo.dwNumberOfProcessors;// check number of processors
+// d->fftwf_init_threads();
+// d->fftwf_plan_with_nthreads(nThreadMult * numCPU);
+#endif
diff --git a/ConvertBGRforInput.h b/ConvertBGRforInput.h
index da5ff90..d28b819 100644
--- a/ConvertBGRforInput.h
+++ b/ConvertBGRforInput.h
@@ -1,49 +1,43 @@
 #ifndef CONVERT_BGR_FOR_INPUT_FORMAT_V_C_MOHAN
 #define CONVERT_BGR_FOR_INPUT_FORMAT_V_C_MOHAN
 // input 8 bit bgr array. color array must be 12 bytes
+// clang-format off
 void convertBGRforInputFormat(uint8_t* color, const uint8_t* bgr, const VSFormat* fi);
 
 void convertBGRforInputFormat(uint8_t* color, const uint8_t* bgr, const VSFormat* fi)
 {
+    // clang-format on
 
-	uint8_t yuv[3];
-	
-	BGRtoYUV( bgr, yuv);
+    uint8_t yuv[3];
 
-	int nbytes = fi->bytesPerSample;
-	int nbits = fi->bitsPerSample;
+    BGRtoYUV(bgr, yuv);
 
-	for (int k = 0; k < 3; k++)
-	{
-		if (nbytes == 1)
-		{
-			if (fi->colorFamily == cmRGB)
-				color[k] = bgr[k];
-			else
-				color[k] = yuv[k];
-		}
-		else if (nbytes == 2)
-		{
-			if (fi->colorFamily == cmRGB)
-				*((uint16_t*)color + k) = (uint16_t)(bgr[k] << (nbits - 8));
-			else
-				*((uint16_t*)color + k) = (uint16_t)(yuv[k] << (nbits - 8));
-		}
-		else // float
-		{
-			if (fi->colorFamily == cmRGB)
-				*((float*)color + k) = (float)(bgr[k] / 255.0f);
-			else
-			{
-				if (k == 0)
-					*((float*)color + k) = (float)((yuv[k] - 16) / 220.0f);
-				else
-					*((float*)color + k) = (float)((yuv[k] - 128) / 220.0f);
-			}
-		}
+    int nbytes = fi->bytesPerSample;
+    int nbits = fi->bitsPerSample;
 
-	}
+    for(int k = 0; k < 3; k++) {
+        if(nbytes == 1) {
+            if(fi->colorFamily == cmRGB)
+                color[k] = bgr[k];
+            else
+                color[k] = yuv[k];
+        } else if(nbytes == 2) {
+            if(fi->colorFamily == cmRGB)
+                *((uint16_t *) color + k) = (uint16_t) (bgr[k] << (nbits - 8));
+            else
+                *((uint16_t *) color + k) = (uint16_t) (yuv[k] << (nbits - 8));
+        } else // float
+        {
+            if(fi->colorFamily == cmRGB)
+                *((float *) color + k) = (float) (bgr[k] / 255.0f);
+            else {
+                if(k == 0)
+                    *((float *) color + k) = (float) ((yuv[k] - 16) / 220.0f);
+                else
+                    *((float *) color + k) = (float) ((yuv[k] - 128) / 220.0f);
+            }
+        }
+    }
 }
 
-
-#endif
\ No newline at end of file
+#endif
diff --git a/F1QClean.cpp b/F1QClean.cpp
index 41de314..972a8cc 100644
--- a/F1QClean.cpp
+++ b/F1QClean.cpp
@@ -1,12 +1,12 @@
 /* This file contains a  f1qclean function of FFTQuiver plugin for vapoursynth
-// Row by row the image is transormed into frequency domain, frequency filtered and 
-transformed back into row. In addition to a large number of Butterworth
+// Row by row the image is transormed into frequency domain, frequency filtered
+and transformed back into row. In addition to a large number of Butterworth
 filters, filter can be custom designed.
 
   This plugin needs any one of libfftw3f-3.dll,
   FFTW3 dll, fftw.dll to reside in path (may be windows\system32 folder)
-  
-Author V.C.Mohan. 
+
+Author V.C.Mohan.
 jun 2015, 14 sep 2020, 26 May 2021
 
   Copyright (C) <2014 - 2021>  <V.C.Mohan>
@@ -22,372 +22,373 @@ jun 2015, 14 sep 2020, 26 May 2021
 
     A copy of the GNU General Public License is at
     see <http://www.gnu.org/licenses/>.
-*/	
+*/
 //---------------------------------------------------------------------------
 /*
-#include <stdlib.h>
-#include "VapourSynth.h"
 #include "VSHelper.h"
+#include "VapourSynth.h"
+#include <stdlib.h>
 
 #include  <math.h>
 #define _USE_MATH_DEFINES
-#include <vector>
-#include "windows.h"
-#include "fftwlite.h"
 #include "FQDomainHelper.h"
+#include "fftwlite.h"
+#include "windows.h"
+#include <vector>
 */
 //-----------------------------------------------------------------------------
 
+typedef struct {
+    VSNodeRef *node;
+    const VSVideoInfo *vi;
+
+    int span; // number of filters or for custo pairs specified
+    int from;
+    int upto;
+    int option;
+    int limit; // original value reduced to this %age
+    int frequency[10];
+    int nfrequencies;
+    float *ampSquareBuf; //  freq response of filter
+
+    fftwf_plan pf, pin; // fftwf creates a plan of process. pointer to it
+
+    int wbest; // wbest dimension for speed
 
-typedef struct
-{
-		VSNodeRef *node;
-		const VSVideoInfo *vi;	
-		
-		int span;		// number of filters or for custo pairs specified
-		int from;
-		int upto;
-		int option;
-		int limit; // original value reduced to this %age  
-		int frequency[10];
-		int nfrequencies;
-		float* ampSquareBuf;	//  freq response of filter 
-		
-		fftwf_plan 	pf, pin;		// fftwf creates a plan of process. pointer to it
-
-		int		wbest;	// wbest dimension for speed
-		
-		int freqWidth;
+    int freqWidth;
 
 #include "fftLateBindingClassParams.cpp"
-		float* inBuf;
-		fftwf_complex* outBuf;
-		float**sortBuf;
-	
-} F1QClean;	
-	
-class LesserThan {
-public:
+    float *inBuf;
+    fftwf_complex *outBuf;
+    float **sortBuf;
+
+} F1QClean;
 
-	template <typename finc>
-	bool operator()(const finc* f1, const finc* f2)	
-	{
-		return *f1 < *f2;
-	}
+class LesserThan {
+  public:
+    template <typename finc> bool operator()(const finc *f1, const finc *f2) {
+        return *f1 < *f2;
+    }
 };
 
-//std::sort(sortBuf, sortBuf + span, LesserThan());
+// std::sort(sortBuf, sortBuf + span, LesserThan());
 template <typename finc>
-void f1qCleanProcessFull(F1QClean* d, const finc * sp, finc *dp, const int pitch,
-			const int wd , const int ht,  finc min, finc max );
-void getAmpSqValues(float *ampSquareBuf, fftwf_complex * outBuf, int freqWidth);
+void f1qCleanProcessFull(F1QClean *d, const finc *sp, finc *dp, const int pitch,
+                         const int wd, const int ht, finc min, finc max);
+void getAmpSqValues(float *ampSquareBuf, fftwf_complex *outBuf, int freqWidth);
+
+// Error
+void cleanOutBuf(fftwf_complex *outBuf, float *ampSquareBuf, float *sortBuf,
+                 int span, int from, int upto, int freqWidth);
+
+// Fix
+void cleanOutBuf(fftwf_complex *outBuf, float *ampSquareBuf, float **sortBuf,
+                 int span, int from, int upto, int freqWidth);
+
+void limitMaxAmplitudeInSpan(fftwf_complex *outBuf, int frequency, int span,
+                             int limit);
+
+void scaleValues(fftwf_complex *outBuf, int freqWidth, float scale);
+
+// This function is called immediately after vsapi->createFilter(). This is the
+// only place where the video properties may be set. In this case we simply use
+// the same as the input clip. You may pass an array of VSVideoInfo if the
+// filter has more than one output, like rgb+alpha as two separate clips.
+static void VS_CC f1qcleanInit(VSMap *in, VSMap *out, void **instanceData,
+                               VSNode *node, VSCore *core, const VSAPI *vsapi) {
+    F1QClean *d = (F1QClean *) *instanceData;
+    vsapi->setVideoInfo(d->vi, 1, node);
 
-void cleanOutBuf(fftwf_complex* outBuf, float* ampSquareBuf, 
-				float *sortBuf, int span,int from,int upto, int freqWidth);
-void limitMaxAmplitudeInSpan(fftwf_complex* outBuf, int frequency, int span, int limit);
+    int *facbuf = (int *) vs_aligned_malloc<int>(
+        sizeof(int) * 64,
+        32); // maximum 64 factors, in this buf values filled are pairs of first
+             // is factor, second is dividend to be factored. At
+             //  a value of 1 no more factors
+    //	wbest dimensions for speed. make sure starting with even number for
+    //width
+    int wdEven = ((d->vi->width + 3) >> 2) << 2;
+    d->wbest = getBestDim(wdEven, facbuf);
 
-void scaleValues(fftwf_complex* outBuf, int freqWidth, float scale);
+    vs_aligned_free(facbuf);
 
+    d->freqWidth = d->wbest / 2 + 1;
+    d->span = ((d->span * d->freqWidth) / NYQUIST) | 1;
 
-// This function is called immediately after vsapi->createFilter(). This is the only place where the video
-// properties may be set. In this case we simply use the same as the input clip. You may pass an array
-// of VSVideoInfo if the filter has more than one output, like rgb+alpha as two separate clips.
-static void VS_CC f1qcleanInit(VSMap *in, VSMap *out, void **instanceData, VSNode *node, 
-								VSCore *core, const VSAPI *vsapi) 
-{
-    F1QClean *d = (F1QClean *) * instanceData;
-    vsapi->setVideoInfo(d->vi, 1, node);
+    if(d->option == 2) {
+        d->from = (d->from * d->freqWidth) / NYQUIST;
+        d->upto = (d->upto * d->freqWidth) / NYQUIST;
+    } else {
+        for(int i = 0; i < d->nfrequencies; i++)
 
-	int * facbuf = (int *) vs_aligned_malloc <int>(sizeof( int) *64, 32);	//maximum 64 factors, in this buf values filled are pairs of first is factor, second is dividend to be factored. At 
-								// a value of 1 no more factors	
-	//	wbest dimensions for speed. make sure starting with even number for width
-	int wdEven = ((d->vi->width + 3) >> 2) << 2;
-	d->wbest = getBestDim(wdEven, facbuf);
-	
-	vs_aligned_free(facbuf);
-
-	d->freqWidth = d->wbest / 2 + 1;
-	d->span = ((d->span * d->freqWidth) / NYQUIST) | 1;
-
-	if (d->option == 2)
-	{
-		d->from = (d->from * d->freqWidth) / NYQUIST;
-		d->upto = (d->upto * d->freqWidth) / NYQUIST;
-	}
-	else
-	{
-		for (int i = 0; i < d->nfrequencies; i ++)
-
-			d->frequency[i] = (d->frequency[i] * d->freqWidth) / NYQUIST;
-
-	}
+            d->frequency[i] = (d->frequency[i] * d->freqWidth) / NYQUIST;
+    }
 #include "ConstructorCodeForLateBindingfft.cpp"
 
-	if (!ok)
-	{
-		vsapi->setError(out, "F1QClean or F1QLimit: could not load any of the dll or get required fnctions");
-		if (d->hinstLib != NULL)
-			FreeLibrary(d->hinstLib);
-		vsapi->freeNode(d->node);
-		return;
-	}	
-	 // create fft plans. Requires buffers 
-	d->inBuf =  (float *)d->fftwf_malloc (sizeof(float) * d->wbest );
-
-	d->outBuf = (fftwf_complex*) d->fftwf_malloc (sizeof(fftwf_complex) * d->freqWidth);
-
-	if (d->option == 2) // F2QClean auto sets it to 2
-	{
-		d->ampSquareBuf = (float*)d->fftwf_malloc(sizeof(float) * d->freqWidth);	
-
-		d->sortBuf = (float**)vs_aligned_malloc(sizeof(float*) * d->span, 32);
-	}
-			// get fft sine cosine config buffers allocated by plans	
-	d->pf = d-> fftwf_plan_dft_r2c_1d( d->wbest, d->inBuf, d->outBuf, FFTW_MEASURE | FFTW_DESTROY_INPUT);
-
-	d->pin = d->fftwf_plan_dft_c2r_1d( d->wbest, d->outBuf, d->inBuf, FFTW_MEASURE | FFTW_DESTROY_INPUT);
-	
-}
+    if(!ok) {
+        vsapi->setError(out, "F1QClean or F1QLimit: could not load any of the "
+                             "dll or get required fnctions");
+        if(d->hinstLib != NULL)
+            // Error
+            //			FreeLibrary(d->hinstLib);
+            // Fix
+            if(d->hinstLib != nullptr) {
+#ifdef _WIN32
+                FreeLibrary((HINSTANCE) d->hinstLib);
+#else
+                dlclose(d->hinstLib);
+#endif
+            }
+        vsapi->freeNode(d->node);
+        return;
+    }
+    // create fft plans. Requires buffers
+    d->inBuf = (float *) d->fftwf_malloc(sizeof(float) * d->wbest);
 
-//---------------------------------------------------------------------------------------------------------------------------------
+    d->outBuf =
+        (fftwf_complex *) d->fftwf_malloc(sizeof(fftwf_complex) * d->freqWidth);
 
+    if(d->option == 2) // F2QClean auto sets it to 2
+    {
+        d->ampSquareBuf =
+            (float *) d->fftwf_malloc(sizeof(float) * d->freqWidth);
 
-template <typename finc>
+        d->sortBuf =
+            (float **) vs_aligned_malloc(sizeof(float *) * d->span, 32);
+    }
+    // get fft sine cosine config buffers allocated by plans
+    d->pf = d->fftwf_plan_dft_r2c_1d(d->wbest, d->inBuf, d->outBuf,
+                                     FFTW_MEASURE | FFTW_DESTROY_INPUT);
+
+    d->pin = d->fftwf_plan_dft_c2r_1d(d->wbest, d->outBuf, d->inBuf,
+                                      FFTW_MEASURE | FFTW_DESTROY_INPUT);
+}
 
-void f1qCleanProcessFull(F1QClean* d, const finc * sp, finc * dp, const int pitch,
-					 const int wd ,const int ht, finc min, finc max)
-{
-	float scale = 1.0f / d->wbest;
+//---------------------------------------------------------------------------------------------------------------------------------
 
-	for(int h = 0; h < ht ; h++)
-	{		
-		getRowInput(d->inBuf, sp, d->wbest, wd );
+template <typename finc>
 
-		d->fftwf_execute(d->pf);
+void f1qCleanProcessFull(F1QClean *d, const finc *sp, finc *dp, const int pitch,
+                         const int wd, const int ht, finc min, finc max) {
+    float scale = 1.0f / d->wbest;
 
-		scaleValues(d->outBuf, d->freqWidth, scale);
+    for(int h = 0; h < ht; h++) {
+        getRowInput(d->inBuf, sp, d->wbest, wd);
 
-		if (d->option == 2)		// F2QClean
-		{
-			//search  spectrum between from and upto
-			getAmpSqValues(d->ampSquareBuf, d->outBuf, d->freqWidth);
+        d->fftwf_execute(d->pf);
 
-			cleanOutBuf(d->outBuf, d->ampSquareBuf, d->sortBuf, d->span, d->from, d->upto, d->freqWidth);
-		}
+        scaleValues(d->outBuf, d->freqWidth, scale);
 
-		else if (d->option == 1)		// F2QLimit
-		{
-			for (int i = 0; i < d->nfrequencies; i++)
-			{
-				limitMaxAmplitudeInSpan(d->outBuf, d->frequency[i], d->span, d->limit);
-			}
+        if(d->option == 2) // F2QClean
+        {
+            // search  spectrum between from and upto
+            getAmpSqValues(d->ampSquareBuf, d->outBuf, d->freqWidth);
 
-		}
+            cleanOutBuf(d->outBuf, d->ampSquareBuf, d->sortBuf, d->span,
+                        d->from, d->upto, d->freqWidth);
+        }
 
-		d->fftwf_execute(d->pin);
+        else if(d->option == 1) // F2QLimit
+        {
+            for(int i = 0; i < d->nfrequencies; i++) {
+                limitMaxAmplitudeInSpan(d->outBuf, d->frequency[i], d->span,
+                                        d->limit);
+            }
+        }
 
-		getRowOutput(d->inBuf, dp, wd, min, max);
+        d->fftwf_execute(d->pin);
 
-		sp += pitch;
-		dp += pitch;
+        getRowOutput(d->inBuf, dp, wd, min, max);
 
-	}	
+        sp += pitch;
+        dp += pitch;
+    }
 }
 //....................................................................
-void getAmpSqValues(float *ampSquareBuf, fftwf_complex* outBuf, int freqWidth)
-{
-	for (int i = 0; i < freqWidth; i++)
-	{
-		ampSquareBuf[i] = getAmpSquareOfComplex(outBuf + i);
-	}
+void getAmpSqValues(float *ampSquareBuf, fftwf_complex *outBuf, int freqWidth) {
+    for(int i = 0; i < freqWidth; i++) {
+        ampSquareBuf[i] = getAmpSquareOfComplex(outBuf + i);
+    }
 }
-void scaleValues( fftwf_complex* outBuf, int freqWidth, float scale)
-{
-	for (int i = 0; i < freqWidth; i++)
-	{
-		outBuf[i][0] *= scale;
-		outBuf[i][1] *= scale;
-	}
+void scaleValues(fftwf_complex *outBuf, int freqWidth, float scale) {
+    for(int i = 0; i < freqWidth; i++) {
+        outBuf[i][0] *= scale;
+        outBuf[i][1] *= scale;
+    }
 }
 
-void cleanOutBuf(fftwf_complex* outBuf, float* ampSquareBuf,
-	float** sortBuf, int span,int from,int upto, int freqWidth)
-{
-	
-	int center = span / 2;
-
-	for (int w = from - center; w < upto - center; w++)
-	{
-		for (int s = 0; s < span; s++)
-		{
-			sortBuf[s] = ampSquareBuf + w + s;
-		}
-		std::sort(sortBuf, sortBuf + span, LesserThan());
-		int median = (int)(sortBuf[center] - ampSquareBuf);
-		if (ampSquareBuf[w + center] > *(sortBuf [center]))
-		{
-			outBuf[w + center][0] = outBuf[median][0];
-			outBuf[w + center][1] = outBuf[median][1];
-		}
-	}
-	
+void cleanOutBuf(fftwf_complex *outBuf, float *ampSquareBuf, float **sortBuf,
+                 int span, int from, int upto, int freqWidth) {
+
+    int center = span / 2;
+
+    for(int w = from - center; w < upto - center; w++) {
+        for(int s = 0; s < span; s++) {
+            sortBuf[s] = ampSquareBuf + w + s;
+        }
+        std::sort(sortBuf, sortBuf + span, LesserThan());
+        int median = (int) (sortBuf[center] - ampSquareBuf);
+        if(ampSquareBuf[w + center] > *(sortBuf[center])) {
+            outBuf[w + center][0] = outBuf[median][0];
+            outBuf[w + center][1] = outBuf[median][1];
+        }
+    }
 }
 
-void limitMaxAmplitudeInSpan(fftwf_complex * outBuf, int frequency, int span, int limit)
-{
-	float max = 0.0f;
-	float local;
-	float lim = limit / 100.0f;
-	int point = 0;
-
-	for (int i = frequency - span; i < frequency + span; i++)
-	{
-		local = getAmpSquareOfComplex(outBuf + i);
-		if (local > max)
-		{
-			max = local;
-			point = i;
-		}
-	}
-	// point and neighbours are zeroed
-	for (int i = point - 1; i <= point + 1; i++)
-	{
-		outBuf[i][0] *= lim;
-		outBuf[i][1] *= lim;
-	}
+void limitMaxAmplitudeInSpan(fftwf_complex *outBuf, int frequency, int span,
+                             int limit) {
+    float max = 0.0f;
+    float local;
+    float lim = limit / 100.0f;
+    int point = 0;
+
+    for(int i = frequency - span; i < frequency + span; i++) {
+        local = getAmpSquareOfComplex(outBuf + i);
+        if(local > max) {
+            max = local;
+            point = i;
+        }
+    }
+    // point and neighbours are zeroed
+    for(int i = point - 1; i <= point + 1; i++) {
+        outBuf[i][0] *= lim;
+        outBuf[i][1] *= lim;
+    }
 }
 
-
 //---------------------------------------------------------------------------------------------------------
-// This is the main function that gets called when a frame should be produced. It will, in most cases, get
-// called several times to produce one frame. This state is being kept track of by the value of
-// activationReason. The first call to produce a certain frame n is always arInitial. In this state
-// you should request all the input frames you need. Always do it in ascending order to play nice with the
-// upstream filters.
-// Once all frames are ready, the filter will be called with arAllFramesReady. It is now time to
-// do the actual processing.
-static const VSFrameRef *VS_CC f1qcleanGetFrame(int n, int activationReason, void **instanceData, void **frameData,
-						VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi)
-{
-    F1QClean *d = (F1QClean *) * instanceData;
-
-    if (activationReason == arInitial)
-	{
+// This is the main function that gets called when a frame should be produced.
+// It will, in most cases, get called several times to produce one frame. This
+// state is being kept track of by the value of activationReason. The first call
+// to produce a certain frame n is always arInitial. In this state you should
+// request all the input frames you need. Always do it in ascending order to
+// play nice with the upstream filters. Once all frames are ready, the filter
+// will be called with arAllFramesReady. It is now time to do the actual
+// processing.
+static const VSFrameRef *VS_CC f1qcleanGetFrame(
+    int n, int activationReason, void **instanceData, void **frameData,
+    VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) {
+    F1QClean *d = (F1QClean *) *instanceData;
+
+    if(activationReason == arInitial) {
         // Request the source frame on the first call
         vsapi->requestFrameFilter(n, d->node, frameCtx);
-    } 
-	else if (activationReason == arAllFramesReady)
-	{
-		
-		const VSFrameRef* src = vsapi->getFrameFilter(n, d->node, frameCtx);
-
-		const VSFormat* fi = d->vi->format;
-		// process R,G,B or  Y component only will be processed
-		int nplanes = fi->colorFamily == cmRGB ? 3 : fi->numPlanes;
-		
-		VSFrameRef* dst = vsapi->copyFrame(src, core);
-
-		int nbytes = fi->bytesPerSample;
-		int nbits = fi->bitsPerSample;
-
-		for (int p = 0; p < nplanes; p++)
-		{
-			int ht = vsapi->getFrameHeight(src, p);
-			int wd = vsapi->getFrameWidth(src, p);
-
-			const uint8_t* srcp = vsapi->getReadPtr(src, p);
-			int src_stride = vsapi->getStride(src, p);
-			uint8_t* dstp = vsapi->getWritePtr(dst, p);
-			int pitch = src_stride / nbytes;
-
-			if (fi->sampleType == stInteger && nbits == 8)
-			{
-				uint8_t max = (1 << nbits) - 1, min = 0;
-
-				f1qCleanProcessFull(d, srcp, dstp, pitch,
-					wd, ht, min, max);
-			}
-
-			else if (fi->sampleType == stInteger && nbits > 8)
-			{
-				uint16_t* dp = (uint16_t*)dstp;
-
-				const uint16_t* sp = (const uint16_t*)srcp;
-
-				uint16_t max = (1 << nbits) - 1, min = 0;
-
-				f1qCleanProcessFull(d, sp, dp, pitch,
-					wd, ht, min, max);
-			}
-
-			else // float
-			{
-				float* dp = (float*)dstp;
-
-				const float* sp = (const float*)srcp;
-
-				float max = 1.0f, min = 0.0f;
-
-				f1qCleanProcessFull(d, sp, dp, pitch,
-					wd, ht, min, max);
-			}
-		}
-			// Release the source frame
-		vsapi->freeFrame(src);				
-		return dst;
+    } else if(activationReason == arAllFramesReady) {
+
+        const VSFrameRef *src = vsapi->getFrameFilter(n, d->node, frameCtx);
+
+        const VSFormat *fi = d->vi->format;
+        // process R,G,B or  Y component only will be processed
+        int nplanes = fi->colorFamily == cmRGB ? 3 : fi->numPlanes;
+
+        VSFrameRef *dst = vsapi->copyFrame(src, core);
+
+        int nbytes = fi->bytesPerSample;
+        int nbits = fi->bitsPerSample;
+
+        for(int p = 0; p < nplanes; p++) {
+            int ht = vsapi->getFrameHeight(src, p);
+            int wd = vsapi->getFrameWidth(src, p);
+
+            const uint8_t *srcp = vsapi->getReadPtr(src, p);
+            int src_stride = vsapi->getStride(src, p);
+            uint8_t *dstp = vsapi->getWritePtr(dst, p);
+            int pitch = src_stride / nbytes;
+
+            if(fi->sampleType == stInteger && nbits == 8) {
+                uint8_t max = (1 << nbits) - 1, min = 0;
+
+                f1qCleanProcessFull(d, srcp, dstp, pitch, wd, ht, min, max);
+            }
+
+            else if(fi->sampleType == stInteger && nbits > 8) {
+                uint16_t *dp = (uint16_t *) dstp;
+
+                const uint16_t *sp = (const uint16_t *) srcp;
+
+                uint16_t max = (1 << nbits) - 1, min = 0;
+
+                f1qCleanProcessFull(d, sp, dp, pitch, wd, ht, min, max);
+            }
+
+            else // float
+            {
+                float *dp = (float *) dstp;
+
+                const float *sp = (const float *) srcp;
+
+                float max = 1.0f, min = 0.0f;
+
+                f1qCleanProcessFull(d, sp, dp, pitch, wd, ht, min, max);
+            }
+        }
+        // Release the source frame
+        vsapi->freeFrame(src);
+        return dst;
     }
 
     return 0;
 }
 
 // Free all allocated data on filter destruction
-static void VS_CC f1qcleanFree(void *instanceData, VSCore *core, const VSAPI *vsapi)
-{
-    F1QClean *d = (F1QClean *)instanceData;
+static void VS_CC f1qcleanFree(void *instanceData, VSCore *core,
+                               const VSAPI *vsapi) {
+    F1QClean *d = (F1QClean *) instanceData;
     vsapi->freeNode(d->node);
-	if (d->option == 2)
-	{
-		d->fftwf_free(d->ampSquareBuf);
-		vs_aligned_free(d->sortBuf);
-	}
-	d->fftwf_free(d->inBuf);
-	d->fftwf_free(d->outBuf);
-	d->fftwf_destroy_plan(d->pf);
-	d->fftwf_destroy_plan(d->pin);
-	if (d->hinstLib != NULL)
-		FreeLibrary(d->hinstLib);
-	
+    if(d->option == 2) {
+        d->fftwf_free(d->ampSquareBuf);
+        vs_aligned_free(d->sortBuf);
+    }
+    d->fftwf_free(d->inBuf);
+    d->fftwf_free(d->outBuf);
+    d->fftwf_destroy_plan(d->pf);
+    d->fftwf_destroy_plan(d->pin);
+
+    // Error
+    // if (d->hinstLib != NULL)
+    //     FreeLibrary(d->hinstLib);
+    // Fix
+    if(d->hinstLib != nullptr) {
+#ifdef _WIN32
+        FreeLibrary((HINSTANCE) d->hinstLib);
+#else
+        dlclose(d->hinstLib);
+#endif
+    }
+
     free(d);
 }
 
-// This function is responsible for validating arguments and creating a new filter
-static void VS_CC f1qcleanCreate(const VSMap *in, VSMap *out, void *userData, VSCore *core, const VSAPI *vsapi)
-{
+// This function is responsible for validating arguments and creating a new
+// filter
+static void VS_CC f1qcleanCreate(const VSMap *in, VSMap *out, void *userData,
+                                 VSCore *core, const VSAPI *vsapi) {
     F1QClean d;
     F1QClean *data;
     int err;
-	//int temp;
-    // Get a clip reference from the input arguments. This must be freed later.
+    // int temp;
+    //  Get a clip reference from the input arguments. This must be freed later.
     d.node = vsapi->propGetNode(in, "clip", 0, 0);
     d.vi = vsapi->getVideoInfo(d.node);
 
-    // In this first version we only want to handle 8bit integer formats. Note that
-    // vi->format can be 0 if the input clip can change format midstream.
-    if (!isConstantFormat(d.vi) || d.vi->width == 0 || d.vi->height == 0 
-		|| (d.vi->format->colorFamily != cmYUV 	&& d.vi->format->colorFamily != cmGray
-			 &&  d.vi->format->colorFamily != cmRGB) )
-	{
-        vsapi->setError(out, "F1QClean: only RGB, Yuv or Gray color constant formats and const frame dimensions input supported");
+    // In this first version we only want to handle 8bit integer formats. Note
+    // that vi->format can be 0 if the input clip can change format midstream.
+    if(!isConstantFormat(d.vi) || d.vi->width == 0 || d.vi->height == 0 ||
+       (d.vi->format->colorFamily != cmYUV &&
+        d.vi->format->colorFamily != cmGray &&
+        d.vi->format->colorFamily != cmRGB)) {
+        vsapi->setError(out,
+                        "F1QClean: only RGB, Yuv or Gray color constant "
+                        "formats and const frame dimensions input supported");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    if(d.vi->format->sampleType == stFloat &&
+       d.vi->format->bitsPerSample == 16) {
+        vsapi->setError(out, "F1QClean: Half float formats not allowed ");
         vsapi->freeNode(d.node);
         return;
     }
-	
-	if (d.vi->format->sampleType == stFloat && d.vi->format->bitsPerSample == 16)
-	{
-		vsapi->setError(out, "F1QClean: Half float formats not allowed ");
-		vsapi->freeNode(d.node);
-		return;
-	}
 
     // If a property read fails for some reason (index out of bounds/wrong type)
     // then err will have flags set to indicate why and 0 will be returned. This
@@ -395,136 +396,139 @@ static void VS_CC f1qcleanCreate(const VSMap *in, VSMap *out, void *userData, VS
     // strict checking because of what we wrote in the argument string, the only
     // reason this could fail is when the value wasn't set by the user.
     // And when it's not set we want it to default to enabled.
-	d.option = 2;
-	d.limit = 0;
-	d.span = 3;
-	d.from = int64ToIntS(vsapi->propGetInt(in, "span", 0, &err));
-	if (err)
-		d.span = 5;
-	else if (d.span < 3 || d.span > 63 || (d.span & 1 ) == 0 )
-	{
-		vsapi->setError(out, "F1QClean: span must be be odd number between 3 and 63 ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-	
-	d.from = int64ToIntS(vsapi->propGetInt(in, "fromf", 0, &err));
-	if (err)
-		d.from = 30;
-	
-	else if (d.from < 10 + d.span / 2 || d.from > NYQUIST / 2 - 11 - d.span / 2)
-	{
-		vsapi->setError(out, "F1QClean: fromf must be be between 10 + half of span and less than  245 - half of span ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-
-	d.upto = int64ToIntS(vsapi->propGetInt(in, "upto", 0, &err));
-	if (err)
-		d.upto = NYQUIST -  10 - d.span;
-	
-	else if (d.upto < d.from + d.span  || d.upto > NYQUIST - 10 - d.span)
-	{
-		vsapi->setError(out, "F1QClean: upto can be between fromf + span to  502 - span  ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-	
+    d.option = 2;
+    d.limit = 0;
+    d.span = 3;
+    d.from = int64ToIntS(vsapi->propGetInt(in, "span", 0, &err));
+    if(err)
+        d.span = 5;
+    else if(d.span < 3 || d.span > 63 || (d.span & 1) == 0) {
+        vsapi->setError(
+            out, "F1QClean: span must be be odd number between 3 and 63 ");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    d.from = int64ToIntS(vsapi->propGetInt(in, "fromf", 0, &err));
+    if(err)
+        d.from = 30;
+
+    else if(d.from < 10 + d.span / 2 ||
+            d.from > NYQUIST / 2 - 11 - d.span / 2) {
+        vsapi->setError(out, "F1QClean: fromf must be be between 10 + half of "
+                             "span and less than  245 - half of span ");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    d.upto = int64ToIntS(vsapi->propGetInt(in, "upto", 0, &err));
+    if(err)
+        d.upto = NYQUIST - 10 - d.span;
+
+    else if(d.upto < d.from + d.span || d.upto > NYQUIST - 10 - d.span) {
+        vsapi->setError(
+            out, "F1QClean: upto can be between fromf + span to  502 - span  ");
+        vsapi->freeNode(d.node);
+        return;
+    }
 
     // I usually keep the filter data struct on the stack and don't allocate it
     // until all the input validation is done.
     data = (F1QClean *) malloc(sizeof(d));
     *data = d;
 
-	vsapi->createFilter(in, out, "F1QClean", f1qcleanInit, f1qcleanGetFrame, f1qcleanFree, fmParallelRequests, 0, data, core);
-
+    vsapi->createFilter(in, out, "F1QClean", f1qcleanInit, f1qcleanGetFrame,
+                        f1qcleanFree, fmParallelRequests, 0, data, core);
 }
 
-// registerFunc("F1QClean", "clip:clip;span:int:opt;fromf:int:opt;upto:int:opt;", f1qcleanCreate, 0, plugin);
-
-// This function is responsible for validating arguments and creating a new filter
-static void VS_CC f1qlimitCreate(const VSMap* in, VSMap* out, void* userData, VSCore* core, const VSAPI* vsapi)
-{
-	F1QClean d;
-	F1QClean* data;
-	int err;
-	//int temp;
-	// Get a clip reference from the input arguments. This must be freed later.
-	d.node = vsapi->propGetNode(in, "clip", 0, 0);
-	d.vi = vsapi->getVideoInfo(d.node);
-	// vi->format can be 0 if the input clip can change format midstream.
-	if (!isConstantFormat(d.vi) || d.vi->width == 0 || d.vi->height == 0
-		|| (d.vi->format->colorFamily != cmYUV && d.vi->format->colorFamily != cmGray
-			&& d.vi->format->colorFamily != cmRGB))
-	{
-		vsapi->setError(out, "F1QLimit: only RGB, Yuv or Gray color constant formats and const frame dimensions input supported");
-		vsapi->freeNode(d.node);
-		return;
-	}
-
-	if (d.vi->format->sampleType == stFloat && d.vi->format->bitsPerSample == 16)
-	{
-		vsapi->setError(out, "F1QLimit: Half float formats not allowed ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-
-	// If a property read fails for some reason (index out of bounds/wrong type)
-	// then err will have flags set to indicate why and 0 will be returned. This
-	// can be very useful to know when having optional arguments. Since we have
-	// strict checking because of what we wrote in the argument string, the only
-	// reason this could fail is when the value wasn't set by the user.
-	// And when it's not set we want it to default to enabled.
-	d.option = 1;	
-	d.span = int64ToIntS(vsapi->propGetInt(in, "span", 0, &err));
-	if (err)
-		d.span =  15;
-	else if (d.span < 3 || d.span > NYQUIST / 8 || (d.span & 1) == 0)
-		{
-			vsapi->setError(out, "F1QLimit: span must  be odd number  3 to 63");
-			vsapi->freeNode(d.node);
-			return;
-		}
-	d.span |= 1;	// make it odd number
-
-	d.limit = int64ToIntS(vsapi->propGetInt(in, "limit", 0, &err));
-	if (err)
-		d.limit = 50;
-	else if (d.limit < 0 || d.limit > 99)
-	{
-		vsapi->setError(out, "F1QLimit: limit percentage value can be 0 to 99");
-		vsapi->freeNode(d.node);
-		return;
-	}
-	
-	d.nfrequencies = vsapi->propNumElements(in, "freqs");
-	if (d.nfrequencies == 0 || d.nfrequencies > 10)
-	{
-		vsapi->setError(out, "F1QLimit: for option 1, at least one and not more than 10 freqs must be specified in the array");
-		vsapi->freeNode(d.node);
-		return;
-	}
-
-	for (int i = 0; i < d.nfrequencies; i++)
-	{
-		d.frequency[i] = int64ToIntS(vsapi->propGetInt(in, "freqs", i, 0));
-		if (d.frequency[i] < 10 + d.span / 2 || d.frequency[i] > NYQUIST - 10 - d.span / 2)
-		{
-			vsapi->setError(out, "F1QLimit:  freqs must be between 10 + half of span and 502 - half of span");
-			vsapi->freeNode(d.node);
-			return;
-		}
-
-	}
-	
-
-	// I usually keep the filter data struct on the stack and don't allocate it
-	// until all the input validation is done.
-	data = (F1QClean*)malloc(sizeof(d));
-	*data = d;
-
-	vsapi->createFilter(in, out, "F1QLimit", f1qcleanInit, f1qcleanGetFrame, f1qcleanFree, fmParallelRequests, 0, data, core);
+// registerFunc("F1QClean",
+// "clip:clip;span:int:opt;fromf:int:opt;upto:int:opt;", f1qcleanCreate, 0,
+// plugin);
+
+// This function is responsible for validating arguments and creating a new
+// filter
+static void VS_CC f1qlimitCreate(const VSMap *in, VSMap *out, void *userData,
+                                 VSCore *core, const VSAPI *vsapi) {
+    F1QClean d;
+    F1QClean *data;
+    int err;
+    // int temp;
+    //  Get a clip reference from the input arguments. This must be freed later.
+    d.node = vsapi->propGetNode(in, "clip", 0, 0);
+    d.vi = vsapi->getVideoInfo(d.node);
+    // vi->format can be 0 if the input clip can change format midstream.
+    if(!isConstantFormat(d.vi) || d.vi->width == 0 || d.vi->height == 0 ||
+       (d.vi->format->colorFamily != cmYUV &&
+        d.vi->format->colorFamily != cmGray &&
+        d.vi->format->colorFamily != cmRGB)) {
+        vsapi->setError(out,
+                        "F1QLimit: only RGB, Yuv or Gray color constant "
+                        "formats and const frame dimensions input supported");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    if(d.vi->format->sampleType == stFloat &&
+       d.vi->format->bitsPerSample == 16) {
+        vsapi->setError(out, "F1QLimit: Half float formats not allowed ");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    // If a property read fails for some reason (index out of bounds/wrong type)
+    // then err will have flags set to indicate why and 0 will be returned. This
+    // can be very useful to know when having optional arguments. Since we have
+    // strict checking because of what we wrote in the argument string, the only
+    // reason this could fail is when the value wasn't set by the user.
+    // And when it's not set we want it to default to enabled.
+    d.option = 1;
+    d.span = int64ToIntS(vsapi->propGetInt(in, "span", 0, &err));
+    if(err)
+        d.span = 15;
+    else if(d.span < 3 || d.span > NYQUIST / 8 || (d.span & 1) == 0) {
+        vsapi->setError(out, "F1QLimit: span must  be odd number  3 to 63");
+        vsapi->freeNode(d.node);
+        return;
+    }
+    d.span |= 1; // make it odd number
+
+    d.limit = int64ToIntS(vsapi->propGetInt(in, "limit", 0, &err));
+    if(err)
+        d.limit = 50;
+    else if(d.limit < 0 || d.limit > 99) {
+        vsapi->setError(out, "F1QLimit: limit percentage value can be 0 to 99");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    d.nfrequencies = vsapi->propNumElements(in, "freqs");
+    if(d.nfrequencies == 0 || d.nfrequencies > 10) {
+        vsapi->setError(out,
+                        "F1QLimit: for option 1, at least one and not more "
+                        "than 10 freqs must be specified in the array");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    for(int i = 0; i < d.nfrequencies; i++) {
+        d.frequency[i] = int64ToIntS(vsapi->propGetInt(in, "freqs", i, 0));
+        if(d.frequency[i] < 10 + d.span / 2 ||
+           d.frequency[i] > NYQUIST - 10 - d.span / 2) {
+            vsapi->setError(out, "F1QLimit:  freqs must be between 10 + half "
+                                 "of span and 502 - half of span");
+            vsapi->freeNode(d.node);
+            return;
+        }
+    }
+
+    // I usually keep the filter data struct on the stack and don't allocate it
+    // until all the input validation is done.
+    data = (F1QClean *) malloc(sizeof(d));
+    *data = d;
 
+    vsapi->createFilter(in, out, "F1QLimit", f1qcleanInit, f1qcleanGetFrame,
+                        f1qcleanFree, fmParallelRequests, 0, data, core);
 }
 
-// registerFunc("F1QLimit", "clip:clip;span:int:opt;freqs:int[];", f1qlimitCreate, 0, plugin);
\ No newline at end of file
+// registerFunc("F1QLimit", "clip:clip;span:int:opt;freqs:int[];",
+// f1qlimitCreate, 0, plugin);
diff --git a/F1Quiver.cpp b/F1Quiver.cpp
index 7ad3b01..df37e20 100644
--- a/F1Quiver.cpp
+++ b/F1Quiver.cpp
@@ -1,12 +1,12 @@
 /* This file contains a  f1quiver function of FFTQuiver plugin for vapoursynth
-// Row by row the image is transormed into frequency domain, frequency filtered and 
-transformed back into row. In addition to a large number of Butterworth
+// Row by row the image is transormed into frequency domain, frequency filtered
+and transformed back into row. In addition to a large number of Butterworth
 filters, filter can be custom designed.
 
   This plugin needs any one of libfftw3f-3.dll,
   FFTW3 dll, fftw.dll to reside in path (may be windows\system32 folder)
-  
-Author V.C.Mohan. 
+
+Author V.C.Mohan.
 jun 2015, 14 sep 2020, 18 May 2021
 
   Copyright (C) <2014 - 2021>  <V.C.Mohan>
@@ -22,628 +22,652 @@ jun 2015, 14 sep 2020, 18 May 2021
 
     A copy of the GNU General Public License is at
     see <http://www.gnu.org/licenses/>.
-*/	
+*/
 //---------------------------------------------------------------------------
 /*
-#include <stdlib.h>
-#include "VapourSynth.h"
 #include "VSHelper.h"
+#include "VapourSynth.h"
+#include <stdlib.h>
 
 #include  <math.h>
 #define _USE_MATH_DEFINES
-#include <vector>
-#include "windows.h"
-#include "fftwlite.h"
 #include "FQDomainHelper.h"
+#include "fftwlite.h"
+#include "windows.h"
+#include <vector>
 */
 //-----------------------------------------------------------------------------
 
+typedef struct {
+    VSNodeRef *node;
+    const VSVideoInfo *vi;
+
+    bool test;   // is this a test?
+    int row;     // test this start row
+    int nrows;   //  number of rows to average to test
+    float gamma; // for spectrum scaling
+    bool morph;  // is homomorphic process required
+    bool custom; // filter is custom designed
+    int Fspec[64];
+    int npoints; // number of filters or for custo pairs specified
 
-typedef struct
-{
-		VSNodeRef *node;
-		const VSVideoInfo *vi;
-	
-		bool  	test;		// is this a test?
-		int  	row;		// test this start row
-		int 	nrows;		//  number of rows to average to test
-		float 	gamma;		// for spectrum scaling
-		bool 	morph;		// is homomorphic process required	
-		bool 	custom;		// filter is custom designed
-		int		Fspec[64];
-		int 	npoints;		// number of filters or for custo pairs specified
-
-		float* FreqFilter;	//  freq response of filter 
-		float* logLUT;
-		fftwf_plan 	pf, pin;		// fftwf creates a plan of process. pointer to it
-
-		int		wbest;	// wbest dimension for speed
-		int 	nfft;	// number of points in this fft
-		
+    float *FreqFilter; //  freq response of filter
+    float *logLUT;
+    fftwf_plan pf, pin; // fftwf creates a plan of process. pointer to it
+
+    int wbest; // wbest dimension for speed
+    int nfft;  // number of points in this fft
 
 #include "fftLateBindingClassParams.cpp"
-		float* inBuf;
-		fftwf_complex* outBuf;
+    float *inBuf;
+    fftwf_complex *outBuf;
 
-	
 } F1QuiverData;
 
-	// filter designing functions
-	//void f1BuildFilterCascade(float * FreqFilter, int * filterSpec, int nfft, int npoints);
-
-	//void f1BuildCustomFilter(float * FrqFilt, int * specs, int nfft, int nval);
-	
-	//template <typename finc>
-	//void f1DisplayHorizontalScale(int nyq, int wbest, int panelh, int wd, int pitch, finc * dp, finc max);
-	template <typename finc>
-	void f1DisplayPowerSpectrumAndFilter(float * powerspect, float * FreqFilter, float pscale, float pmax, float gamma, int panelh,int nfft,
-						int wd, int pitch, finc * dp, finc max );
-	template <typename finc>
-	float f1GetSummedPowerspectrum(void** instanceData, float * in, fftwf_complex* out, float * powerspect,
-		const finc * sp, const int pitch, const int wd);
-
-	template <typename finc>
-	void f1ProcessFullFrame(F1QuiverData* d, float * in, fftwf_complex* out,
-		const finc * sp, finc *dp, const int pitch, const int wd , const int ht,finc min, finc max, float * LUT );
-
-
-// This function is called immediately after vsapi->createFilter(). This is the only place where the video
-// properties may be set. In this case we simply use the same as the input clip. You may pass an array
-// of VSVideoInfo if the filter has more than one output, like rgb+alpha as two separate clips.
-static void VS_CC f1quiverInit(VSMap *in, VSMap *out, void **instanceData, VSNode *node, 
-								VSCore *core, const VSAPI *vsapi) 
-{
-    F1QuiverData *d = (F1QuiverData *) * instanceData;
+// filter designing functions
+// void f1BuildFilterCascade(float * FreqFilter, int * filterSpec, int nfft, int
+// npoints);
+
+// void f1BuildCustomFilter(float * FrqFilt, int * specs, int nfft, int nval);
+
+// template <typename finc>
+// void f1DisplayHorizontalScale(int nyq, int wbest, int panelh, int wd, int
+// pitch, finc * dp, finc max);
+template <typename finc>
+void f1DisplayPowerSpectrumAndFilter(float *powerspect, float *FreqFilter,
+                                     float pscale, float pmax, float gamma,
+                                     int panelh, int nfft, int wd, int pitch,
+                                     finc *dp, finc max);
+template <typename finc>
+float f1GetSummedPowerspectrum(void **instanceData, float *in,
+                               fftwf_complex *out, float *powerspect,
+                               const finc *sp, const int pitch, const int wd);
+
+template <typename finc>
+void f1ProcessFullFrame(F1QuiverData *d, float *in, fftwf_complex *out,
+                        const finc *sp, finc *dp, const int pitch, const int wd,
+                        const int ht, finc min, finc max, float *LUT);
+
+// This function is called immediately after vsapi->createFilter(). This is the
+// only place where the video properties may be set. In this case we simply use
+// the same as the input clip. You may pass an array of VSVideoInfo if the
+// filter has more than one output, like rgb+alpha as two separate clips.
+static void VS_CC f1quiverInit(VSMap *in, VSMap *out, void **instanceData,
+                               VSNode *node, VSCore *core, const VSAPI *vsapi) {
+    F1QuiverData *d = (F1QuiverData *) *instanceData;
     vsapi->setVideoInfo(d->vi, 1, node);
 
-	int * facbuf = (int *) vs_aligned_malloc <int>(sizeof( int) *64, 32);	//maximum 64 factors, in this buf values filled are pairs of first is factor, second is dividend to be factored. At 
-								// a value of 1 no more factors	
-	//	wbest dimensions for speed. make sure starting with even number for width
-	int wdEven = ((d->vi->width + 1) >> 1) << 1;
-	d->wbest = getBestDim(wdEven, facbuf);
-	
-	vs_aligned_free(facbuf);	
+    int *facbuf = (int *) vs_aligned_malloc<int>(
+        sizeof(int) * 64,
+        32); // maximum 64 factors, in this buf values filled are pairs of first
+             // is factor, second is dividend to be factored. At
+             //  a value of 1 no more factors
+    //	wbest dimensions for speed. make sure starting with even number for
+    //width
+    int wdEven = ((d->vi->width + 1) >> 1) << 1;
+    d->wbest = getBestDim(wdEven, facbuf);
 
+    vs_aligned_free(facbuf);
 
 #include "ConstructorCodeForLateBindingfft.cpp"
 
-	if (!ok)
-	{
-		vsapi->setError(out, "vcm.f1quiver: could not load any of the dll or get required fnctions");
-		if (d->hinstLib != NULL)
-			FreeLibrary(d->hinstLib);
-
-		vsapi->freeNode(d->node);
-		return;
-	}
-
-	
-	 // create fft plans. Requires buffers temporarily
-	d->inBuf =  (float *)d->fftwf_malloc (sizeof(float) * d->wbest );
-
-	d->outBuf = (fftwf_complex*) d->fftwf_malloc (sizeof(fftwf_complex) * (d->wbest/2+1));
-
-	d->FreqFilter = (float*)d->fftwf_malloc(sizeof(float) * (d->wbest / 2 + 1));	// filter buffer
-
-			// get fft sine cosine config buffers allocated by plan
-	
-	d->pf = d-> fftwf_plan_dft_r2c_1d( d->wbest, d->inBuf, d->outBuf, FFTW_MEASURE | FFTW_DESTROY_INPUT);
-
-	d->pin = d->fftwf_plan_dft_c2r_1d( d->wbest, d->outBuf, d->inBuf, FFTW_MEASURE | FFTW_DESTROY_INPUT);
-
-	
-			// initialize freq response buffer with value of one
-	for(int i = 0; i < d->wbest / 2 + 1; i ++)
-		// all ones. will be multiplied by each filter with its constants (cascading)
-		d->FreqFilter[i] = 1.0;			
-	
-	if (d->custom)
-	{
-		
-		f1BuildCustomFilter( d->FreqFilter, d->Fspec, d->wbest,  d->npoints);
-	}
-	else
-	{
-		// Freq filters of all Input params are built and cascaded
-		f1BuildFilterCascade(d->FreqFilter, d->Fspec, d->wbest, d->npoints);	
-	}
-
-	// normalize and scale by 1/ nfft 
-	float fmax = 0;
-
-	for( int i = 0; i <= d->wbest / 2; i ++)
-	{
-		fmax = fmax >= d->FreqFilter[i] ? fmax : d->FreqFilter[i];
-	}
-
-	float fscaler = 1.0f / (d->wbest * fmax);	// as fft scales up by nfft we compensate it here
-
-	for(int i = 0; i <= d->wbest / 2; i ++)
-		d->FreqFilter[i] *= fscaler;
-
-	int nbits = d->vi->format->bitsPerSample;	
-
-	if (d->morph && nbits >= 8 && nbits <= 12)
-	{
-		int nl = 1 << nbits;
-		d->logLUT = (float*)d->fftwf_malloc(sizeof(float) * nl);
-
-		for (int i = 0; i < nl; i++)
-			d->logLUT[i] = (float)log((float)i);
-	}
-	else
-		d->logLUT = NULL;
+    if(!ok) {
+        vsapi->setError(out, "vcm.f1quiver: could not load any of the dll or "
+                             "get required fnctions");
+        // Error
+        // if (d->hinstLib != NULL)
+        //     FreeLibrary(d->hinstLib);
+        // Fix
+        if(d->hinstLib != NULL) {
+#ifdef _WIN32
+            FreeLibrary((HINSTANCE) d->hinstLib);
+#else
+            if(d->hinstLib)
+                dlclose(d->hinstLib);
+#endif
+        }
+        vsapi->freeNode(d->node);
+        return;
+    }
+
+    // create fft plans. Requires buffers temporarily
+    d->inBuf = (float *) d->fftwf_malloc(sizeof(float) * d->wbest);
+
+    d->outBuf = (fftwf_complex *) d->fftwf_malloc(sizeof(fftwf_complex) *
+                                                  (d->wbest / 2 + 1));
+
+    d->FreqFilter = (float *) d->fftwf_malloc(
+        sizeof(float) * (d->wbest / 2 + 1)); // filter buffer
+
+    // get fft sine cosine config buffers allocated by plan
+
+    d->pf = d->fftwf_plan_dft_r2c_1d(d->wbest, d->inBuf, d->outBuf,
+                                     FFTW_MEASURE | FFTW_DESTROY_INPUT);
+
+    d->pin = d->fftwf_plan_dft_c2r_1d(d->wbest, d->outBuf, d->inBuf,
+                                      FFTW_MEASURE | FFTW_DESTROY_INPUT);
+
+    // initialize freq response buffer with value of one
+    for(int i = 0; i < d->wbest / 2 + 1; i++)
+        // all ones. will be multiplied by each filter with its constants
+        // (cascading)
+        d->FreqFilter[i] = 1.0;
+
+    if(d->custom) {
+
+        f1BuildCustomFilter(d->FreqFilter, d->Fspec, d->wbest, d->npoints);
+    } else {
+        // Freq filters of all Input params are built and cascaded
+        f1BuildFilterCascade(d->FreqFilter, d->Fspec, d->wbest, d->npoints);
+    }
+
+    // normalize and scale by 1/ nfft
+    float fmax = 0;
+
+    for(int i = 0; i <= d->wbest / 2; i++) {
+        fmax = fmax >= d->FreqFilter[i] ? fmax : d->FreqFilter[i];
+    }
+
+    float fscaler =
+        1.0f /
+        (d->wbest * fmax); // as fft scales up by nfft we compensate it here
+
+    for(int i = 0; i <= d->wbest / 2; i++)
+        d->FreqFilter[i] *= fscaler;
+
+    int nbits = d->vi->format->bitsPerSample;
+
+    if(d->morph && nbits >= 8 && nbits <= 12) {
+        int nl = 1 << nbits;
+        d->logLUT = (float *) d->fftwf_malloc(sizeof(float) * nl);
+
+        for(int i = 0; i < nl; i++)
+            d->logLUT[i] = (float) log((float) i);
+    } else
+        d->logLUT = NULL;
 }
 
 //---------------------------------------------------------------------------------------------------------------------------------
 
 template <typename finc>
-void f1DisplayPowerSpectrumAndFilter(float * powerspect, float * FreqFilter, float pscale, 
-									float pmax, float gamma, int panelh,int nfft,
-									int wd, int pitch, finc * dp, finc max )
-{
-	// pmax = 1.0;
-	for(int i = 0; i < wd / 2; i++)
-	{
-					//power spectrum
-		for (int h = 0; h <  (powerspect[i] * pscale) / pmax; h ++)
-		{
-
-			dp[(2 * panelh + 20 - h) * pitch +  i] = max; // normal scale
-		}				
-						// exp gamma scale
-		for(int h = 0; h < pow(powerspect[i]  / pmax, gamma) * pscale; h ++)
-		{
-
-			dp[(panelh - h) * pitch + i] = max; // gamma scale
-		}
-					
-					// designed filter
-		dp[(panelh - (int)(pscale * FreqFilter[i] * nfft)) * pitch + i] = (max + max) / 3;
-		// to make it bold 2 pixel wide
-		dp[(panelh + 1 - (int)(pscale * FreqFilter[i] * nfft)) * pitch +  i] = (max + max) / 3;
-		
-	}
+void f1DisplayPowerSpectrumAndFilter(float *powerspect, float *FreqFilter,
+                                     float pscale, float pmax, float gamma,
+                                     int panelh, int nfft, int wd, int pitch,
+                                     finc *dp, finc max) {
+    // pmax = 1.0;
+    for(int i = 0; i < wd / 2; i++) {
+        // power spectrum
+        for(int h = 0; h < (powerspect[i] * pscale) / pmax; h++) {
+
+            dp[(2 * panelh + 20 - h) * pitch + i] = max; // normal scale
+        }
+        // exp gamma scale
+        for(int h = 0; h < pow(powerspect[i] / pmax, gamma) * pscale; h++) {
+
+            dp[(panelh - h) * pitch + i] = max; // gamma scale
+        }
+
+        // designed filter
+        dp[(panelh - (int) (pscale * FreqFilter[i] * nfft)) * pitch + i] =
+            (max + max) / 3;
+        // to make it bold 2 pixel wide
+        dp[(panelh + 1 - (int) (pscale * FreqFilter[i] * nfft)) * pitch + i] =
+            (max + max) / 3;
+    }
 }
 //--------------------------------------------------------------------------------------------------------------------
 template <typename finc>
-float f1GetSummedPowerspectrum(void** instanceData,  float * in, fftwf_complex* out,
-							float * powerspect, const finc * sp, const int pitch, const int wd)
-{
-	F1QuiverData* d = (F1QuiverData*)*instanceData;
-	// zero power spectrum buffer
+float f1GetSummedPowerspectrum(void **instanceData, float *in,
+                               fftwf_complex *out, float *powerspect,
+                               const finc *sp, const int pitch, const int wd) {
+    F1QuiverData *d = (F1QuiverData *) *instanceData;
+    // zero power spectrum buffer
 
-	for(int i = 0; i < d->wbest / 2 + 1; i++)
-	{				
+    for(int i = 0; i < d->wbest / 2 + 1; i++) {
 
-		powerspect[i] = 0;
-	}
+        powerspect[i] = 0;
+    }
 
-	for( int r = d->row; r <  d->row + d->nrows; r ++)
-	{
-		// process each row and get average powerspectrum
-	 
-		 if (d->morph)
+    for(int r = d->row; r < d->row + d->nrows; r++) {
+        // process each row and get average powerspectrum
 
-			getRowMorphInput(in, sp + r * pitch, d->wbest, wd, false, 1, d->logLUT);
+        if(d->morph)
 
-		else
+            getRowMorphInput(in, sp + r * pitch, d->wbest, wd, false, 1,
+                             d->logLUT);
 
-			getRowInput(in, sp + r * pitch, d->wbest, wd);
+        else
 
-		// d->fftwf_execute_dft_r2c(d->pf, in, out);
-		 d->fftwf_execute(d->pf);
-						// sum powerspectra
-		for(int i = 0; i < d->wbest / 2 + 1; i++)
-		{				
+            getRowInput(in, sp + r * pitch, d->wbest, wd);
 
-			powerspect[i] += out[i][0] * out[i][0] + out[i][1] * out[i][1];
-		}
-	}
-		// get max value
-	float pmax = 0.0f;
+        // d->fftwf_execute_dft_r2c(d->pf, in, out);
+        d->fftwf_execute(d->pf);
+        // sum powerspectra
+        for(int i = 0; i < d->wbest / 2 + 1; i++) {
 
-	for(int i = 0; i < d->wbest/2 + 1; i ++)
-	{
-		if ( pmax < powerspect[i])
+            powerspect[i] += out[i][0] * out[i][0] + out[i][1] * out[i][1];
+        }
+    }
+    // get max value
+    float pmax = 0.0f;
 
-			pmax = powerspect[i];
-	}
+    for(int i = 0; i < d->wbest / 2 + 1; i++) {
+        if(pmax < powerspect[i])
 
+            pmax = powerspect[i];
+    }
 
-	return pmax;
+    return pmax;
 }
 //---------------------------------------------------------------------------------------------
 template <typename finc>
 
-void f1ProcessFullFrame(F1QuiverData* d,   float * in, fftwf_complex* out,
-					const finc * sp, finc * dp, const int pitch, const int wd ,
-					const int ht, finc min, finc max, float *LUT )
-{
-	
-	bool center = false;
-	int start = 1;
+void f1ProcessFullFrame(F1QuiverData *d, float *in, fftwf_complex *out,
+                        const finc *sp, finc *dp, const int pitch, const int wd,
+                        const int ht, finc min, finc max, float *LUT) {
 
-	for(int h = 0; h < ht ; h++)
-	{
-		if ( d->morph)
-			getRowMorphInput(in, sp, d->wbest, wd, center, start, LUT);
-		else
-			getRowInput(in, sp, d->wbest, wd );
+    bool center = false;
+    int start = 1;
 
-		//d->fftwf_execute_dft_r2c(d->pf, in, out);
-		d->fftwf_execute(d->pf);
+    for(int h = 0; h < ht; h++) {
+        if(d->morph)
+            getRowMorphInput(in, sp, d->wbest, wd, center, start, LUT);
+        else
+            getRowInput(in, sp, d->wbest, wd);
 
-		F1ApplyFilter(out,d->FreqFilter, d->wbest /2 + 1);		
+        // d->fftwf_execute_dft_r2c(d->pf, in, out);
+        d->fftwf_execute(d->pf);
 
-		//d->fftwf_execute_dft_c2r(d->pin,  out, in);
-		d->fftwf_execute(d->pin);
+        F1ApplyFilter(out, d->FreqFilter, d->wbest / 2 + 1);
 
-		if( d->morph)
+        // d->fftwf_execute_dft_c2r(d->pin,  out, in);
+        d->fftwf_execute(d->pin);
 
-			getRowMorphOutput(in, dp, wd, min, max);
-		else
+        if(d->morph)
 
-			getRowOutput(in, dp, wd, min, max);
+            getRowMorphOutput(in, dp, wd, min, max);
+        else
 
-		sp += pitch;
-		dp += pitch;
+            getRowOutput(in, dp, wd, min, max);
 
-	}	
+        sp += pitch;
+        dp += pitch;
+    }
 }
 
 //---------------------------------------------------------------------------------------------------------------------
-void scaleFloatInput( float * fp, float scale, int nval)
-{
-	for ( int i = 0; i < nval; i ++)
-	{
-		fp[i] *= scale;
-	}
+void scaleFloatInput(float *fp, float scale, int nval) {
+    for(int i = 0; i < nval; i++) {
+        fp[i] *= scale;
+    }
 }
 //---------------------------------------------------------------------------------------------------------
-// This is the main function that gets called when a frame should be produced. It will, in most cases, get
-// called several times to produce one frame. This state is being kept track of by the value of
-// activationReason. The first call to produce a certain frame n is always arInitial. In this state
-// you should request all the input frames you need. Always do it in ascending order to play nice with the
-// upstream filters.
-// Once all frames are ready, the filter will be called with arAllFramesReady. It is now time to
-// do the actual processing.
-static const VSFrameRef *VS_CC f1quiverGetFrame(int n, int activationReason, void **instanceData, void **frameData,
-						VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi)
-{
-    F1QuiverData *d = (F1QuiverData *) * instanceData;
-
-    if (activationReason == arInitial)
-	{
+// This is the main function that gets called when a frame should be produced.
+// It will, in most cases, get called several times to produce one frame. This
+// state is being kept track of by the value of activationReason. The first call
+// to produce a certain frame n is always arInitial. In this state you should
+// request all the input frames you need. Always do it in ascending order to
+// play nice with the upstream filters. Once all frames are ready, the filter
+// will be called with arAllFramesReady. It is now time to do the actual
+// processing.
+static const VSFrameRef *VS_CC f1quiverGetFrame(
+    int n, int activationReason, void **instanceData, void **frameData,
+    VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) {
+    F1QuiverData *d = (F1QuiverData *) *instanceData;
+
+    if(activationReason == arInitial) {
         // Request the source frame on the first call
         vsapi->requestFrameFilter(n, d->node, frameCtx);
-    } 
-	else if (activationReason == arAllFramesReady)
-	{
-		//we are creating buffers here so that each thread has separate areas
-		// so need to free them at end of GetFrame
-
-		//-------------------------------------------------------------------
-
-		const VSFrameRef* src = vsapi->getFrameFilter(n, d->node, frameCtx);
-
-		const VSFormat* fi = d->vi->format;
-		// process Green or Y component
-		int plane = fi->colorFamily == cmRGB ? 1 : 0;
-		int height = vsapi->getFrameHeight(src, plane);
-		int width = vsapi->getFrameWidth(src, plane);
-		VSFrameRef* dst = vsapi->copyFrame(src, core); //newVideoFrame(fi, width, height, src, core); 
-		const uint8_t* srcp = vsapi->getReadPtr(src, plane);
-		int src_stride = vsapi->getStride(src, plane);
-		uint8_t* dstp = vsapi->getWritePtr(dst, plane);
-		int nbytes = fi->bytesPerSample;
-		int nbits = fi->bitsPerSample;
-		int pitch = src_stride / nbytes;
-		int ht = height;
-		int wd = width; 		//
-		int iwidth = d->wbest;
-		int owidth = 2 + iwidth;
-		// we can use those pointers in struct as not using threads
-		//float* inBuf = (float*)d->fftwf_malloc (sizeof(float) * iwidth);
-
-		//fftwf_complex* outBuf = (fftwf_complex*)d->fftwf_malloc(sizeof(fftwf_complex) * owidth);
-
-		
-		if (fi->sampleType == stInteger && nbits == 8)
-		{
-			uint8_t max = (1 << nbits) - 1, min = 0;
-
-			f1ProcessFullFrame(d, d->inBuf, d->outBuf, srcp, dstp, pitch, wd, ht, min, max, d->logLUT);
-		}
-
-		else if (fi->sampleType == stInteger && nbits > 8)
-		{
-			uint16_t* dp = (uint16_t*)dstp;
-
-			const uint16_t* sp = (const uint16_t*)srcp;
-
-			uint16_t max = (1 << nbits) - 1, min = 0;
-
-			f1ProcessFullFrame(d, d->inBuf, d->outBuf, sp, dp, pitch, wd, ht, min, max, d->logLUT);
-		}
-
-		else // float
-		{
-			float* dp = (float*)dstp;
-
-			const float* sp = (const float*)srcp;
-
-			float max = 1.0f, min = 0.0f;
-
-			f1ProcessFullFrame(d, d->inBuf, d->outBuf, sp, dp, pitch, wd, ht, min, max, d->logLUT);
-		}
-
-			// Release the source frame
-		vsapi->freeFrame(src);				
-		return dst;
+    } else if(activationReason == arAllFramesReady) {
+        // we are creating buffers here so that each thread has separate areas
+        //  so need to free them at end of GetFrame
+
+        //-------------------------------------------------------------------
+
+        const VSFrameRef *src = vsapi->getFrameFilter(n, d->node, frameCtx);
+
+        const VSFormat *fi = d->vi->format;
+        // process Green or Y component
+        int plane = fi->colorFamily == cmRGB ? 1 : 0;
+        int height = vsapi->getFrameHeight(src, plane);
+        int width = vsapi->getFrameWidth(src, plane);
+        VSFrameRef *dst = vsapi->copyFrame(
+            src, core); // newVideoFrame(fi, width, height, src, core);
+        const uint8_t *srcp = vsapi->getReadPtr(src, plane);
+        int src_stride = vsapi->getStride(src, plane);
+        uint8_t *dstp = vsapi->getWritePtr(dst, plane);
+        int nbytes = fi->bytesPerSample;
+        int nbits = fi->bitsPerSample;
+        int pitch = src_stride / nbytes;
+        int ht = height;
+        int wd = width; //
+        int iwidth = d->wbest;
+        int owidth = 2 + iwidth;
+        // we can use those pointers in struct as not using threads
+        // float* inBuf = (float*)d->fftwf_malloc (sizeof(float) * iwidth);
+
+        // fftwf_complex* outBuf =
+        // (fftwf_complex*)d->fftwf_malloc(sizeof(fftwf_complex) * owidth);
+
+        if(fi->sampleType == stInteger && nbits == 8) {
+            uint8_t max = (1 << nbits) - 1, min = 0;
+
+            f1ProcessFullFrame(d, d->inBuf, d->outBuf, srcp, dstp, pitch, wd,
+                               ht, min, max, d->logLUT);
+        }
+
+        else if(fi->sampleType == stInteger && nbits > 8) {
+            uint16_t *dp = (uint16_t *) dstp;
+
+            const uint16_t *sp = (const uint16_t *) srcp;
+
+            uint16_t max = (1 << nbits) - 1, min = 0;
+
+            f1ProcessFullFrame(d, d->inBuf, d->outBuf, sp, dp, pitch, wd, ht,
+                               min, max, d->logLUT);
+        }
+
+        else // float
+        {
+            float *dp = (float *) dstp;
+
+            const float *sp = (const float *) srcp;
+
+            float max = 1.0f, min = 0.0f;
+
+            f1ProcessFullFrame(d, d->inBuf, d->outBuf, sp, dp, pitch, wd, ht,
+                               min, max, d->logLUT);
+        }
+
+        // Release the source frame
+        vsapi->freeFrame(src);
+        return dst;
     }
 
     return 0;
 }
 //--------------------------------------------------------------------------------------------------
 // test process
-static const VSFrameRef* VS_CC f1qtestGetFrame(int n, int activationReason, void** instanceData, void** frameData,
-	VSFrameContext* frameCtx, VSCore* core, const VSAPI* vsapi)
-{
-	F1QuiverData* d = (F1QuiverData*)*instanceData;
-
-	if (activationReason == arInitial)
-	{
-		// Request the source frame on the first call
-		vsapi->requestFrameFilter(n, d->node, frameCtx);
-	}
-	else if (activationReason == arAllFramesReady)
-	{
-		//we are creating buffers here so that each thread has separate areas
-		// so need to free them at end of GetFrame
-
-		//-------------------------------------------------------------------
-
-		const VSFrameRef* src = vsapi->getFrameFilter(n, d->node, frameCtx);
-
-		const VSFormat* fi = d->vi->format;
-		// process Green or Y
-		int plane = fi->colorFamily == cmRGB ? 1 : 0;
-		int height = vsapi->getFrameHeight(src, plane);
-		int width = vsapi->getFrameWidth(src, plane);
-		VSFrameRef* dst = vsapi->copyFrame(src, core); //newVideoFrame(fi, width, height, src, core); 
-		const uint8_t* srcp = vsapi->getReadPtr(src, plane);
-		int src_stride = vsapi->getStride(src, plane);
-		int nbits = fi->bitsPerSample;
-		int nbytes = fi->bytesPerSample;
-		uint8_t* dstp = vsapi->getWritePtr(dst, plane);
-		int pitch = src_stride / nbytes;
-		int ht = height;
-		int wd = width; 		//
-		int iwidth = d->wbest;
-		int owidth = 2 + iwidth;
-
-		//float* inBuf = (float*)d->fftwf_malloc(sizeof(float) * iwidth);
-
-		//fftwf_complex* outBuf = (fftwf_complex*)d->fftwf_malloc(sizeof(fftwf_complex) * owidth);
-		// in test processing we are not particular about time optimization
-		float* powerspect = (float*)d->fftwf_malloc(sizeof(float) * iwidth);
-
-		if (fi->sampleType == stInteger)
-		{
-			if (nbytes == 1)
-			{
-				// 8 bit samples
-				const uint8_t* sp = (uint8_t*)srcp;
-				uint8_t* dp = (uint8_t*)dstp;
-				uint8_t gray = 1 << (nbits - 1);
-				uint8_t max = (1 << nbits) - 1;
-				uint8_t zero = 0;
-
-
-				// get row values in to in, do  forward fft, sum square of complex numbers, find maximum
-				float pmax = f1GetSummedPowerspectrum(instanceData, d->inBuf, d->outBuf, powerspect, sp, pitch, wd);
-
-				// forward fft, apply filter, inverse fft plane, use right half of it in display
-
-				f1ProcessFullFrame(d, d->inBuf, d->outBuf, sp, dp, pitch, wd, ht / 2, zero, max, d->logLUT);
-
-				// zero out left half luma
-
-				fillPlaneWithVal(dp, pitch, wd / 2, ht, zero);
-				if (fi->colorFamily != cmRGB)
-				{
-					for (int p = 1; p < fi->numPlanes; p++)
-					{
-						int ht = vsapi->getFrameHeight(src, p);
-						int wd = vsapi->getFrameWidth(src, p);
-						const uint8_t* sp = vsapi->getReadPtr(src, p);
-						int src_stride = vsapi->getStride(src, p);
-						int pitch = src_stride / nbytes;
-						uint8_t* dp = vsapi->getWritePtr(dst, p);
-						// blacken left half background
-						fillPlaneWithVal(dp, pitch, wd / 2, ht, gray);
-					}
-				}
-
-				int panelh = (ht - 40) / 2;
-				int pscale = panelh;
-
-				if (pmax > 0.1f)	// pmax normally should be a large value dc value * nrows. zero only for a black clip
-				{
-					f1DisplayPowerSpectrumAndFilter(powerspect, d->FreqFilter, pscale,
-						pmax, d->gamma, panelh, d->wbest,
-						wd, pitch, dp, max);
-				}
-
-				f1DisplayHorizontalScale(NYQUIST, d->wbest, panelh, wd, pitch, dp, max);
-			}
-
-			else	// nb 9 to 16 bits per sample
-			{
-				const uint16_t* sp = (uint16_t*)srcp;
-				uint16_t* dp = (uint16_t*)dstp;
-
-				uint16_t gray = 1 << (nbits - 1);
-				uint16_t max = (1 << nbits) - 1;
-				uint16_t zero = 0;
-
-				float pmax;
-				// get row values in to in, do  forward fft, sum square of complex numbers, find maximum
-				pmax = f1GetSummedPowerspectrum(instanceData, d->inBuf, d->outBuf, powerspect, sp, pitch, wd);
-
-				// forward fft, apply filter, inverse fft top half frame, use right half of it in display
-
-				f1ProcessFullFrame(d, d->inBuf, d->outBuf, sp, dp, pitch, wd, ht / 2, zero, max, d->logLUT);
-
-				// zero out left half luma
-
-				fillPlaneWithVal(dp, pitch, wd / 2, ht, zero);
-				if (fi->colorFamily != cmRGB)
-				{
-					for (int p = 1; p < fi->numPlanes; p++)
-					{
-						int ht = vsapi->getFrameHeight(src, p);
-						int wd = vsapi->getFrameWidth(src, p);
-						const uint16_t* sp = (const uint16_t*)vsapi->getReadPtr(src, p);
-						int src_stride = vsapi->getStride(src, p);
-						int dst_stride = vsapi->getStride(src, p);
-						int pitch = src_stride / fi->bytesPerSample;
-						uint16_t* dp = (uint16_t*)vsapi->getWritePtr(dst, p);
-
-						// blacken left half background
-						fillPlaneWithVal(dp, pitch, wd / 2, ht, gray);
-					}
-				}
-
-				int panelh = (ht - 40) / 2;
-				int pscale = panelh;
-
-				if (pmax > 0.1f)	// pmax normally should be a large value dc value * nrows. zero only for a black clip
-				{
-					f1DisplayPowerSpectrumAndFilter(powerspect, d->FreqFilter, pscale, pmax, d->gamma, panelh, d->wbest,
-						wd, pitch, dp, max);
-				}
-
-				f1DisplayHorizontalScale(NYQUIST, d->wbest, panelh, wd, pitch, dp, max);
-			}	// 16 bit
-
-		}	// integer
-
-
-		else	// if(fi->sampleType == stFloat)
-		{
-			const float* sp = (const float*)srcp;
-			float* dp = (float*)dstp;
-
-			float  gray = fi->colorFamily == cmRGB ? 0.5f : 0.0; // plane 1 & 2
-			float  max = 1.0f;	// for plane 0
-			float  zero = 0.0f; // plane 0
-
-			float pmax;
-			// get row values in to in, do  forward fft, sum square of complex numbers, find maximum
-			pmax = f1GetSummedPowerspectrum(instanceData, d->inBuf, d->outBuf, powerspect, sp, pitch, wd);
-
-			// forward fft, apply filter, inverse fft top half frame, use right half of it in display
-
-			f1ProcessFullFrame(d, d->inBuf, d->outBuf, sp, dp, pitch, wd, ht / 2, zero, max, d->logLUT);
-
-			// zero out left half luma
-
-			fillPlaneWithVal(dp, pitch, wd / 2, ht, zero);
-			if (fi->colorFamily != cmRGB)
-			{
-				for (int p = 1; p < fi->numPlanes; p++)
-				{
-					int ht = vsapi->getFrameHeight(src, p);
-					int wd = vsapi->getFrameWidth(src, p);
-					const float* sp = (const float*)vsapi->getReadPtr(src, p);
-					int src_stride = vsapi->getStride(src, p);
-					int dst_stride = vsapi->getStride(src, p);
-					int pitch = src_stride / fi->bytesPerSample;
-					float* dp = (float*)vsapi->getWritePtr(dst, p);
-
-					// blacken left half background
-					fillPlaneWithVal(dp, pitch, wd / 2, ht, gray);
-				}
-			}
-
-			int panelh = (ht - 40) / 2;
-			int pscale = panelh;
-
-			if (pmax > 0.1f)	// pmax normally should be a large value dc value * nrows. zero only for a black clip
-			{
-				f1DisplayPowerSpectrumAndFilter(powerspect, d->FreqFilter, pscale, pmax, d->gamma, panelh, d->wbest,
-					wd, pitch, dp, max);
-			}
-
-			f1DisplayHorizontalScale(NYQUIST, d->wbest, panelh, wd, pitch, dp, max);
-		}
-
-		if (fi->colorFamily == cmRGB)
-		{
-			// copy Green on to Blu and Red planes
-			vs_bitblt(vsapi->getWritePtr(dst, 0), vsapi->getStride(dst, 0),
-				vsapi->getWritePtr(dst, 1), vsapi->getStride(dst, 1),
-				wd * nbytes, ht);
-			vs_bitblt(vsapi->getWritePtr(dst, 2), vsapi->getStride(dst, 2),
-				vsapi->getWritePtr(dst, 1), vsapi->getStride(dst, 1),
-				wd * nbytes, ht);
-		}
-
-		d->fftwf_free(powerspect);
-		vsapi->freeFrame(src);
-		return dst;
-	}
-	return 0;
-}
+static const VSFrameRef *VS_CC f1qtestGetFrame(
+    int n, int activationReason, void **instanceData, void **frameData,
+    VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) {
+    F1QuiverData *d = (F1QuiverData *) *instanceData;
 
+    if(activationReason == arInitial) {
+        // Request the source frame on the first call
+        vsapi->requestFrameFilter(n, d->node, frameCtx);
+    } else if(activationReason == arAllFramesReady) {
+        // we are creating buffers here so that each thread has separate areas
+        //  so need to free them at end of GetFrame
+
+        //-------------------------------------------------------------------
+
+        const VSFrameRef *src = vsapi->getFrameFilter(n, d->node, frameCtx);
+
+        const VSFormat *fi = d->vi->format;
+        // process Green or Y
+        int plane = fi->colorFamily == cmRGB ? 1 : 0;
+        int height = vsapi->getFrameHeight(src, plane);
+        int width = vsapi->getFrameWidth(src, plane);
+        VSFrameRef *dst = vsapi->copyFrame(
+            src, core); // newVideoFrame(fi, width, height, src, core);
+        const uint8_t *srcp = vsapi->getReadPtr(src, plane);
+        int src_stride = vsapi->getStride(src, plane);
+        int nbits = fi->bitsPerSample;
+        int nbytes = fi->bytesPerSample;
+        uint8_t *dstp = vsapi->getWritePtr(dst, plane);
+        int pitch = src_stride / nbytes;
+        int ht = height;
+        int wd = width; //
+        int iwidth = d->wbest;
+        int owidth = 2 + iwidth;
+
+        // float* inBuf = (float*)d->fftwf_malloc(sizeof(float) * iwidth);
+
+        // fftwf_complex* outBuf =
+        // (fftwf_complex*)d->fftwf_malloc(sizeof(fftwf_complex) * owidth);
+        //  in test processing we are not particular about time optimization
+        float *powerspect = (float *) d->fftwf_malloc(sizeof(float) * iwidth);
+
+        if(fi->sampleType == stInteger) {
+            if(nbytes == 1) {
+                // 8 bit samples
+                const uint8_t *sp = (uint8_t *) srcp;
+                uint8_t *dp = (uint8_t *) dstp;
+                uint8_t gray = 1 << (nbits - 1);
+                uint8_t max = (1 << nbits) - 1;
+                uint8_t zero = 0;
+
+                // get row values in to in, do  forward fft, sum square of
+                // complex numbers, find maximum
+                float pmax =
+                    f1GetSummedPowerspectrum(instanceData, d->inBuf, d->outBuf,
+                                             powerspect, sp, pitch, wd);
+
+                // forward fft, apply filter, inverse fft plane, use right half
+                // of it in display
+
+                f1ProcessFullFrame(d, d->inBuf, d->outBuf, sp, dp, pitch, wd,
+                                   ht / 2, zero, max, d->logLUT);
+
+                // zero out left half luma
+
+                fillPlaneWithVal(dp, pitch, wd / 2, ht, zero);
+                if(fi->colorFamily != cmRGB) {
+                    for(int p = 1; p < fi->numPlanes; p++) {
+                        int ht = vsapi->getFrameHeight(src, p);
+                        int wd = vsapi->getFrameWidth(src, p);
+                        const uint8_t *sp = vsapi->getReadPtr(src, p);
+                        int src_stride = vsapi->getStride(src, p);
+                        int pitch = src_stride / nbytes;
+                        uint8_t *dp = vsapi->getWritePtr(dst, p);
+                        // blacken left half background
+                        fillPlaneWithVal(dp, pitch, wd / 2, ht, gray);
+                    }
+                }
+
+                int panelh = (ht - 40) / 2;
+                int pscale = panelh;
+
+                if(pmax > 0.1f) // pmax normally should be a large value dc
+                                // value * nrows. zero only for a black clip
+                {
+                    f1DisplayPowerSpectrumAndFilter(
+                        powerspect, d->FreqFilter, pscale, pmax, d->gamma,
+                        panelh, d->wbest, wd, pitch, dp, max);
+                }
+
+                f1DisplayHorizontalScale(NYQUIST, d->wbest, panelh, wd, pitch,
+                                         dp, max);
+            }
+
+            else // nb 9 to 16 bits per sample
+            {
+                const uint16_t *sp = (uint16_t *) srcp;
+                uint16_t *dp = (uint16_t *) dstp;
+
+                uint16_t gray = 1 << (nbits - 1);
+                uint16_t max = (1 << nbits) - 1;
+                uint16_t zero = 0;
+
+                float pmax;
+                // get row values in to in, do  forward fft, sum square of
+                // complex numbers, find maximum
+                pmax =
+                    f1GetSummedPowerspectrum(instanceData, d->inBuf, d->outBuf,
+                                             powerspect, sp, pitch, wd);
+
+                // forward fft, apply filter, inverse fft top half frame, use
+                // right half of it in display
+
+                f1ProcessFullFrame(d, d->inBuf, d->outBuf, sp, dp, pitch, wd,
+                                   ht / 2, zero, max, d->logLUT);
+
+                // zero out left half luma
+
+                fillPlaneWithVal(dp, pitch, wd / 2, ht, zero);
+                if(fi->colorFamily != cmRGB) {
+                    for(int p = 1; p < fi->numPlanes; p++) {
+                        int ht = vsapi->getFrameHeight(src, p);
+                        int wd = vsapi->getFrameWidth(src, p);
+                        const uint16_t *sp =
+                            (const uint16_t *) vsapi->getReadPtr(src, p);
+                        int src_stride = vsapi->getStride(src, p);
+                        int dst_stride = vsapi->getStride(src, p);
+                        int pitch = src_stride / fi->bytesPerSample;
+                        uint16_t *dp = (uint16_t *) vsapi->getWritePtr(dst, p);
+
+                        // blacken left half background
+                        fillPlaneWithVal(dp, pitch, wd / 2, ht, gray);
+                    }
+                }
+
+                int panelh = (ht - 40) / 2;
+                int pscale = panelh;
+
+                if(pmax > 0.1f) // pmax normally should be a large value dc
+                                // value * nrows. zero only for a black clip
+                {
+                    f1DisplayPowerSpectrumAndFilter(
+                        powerspect, d->FreqFilter, pscale, pmax, d->gamma,
+                        panelh, d->wbest, wd, pitch, dp, max);
+                }
+
+                f1DisplayHorizontalScale(NYQUIST, d->wbest, panelh, wd, pitch,
+                                         dp, max);
+            } // 16 bit
+
+        } // integer
+
+        else // if(fi->sampleType == stFloat)
+        {
+            const float *sp = (const float *) srcp;
+            float *dp = (float *) dstp;
+
+            float gray = fi->colorFamily == cmRGB ? 0.5f : 0.0; // plane 1 & 2
+            float max = 1.0f;                                   // for plane 0
+            float zero = 0.0f;                                  // plane 0
+
+            float pmax;
+            // get row values in to in, do  forward fft, sum square of complex
+            // numbers, find maximum
+            pmax = f1GetSummedPowerspectrum(instanceData, d->inBuf, d->outBuf,
+                                            powerspect, sp, pitch, wd);
+
+            // forward fft, apply filter, inverse fft top half frame, use right
+            // half of it in display
+
+            f1ProcessFullFrame(d, d->inBuf, d->outBuf, sp, dp, pitch, wd,
+                               ht / 2, zero, max, d->logLUT);
+
+            // zero out left half luma
+
+            fillPlaneWithVal(dp, pitch, wd / 2, ht, zero);
+            if(fi->colorFamily != cmRGB) {
+                for(int p = 1; p < fi->numPlanes; p++) {
+                    int ht = vsapi->getFrameHeight(src, p);
+                    int wd = vsapi->getFrameWidth(src, p);
+                    const float *sp = (const float *) vsapi->getReadPtr(src, p);
+                    int src_stride = vsapi->getStride(src, p);
+                    int dst_stride = vsapi->getStride(src, p);
+                    int pitch = src_stride / fi->bytesPerSample;
+                    float *dp = (float *) vsapi->getWritePtr(dst, p);
+
+                    // blacken left half background
+                    fillPlaneWithVal(dp, pitch, wd / 2, ht, gray);
+                }
+            }
+
+            int panelh = (ht - 40) / 2;
+            int pscale = panelh;
+
+            if(pmax > 0.1f) // pmax normally should be a large value dc value *
+                            // nrows. zero only for a black clip
+            {
+                f1DisplayPowerSpectrumAndFilter(powerspect, d->FreqFilter,
+                                                pscale, pmax, d->gamma, panelh,
+                                                d->wbest, wd, pitch, dp, max);
+            }
+
+            f1DisplayHorizontalScale(NYQUIST, d->wbest, panelh, wd, pitch, dp,
+                                     max);
+        }
+
+        if(fi->colorFamily == cmRGB) {
+            // copy Green on to Blu and Red planes
+            vs_bitblt(vsapi->getWritePtr(dst, 0), vsapi->getStride(dst, 0),
+                      vsapi->getWritePtr(dst, 1), vsapi->getStride(dst, 1),
+                      wd * nbytes, ht);
+            vs_bitblt(vsapi->getWritePtr(dst, 2), vsapi->getStride(dst, 2),
+                      vsapi->getWritePtr(dst, 1), vsapi->getStride(dst, 1),
+                      wd * nbytes, ht);
+        }
+
+        d->fftwf_free(powerspect);
+        vsapi->freeFrame(src);
+        return dst;
+    }
+    return 0;
+}
 
 // Free all allocated data on filter destruction
-static void VS_CC f1quiverFree(void *instanceData, VSCore *core, const VSAPI *vsapi)
-{
-    F1QuiverData *d = (F1QuiverData *)instanceData;
+static void VS_CC f1quiverFree(void *instanceData, VSCore *core,
+                               const VSAPI *vsapi) {
+    F1QuiverData *d = (F1QuiverData *) instanceData;
     vsapi->freeNode(d->node);
-	d->fftwf_free (d->FreqFilter);
-	d->fftwf_free(d->inBuf);
-	d->fftwf_free(d->outBuf);
-	if (d->logLUT != NULL)
-		d->fftwf_free(d->logLUT);
-	d->fftwf_destroy_plan(d->pf);
-	d->fftwf_destroy_plan(d->pin);
-	if (d->hinstLib != NULL)
-		FreeLibrary(d->hinstLib);
+    d->fftwf_free(d->FreqFilter);
+    d->fftwf_free(d->inBuf);
+    d->fftwf_free(d->outBuf);
+    if(d->logLUT != NULL)
+        d->fftwf_free(d->logLUT);
+    d->fftwf_destroy_plan(d->pf);
+    d->fftwf_destroy_plan(d->pin);
+    // Error
+    //	if (d->hinstLib != NULL)
+    //		FreeLibrary(d->hinstLib);
+    // Fix
+    if(d->hinstLib != NULL) {
+#ifdef _WIN32
+        FreeLibrary((HINSTANCE) d->hinstLib);
+#else
+        if(d->hinstLib)
+            dlclose(d->hinstLib);
+#endif
+    }
     free(d);
 }
 
-// This function is responsible for validating arguments and creating a new filter
-static void VS_CC f1quiverCreate(const VSMap *in, VSMap *out, void *userData, VSCore *core, const VSAPI *vsapi)
-{
+// This function is responsible for validating arguments and creating a new
+// filter
+static void VS_CC f1quiverCreate(const VSMap *in, VSMap *out, void *userData,
+                                 VSCore *core, const VSAPI *vsapi) {
     F1QuiverData d;
     F1QuiverData *data;
     int err;
-	int temp;
+    int temp;
     // Get a clip reference from the input arguments. This must be freed later.
     d.node = vsapi->propGetNode(in, "clip", 0, 0);
     d.vi = vsapi->getVideoInfo(d.node);
 
-    // In this first version we only want to handle 8bit integer formats. Note that
-    // vi->format can be 0 if the input clip can change format midstream.
-    if (!isConstantFormat(d.vi) || d.vi->width == 0 || d.vi->height == 0 
-		|| (d.vi->format->colorFamily != cmYUV 	&& d.vi->format->colorFamily != cmGray
-			 &&  d.vi->format->colorFamily != cmRGB) )
-	{
-        vsapi->setError(out, "F1Quiver: only RGB, Yuv or Gray color constant formats and const frame dimensions input supported");
+    // In this first version we only want to handle 8bit integer formats. Note
+    // that vi->format can be 0 if the input clip can change format midstream.
+    if(!isConstantFormat(d.vi) || d.vi->width == 0 || d.vi->height == 0 ||
+       (d.vi->format->colorFamily != cmYUV &&
+        d.vi->format->colorFamily != cmGray &&
+        d.vi->format->colorFamily != cmRGB)) {
+        vsapi->setError(out,
+                        "F1Quiver: only RGB, Yuv or Gray color constant "
+                        "formats and const frame dimensions input supported");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    if(d.vi->format->sampleType == stFloat &&
+       d.vi->format->bitsPerSample == 16) {
+        vsapi->setError(out, "F1Quiver: Half float formats not allowed ");
         vsapi->freeNode(d.node);
         return;
     }
-	
-	if (d.vi->format->sampleType == stFloat && d.vi->format->bitsPerSample == 16)
-	{
-		vsapi->setError(out, "F1Quiver: Half float formats not allowed ");
-		vsapi->freeNode(d.node);
-		return;
-	}
 
     // If a property read fails for some reason (index out of bounds/wrong type)
     // then err will have flags set to indicate why and 0 will be returned. This
@@ -651,196 +675,189 @@ static void VS_CC f1quiverCreate(const VSMap *in, VSMap *out, void *userData, VS
     // strict checking because of what we wrote in the argument string, the only
     // reason this could fail is when the value wasn't set by the user.
     // And when it's not set we want it to default to enabled.
-    temp =  vsapi->propGetInt(in, "test", 0, &err);
-    if (err)
+    temp = vsapi->propGetInt(in, "test", 0, &err);
+    if(err)
         d.test = false;
-	else
-    // Let's pretend the only allowed values are 1 or 0...
-    if (temp < 0 || temp > 1) 
-	{
-        vsapi->setError(out, "F1Quiver: test must be 0 or 1");
-        vsapi->freeNode(d.node);
-        return;
-    } 
-	else
-		d.test = temp == 0? false : true;
-
-	temp =   vsapi->propGetInt(in, "custom", 0, &err);
-    if (err)
+    else
+        // Let's pretend the only allowed values are 1 or 0...
+        if(temp < 0 || temp > 1) {
+            vsapi->setError(out, "F1Quiver: test must be 0 or 1");
+            vsapi->freeNode(d.node);
+            return;
+        } else
+            d.test = temp == 0 ? false : true;
+
+    temp = vsapi->propGetInt(in, "custom", 0, &err);
+    if(err)
         d.custom = false;
-	else
-    // Let's pretend the only allowed values are 1 or 0...
-    if (temp < 0 || temp > 1) 
-	{
-        vsapi->setError(out, "F1Quiver: custom must be 0 or 1");
-        vsapi->freeNode(d.node);
-        return;
-    } 
-	else
-		d.custom = temp == 0? false : true;
-
-	temp =   vsapi->propGetInt(in, "morph", 0, &err);
-    if (err)
+    else
+        // Let's pretend the only allowed values are 1 or 0...
+        if(temp < 0 || temp > 1) {
+            vsapi->setError(out, "F1Quiver: custom must be 0 or 1");
+            vsapi->freeNode(d.node);
+            return;
+        } else
+            d.custom = temp == 0 ? false : true;
+
+    temp = vsapi->propGetInt(in, "morph", 0, &err);
+    if(err)
         d.morph = false;
-	else
-    // Let's pretend the only allowed values are 1 or 0...
-    if (temp < 0 || temp > 1) 
-	{
-        vsapi->setError(out, "F1Quiver: morph must be 0 or 1");
+    else
+        // Let's pretend the only allowed values are 1 or 0...
+        if(temp < 0 || temp > 1) {
+            vsapi->setError(out, "F1Quiver: morph must be 0 or 1");
+            vsapi->freeNode(d.node);
+            return;
+        }
+
+        else
+            d.morph = temp == 0 ? false : true;
+
+    d.row = vsapi->propGetInt(in, "strow", 0, &err);
+    if(err)
+        d.row = 0;
+    else {
+        if(d.row < 0 || d.row >= d.vi->height) {
+
+            vsapi->setError(out, "F1Quiver: strow must be in frame");
+            vsapi->freeNode(d.node);
+            return;
+        }
+    }
+
+    d.nrows = vsapi->propGetInt(in, "nrows", 0, &err);
+
+    if(err)
+        d.nrows = d.vi->height / 2;
+    else {
+        if(d.nrows < 0 || d.row + d.nrows >= d.vi->height) {
+
+            vsapi->setError(out, "F1Quiver: nrows must be one or more and "
+                                 "strow +  nrows must be within frame height");
+            vsapi->freeNode(d.node);
+            return;
+        }
+    }
+
+    if(d.test) {
+        if(d.vi->height < 80) {
+            vsapi->setError(out,
+                            "F1Quiver: frame height must be atleast 80 for "
+                            "test display. may add border  to make up");
+            vsapi->freeNode(d.node);
+            return;
+        }
+
+        d.gamma = vsapi->propGetFloat(in, "gamma", 0, &err);
+
+        if(err)
+            d.gamma = 0.05;
+        else {
+            if(d.gamma < 0.00001 || d.gamma > 1.0f) {
+
+                vsapi->setError(
+                    out, "F1Quiver: gamma must be +ve and less than 1.0");
+                vsapi->freeNode(d.node);
+                return;
+            }
+        }
+    }
+
+    d.npoints = vsapi->propNumElements(in, "filter");
+    if(d.npoints > 64 || d.npoints < 2 ||
+       (d.custom && ((d.npoints & 1) != 0)) ||
+       (!d.custom && (d.npoints & 3) != 0)) {
+        vsapi->setError(out,
+                        "F1Quiver: filter entries should not be more than 64, "
+                        "even number for custom and otherwise multiple of 4  ");
         vsapi->freeNode(d.node);
         return;
-    } 
-
-	else
-		d.morph = temp == 0? false : true;
-
-	d.row = vsapi->propGetInt(in, "strow", 0, &err);
-	if(err)
-		d.row = 0;
-	else
-	{
-		if(d.row < 0 || d.row >= d.vi->height)
-		{
-			
-			vsapi->setError(out, "F1Quiver: strow must be in frame");
-			vsapi->freeNode(d.node);
-			return;
-		}
     }
 
-	d.nrows = vsapi->propGetInt(in, "nrows", 0, &err);
-
-	if(err)
-		d.nrows = d.vi->height / 2;
-	else
-	{
-		if(d.nrows < 0 || d.row + d.nrows >= d.vi->height)
-		{
-			
-			vsapi->setError(out, "F1Quiver: nrows must be one or more and strow +  nrows must be within frame height");
-			vsapi->freeNode(d.node);
-			return;
-		}
+    if(d.custom) {
+        temp = -1;
+        for(int i = 0; i < d.npoints; i += 2) {
+            d.Fspec[i] = vsapi->propGetInt(in, "filter", i, 0);
+
+            if(d.Fspec[i] <= temp || d.Fspec[i] > NYQUIST) {
+                vsapi->setError(out,
+                                "F1Quiver: first value of filter pair must be "
+                                "in ascending order and less than NYQUIST ");
+                vsapi->freeNode(d.node);
+                return;
+            }
+
+            temp = d.Fspec[i];
+
+            d.Fspec[i + 1] = vsapi->propGetInt(in, "filter", i + 1, 0);
+
+            if(d.Fspec[i + 1] <= 0 || d.Fspec[i + 1] > 100) {
+                vsapi->setError(out, "F1Quiver: second value of custom filter "
+                                     "pair should be zero to 100 only ");
+                vsapi->freeNode(d.node);
+                return;
+            }
+        }
     }
 
-	if (d.test)
-	{
-		if (d.vi->height < 80)
-		{
-			vsapi->setError(out, "F1Quiver: frame height must be atleast 80 for test display. may add border  to make up");
-			vsapi->freeNode(d.node);
-			return;
-		}
-
-		d.gamma = vsapi->propGetFloat(in, "gamma", 0, &err);
-
-		if(err)
-			d.gamma = 0.05;
-		else
-		{
-			if(d.gamma < 0.00001 || d.gamma > 1.0f)
-			{
-			
-				vsapi->setError(out, "F1Quiver: gamma must be +ve and less than 1.0");
-				vsapi->freeNode(d.node);
-				return;
-			}
-		}
+    else // not custom
+    {
+        for(int i = 0; i < d.npoints; i += 4) {
+            d.Fspec[i] = vsapi->propGetInt(in, "filter", i, 0);
+
+            if(d.Fspec[i] < 0 || d.Fspec[i] > 4) {
+                vsapi->setError(out, "F1Quiver: first value of filter quartet "
+                                     "should be 0 to 4 only ");
+                vsapi->freeNode(d.node);
+                return;
+            }
+            d.Fspec[i + 1] = vsapi->propGetInt(in, "filter", i + 1, 0);
+
+            if(d.Fspec[i + 1] <= 0 || d.Fspec[i + 1] > NYQUIST) {
+                vsapi->setError(out, "F1Quiver: Frequency the second value of "
+                                     "filter pair should be zero to 100 only ");
+                vsapi->freeNode(d.node);
+                return;
+            }
+
+            d.Fspec[i + 2] = vsapi->propGetInt(in, "filter", i + 2, 0);
+
+            if(d.Fspec[0] == 3 &&
+               (d.Fspec[i + 2] < d.Fspec[i + 1] || d.Fspec[i + 2] > NYQUIST)) {
+                vsapi->setError(
+                    out, "F1Quiver:  freq2 the third value of filter pair "
+                         "should not be less than freq or more than NYQUIST ");
+                vsapi->freeNode(d.node);
+                return;
+            } else if(d.Fspec[0] == 3 &&
+                      (d.Fspec[i + 2] <= 0 || d.Fspec[i + 2] > 100)) {
+                vsapi->setError(
+                    out, "F1Quiver: bandwidth being %age of freq the third "
+                         "value of filter pair should be 1 to 100 only ");
+                vsapi->freeNode(d.node);
+                return;
+            }
+
+            d.Fspec[i + 3] = vsapi->propGetInt(in, "filter", i + 3, 0);
+
+            if(d.Fspec[i + 3] <= 0 || d.Fspec[i + 3] > 12) {
+                vsapi->setError(out, "F1Quiver: degree the sharpness  value of "
+                                     "filter pair should be 1 to 12 only ");
+                vsapi->freeNode(d.node);
+                return;
+            }
+        }
     }
 
-	d.npoints = vsapi->propNumElements( in,"filter");
-	if (d.npoints > 64 || d.npoints < 2 || (d.custom && ((d.npoints & 1) != 0 )) || ( ! d.custom && (d.npoints & 3) != 0 ) )
-	{
-		vsapi->setError(out, "F1Quiver: filter entries should not be more than 64, even number for custom and otherwise multiple of 4  ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-
-	if ( d.custom)
-	{
-		temp = -1;
-		for ( int i = 0; i < d.npoints; i += 2)
-		{
-			d.Fspec[i] = vsapi->propGetInt(in, "filter", i, 0);
-
-			if(d.Fspec[i] <= temp || d.Fspec[i] > NYQUIST)
-			{
-				vsapi->setError(out, "F1Quiver: first value of filter pair must be in ascending order and less than NYQUIST ");
-				vsapi->freeNode(d.node);
-				return;
-			}
-
-			temp = d.Fspec[i];
-
-			d.Fspec[i + 1] = vsapi->propGetInt(in, "filter", i + 1, 0);
-
-			if(d.Fspec[i+ 1] <= 0 || d.Fspec[i+ 1] > 100)
-			{
-				vsapi->setError(out, "F1Quiver: second value of custom filter pair should be zero to 100 only ");
-				vsapi->freeNode(d.node);
-				return;
-			}
-		}
-	}
-
-	else		// not custom
-	{
-		for ( int i = 0; i < d.npoints; i += 4)
-		{
-			d.Fspec[i ] = vsapi->propGetInt(in, "filter", i , 0);
-
-			if(d.Fspec[i] < 0 || d.Fspec[i] > 4)
-			{
-				vsapi->setError(out, "F1Quiver: first value of filter quartet should be 0 to 4 only ");
-				vsapi->freeNode(d.node);
-				return;
-			}
-			d.Fspec[i + 1] = vsapi->propGetInt(in, "filter", i + 1, 0);
-
-			if(d.Fspec[i+ 1] <= 0 || d.Fspec[i+ 1] > NYQUIST)
-			{
-				vsapi->setError(out, "F1Quiver: Frequency the second value of filter pair should be zero to 100 only ");
-				vsapi->freeNode(d.node);
-				return;
-			}
-
-			d.Fspec[i + 2] = vsapi->propGetInt(in, "filter", i + 2, 0);
-
-			if ( d.Fspec[0] == 3 && (d.Fspec[i+ 2] < d.Fspec[i + 1] || d.Fspec[i+ 2] > NYQUIST) )
-			{
-				vsapi->setError(out, "F1Quiver:  freq2 the third value of filter pair should not be less than freq or more than NYQUIST ");
-				vsapi->freeNode(d.node);
-				return;
-			}
-			else if (d.Fspec[0] == 3 && (d.Fspec[i + 2] <= 0 || d.Fspec[i + 2] > 100))
-			{
-				vsapi->setError(out, "F1Quiver: bandwidth being %age of freq the third value of filter pair should be 1 to 100 only ");
-				vsapi->freeNode(d.node);
-				return;
-			}
-
-			d.Fspec[i + 3] = vsapi->propGetInt(in, "filter", i + 3, 0);
-
-			if(d.Fspec[i+ 3] <= 0 || d.Fspec[i+ 3] > 12)
-			{
-				vsapi->setError(out, "F1Quiver: degree the sharpness  value of filter pair should be 1 to 12 only ");
-				vsapi->freeNode(d.node);
-				return;
-			}
-		}
-	}
-
-	
     // I usually keep the filter data struct on the stack and don't allocate it
     // until all the input validation is done.
     data = (F1QuiverData *) malloc(sizeof(d));
     *data = d;
 
-	if(d.test)
-		vsapi->createFilter(in, out, "F1Quiver", f1quiverInit, f1qtestGetFrame, f1quiverFree, fmParallelRequests, 0, data, core);
-	else
-		vsapi->createFilter(in, out, "F1Quiver", f1quiverInit, f1quiverGetFrame, f1quiverFree, fmParallelRequests, 0, data, core);
-
+    if(d.test)
+        vsapi->createFilter(in, out, "F1Quiver", f1quiverInit, f1qtestGetFrame,
+                            f1quiverFree, fmParallelRequests, 0, data, core);
+    else
+        vsapi->createFilter(in, out, "F1Quiver", f1quiverInit, f1quiverGetFrame,
+                            f1quiverFree, fmParallelRequests, 0, data, core);
 }
-
-
diff --git a/F2QBokeh.cpp b/F2QBokeh.cpp
index 993a44b..fd17a75 100644
--- a/F2QBokeh.cpp
+++ b/F2QBokeh.cpp
@@ -3,8 +3,8 @@ F2QBokeh filter plugin for vapoursynth( 32 & 64 bit) by V.C.Mohan
 This filter operates in freq domain (2d), detects parts in focus.
 Parts in focus are inserted into a blurred clip to mimic Bokeh effect.
 
-This plugin needs any one of libfftw3f-3.dll 32bit and 64bit of FFTW.org to reside in path
-(may be windows\system32 folder, or wow)
+This plugin needs any one of libfftw3f-3.dll 32bit and 64bit of FFTW.org to
+reside in path (may be windows\system32 folder, or wow)
 
 Author V.C.Mohan.
 20 Dec 2020. 25 May 2021
@@ -22,7 +22,8 @@ GNU General Public License for more details.
 
 A copy of the GNU General Public License is at
 see <http://www.gnu.org/licenses/>.
-For details of how to contact author see <http://www.avisynth.nl/users/vcmohan/vcmohan.html>
+For details of how to contact author see
+<http://www.avisynth.nl/users/vcmohan/vcmohan.html>
 ********************************************************************************/
 /******************************************************************************
 f2qBokeh filter plugin for vapoursynth by V.C.Mohan
@@ -34,25 +35,25 @@ Author V.C.Mohan.
 
   Copyright (C) < 2008- 2020>  <V.C.Mohan>
 
-	This program is free software: you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation, version 3 of the License.
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, version 3 of the License.
 
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
 
-	A copy of the GNU General Public License is at
-	see <http://www.gnu.org/licenses/>.
-	For details of how to contact author see <http://www.avisynth.org/vcmohan>
+    A copy of the GNU General Public License is at
+    see <http://www.gnu.org/licenses/>.
+    For details of how to contact author see <http://www.avisynth.org/vcmohan>
 ********************************************************************************/
 /*
-#include <Windows.h>
-#include <stdlib.h>
-#include "VapourSynth.h"
 #include "VSHelper.h"
+#include "VapourSynth.h"
+#include <Windows.h>
 #include <math.h>
+#include <stdlib.h>
 //#include <complex>
 #include "fftwlite.h"
 
@@ -60,653 +61,616 @@ Author V.C.Mohan.
 */
 #include "FQDomainHelper.h"
 
-
 //----------------------------------------------------------------------------------------
 
-typedef struct
-{
-	VSNodeRef* node;
-	VSNodeRef* nodeB;
-	const VSVideoInfo* vi;
-	float thresh;	// threshold above which is blur
-	int grid;
-	int rgb[3];
-	int yuv[3];
-
-	int block;		//  block X block is dim of fft
-	bool proc[3];
-	int bestR;		// freq width for real data will be  bwd / 2 + 1.and used for filter design 
-	int f2size;		// complex freq size
-	int* gridLUT;	// lookup table for grid from input frame
-	int* circleLUT;	// look up table for copying circle from input to output frame
-	int noffsets, count;// number of points in lookup tables
-
-	fftwf_plan  pf, pinv;	// forward and inverse fft
+typedef struct {
+    VSNodeRef *node;
+    VSNodeRef *nodeB;
+    const VSVideoInfo *vi;
+    float thresh; // threshold above which is blur
+    int grid;
+    int rgb[3];
+    int yuv[3];
+
+    int block; //  block X block is dim of fft
+    bool proc[3];
+    int bestR;    // freq width for real data will be  bwd / 2 + 1.and used for
+                  // filter design
+    int f2size;   // complex freq size
+    int *gridLUT; // lookup table for grid from input frame
+    int *circleLUT; // look up table for copying circle from input to output
+                    // frame
+    int noffsets, count; // number of points in lookup tables
+
+    fftwf_plan pf, pinv; // forward and inverse fft
 #include "fftLateBindingClassParams.cpp"
-	float* inBuf;
-	fftwf_complex* outBuf;
+    float *inBuf;
+    fftwf_complex *outBuf;
 
-}F2QBokehData;
+} F2QBokehData;
 
 //------------------------------------------------------------------------------
-void AutoCorrelate(fftwf_complex* Afreq, int block, bool center);
-float NormalizeSpectrum(fftwf_complex* buf, int size, bool center);
+void AutoCorrelate(fftwf_complex *Afreq, int block, bool center);
+float NormalizeSpectrum(fftwf_complex *buf, int size, bool center);
 
 template <typename finc>
-bool isBlockSharp(F2QBokehData * d, float* buf, fftwf_complex* freq, 
-	const finc* ap, int apitch);
+bool isBlockSharp(F2QBokehData *d, float *buf, fftwf_complex *freq,
+                  const finc *ap, int apitch);
 
 template <typename finc>
-float makeZeroMean(float* in, const finc* sp,int pitch, int* offsets,int grid, int block);
+float makeZeroMean(float *in, const finc *sp, int pitch, int *offsets, int grid,
+                   int block);
 
-bool checkBlur(float* in, int block, float thresh);
+bool checkBlur(float *in, int block, float thresh);
 
 //-----------------------------------------------------------------------------------------------
 
-bool  checkBlur(float* in, int block, float thresh)
-{
-	int centerOffset = (block / 2) * block + block / 2;
-	float maxGo = *(in + centerOffset) * thresh;
-	return (maxGo > in[centerOffset - block - 1] || maxGo > in[centerOffset - 1]
-		|| maxGo > in[centerOffset + block - 1] || maxGo > in[centerOffset - block]);
+bool checkBlur(float *in, int block, float thresh) {
+    int centerOffset = (block / 2) * block + block / 2;
+    float maxGo = *(in + centerOffset) * thresh;
+    return (maxGo > in[centerOffset - block - 1] ||
+            maxGo > in[centerOffset - 1] ||
+            maxGo > in[centerOffset + block - 1] ||
+            maxGo > in[centerOffset - block]);
 }
 
 //--------------------------------------------------------------------------------------------------------------
 template <typename finc>
-float  makeZeroMean(float* in, const finc* sp,int pitch, int* offsets, int grid, int block)
-{
-	float mean = getMeanValue(sp, offsets, grid * grid);
-	
-	float* inBuf = in;
-
-	for (int h = 0; h < grid; h++)
-	{
-		for (int w = 0; w < grid; w++)
-		{
-			inBuf[w] = (float)sp[w] - mean;
-		}
-		for (int w = grid; w < block; w++)
-		{
-			// fill zeroes
-			inBuf[w] = 0.0f;
-		}
-
-		inBuf += block;
-		sp +=  pitch;
-	}
-	inBuf = in + grid * block;
-
-	for (int h = grid; h < block; h++)
-	{
-		// fill zeroes
-		for (int w = 0; w < block; w++)
-		{
-			inBuf[w] = 0.0f;
-		}
-	}
-	return mean;
+float makeZeroMean(float *in, const finc *sp, int pitch, int *offsets, int grid,
+                   int block) {
+    float mean = getMeanValue(sp, offsets, grid * grid);
+
+    float *inBuf = in;
+
+    for(int h = 0; h < grid; h++) {
+        for(int w = 0; w < grid; w++) {
+            inBuf[w] = (float) sp[w] - mean;
+        }
+        for(int w = grid; w < block; w++) {
+            // fill zeroes
+            inBuf[w] = 0.0f;
+        }
+
+        inBuf += block;
+        sp += pitch;
+    }
+    inBuf = in + grid * block;
+
+    for(int h = grid; h < block; h++) {
+        // fill zeroes
+        for(int w = 0; w < block; w++) {
+            inBuf[w] = 0.0f;
+        }
+    }
+    return mean;
 }
 
 //-----------------------------------------------------------------------------------------------------------
 
-void  AutoCorrelate(fftwf_complex* Afreq, int fsize, bool center)
-{
-	
-	float mult = 1.0 / (fsize);
+void AutoCorrelate(fftwf_complex *Afreq, int fsize, bool center) {
 
-	// complex multiply with conjugate and scale down to compensate fft upscaling
-	
-	float real;
+    float mult = 1.0 / (fsize);
 
-	if (center)
-	{
-		int i = 1;
+    // complex multiply with conjugate and scale down to compensate fft
+    // upscaling
 
-		for (int w = 0; w < fsize; w++)
-		{			
-			real = (Afreq[w][0] * Afreq[w][0] + Afreq[w][1] * Afreq[w][1]);
+    float real;
 
-			Afreq[w][0] = real * mult * i;
-			Afreq[w][1] = 0.0f;
+    if(center) {
+        int i = 1;
 
-			i = -i;	//			
-		}
-	}
-	else // no centering
-	{		
+        for(int w = 0; w < fsize; w++) {
+            real = (Afreq[w][0] * Afreq[w][0] + Afreq[w][1] * Afreq[w][1]);
 
-		for (int n = 0; n < fsize; n++)
-		{
+            Afreq[w][0] = real * mult * i;
+            Afreq[w][1] = 0.0f;
 
-			real = (Afreq[n][0] * Afreq[n][0] + Afreq[n][1] * Afreq[n][1]);
+            i = -i; //
+        }
+    } else // no centering
+    {
 
-			Afreq[n][0] = real * mult;
-			Afreq[n][1] = 0.0;
-		}
-	}
+        for(int n = 0; n < fsize; n++) {
+
+            real = (Afreq[n][0] * Afreq[n][0] + Afreq[n][1] * Afreq[n][1]);
+
+            Afreq[n][0] = real * mult;
+            Afreq[n][1] = 0.0;
+        }
+    }
 }
 //---------------------------------------------------------------------------
-float NormalizeSpectrum(fftwf_complex* buf, int fsize, bool center)
-{
-	// normalizing auto correlation spectrum
-	float maximum = buf[0][0];
-
-	// get  max values
-	for (int n = 0; n < fsize; n++)
-	{
-		if (maximum < buf[n][0])
-			maximum = buf[n][0];
-
-	}
-	// normalize
-	if (maximum > 0.0001f)
-	{
-		float mult = 1.0 / (maximum);
-
-		if (center)
-		{
-			int i = 1;
-			for (int n = 0; n < fsize; n++)
-			{
-				buf[n][0] *= mult * i;
-				i = -i;
-			}
-		}
-		else
-		{
-			for (int n = 0; n < fsize; n++)
-			{
-				buf[n][0] *= mult;
-			}
-		}
-
-	}
-	return maximum;
+float NormalizeSpectrum(fftwf_complex *buf, int fsize, bool center) {
+    // normalizing auto correlation spectrum
+    float maximum = buf[0][0];
+
+    // get  max values
+    for(int n = 0; n < fsize; n++) {
+        if(maximum < buf[n][0])
+            maximum = buf[n][0];
+    }
+    // normalize
+    if(maximum > 0.0001f) {
+        float mult = 1.0 / (maximum);
+
+        if(center) {
+            int i = 1;
+            for(int n = 0; n < fsize; n++) {
+                buf[n][0] *= mult * i;
+                i = -i;
+            }
+        } else {
+            for(int n = 0; n < fsize; n++) {
+                buf[n][0] *= mult;
+            }
+        }
+    }
+    return maximum;
 }
 
 //--------------------------------------------------------------------------------------------
 template <typename finc>
-bool isBlockSharp(F2QBokehData * d,float* buf, fftwf_complex* Afreq,
-	const finc* ap, int apitch)
-{
-
-	float mean = makeZeroMean(buf, ap,apitch, d->gridLUT, d->grid, d->block);
-	// 2d forward transform into Afreq complex buffer
-	//d->fftwf_execute_dft_r2c(d->pf, buf, Afreq);
-	d->fftwf_execute(d->pf);
-	// auto correlation in freq domain is multiplication. Also scale down as scaleup happens in FFT
-	AutoCorrelate(Afreq, d->f2size, false);
-	float max = NormalizeSpectrum(Afreq, d->f2size, true);
-	// avoid zero or same color in block
-	if (max > 0.0001f)
-	{
-		// inverse fft
-		//d->fftwf_execute_dft_c2r(d->pinv, Afreq, buf);
-		d->fftwf_execute(d->pinv);
-		// check if in focus
-		return  checkBlur(buf, d->block, d->thresh);
-	}
-	return false;
+bool isBlockSharp(F2QBokehData *d, float *buf, fftwf_complex *Afreq,
+                  const finc *ap, int apitch) {
+
+    float mean = makeZeroMean(buf, ap, apitch, d->gridLUT, d->grid, d->block);
+    // 2d forward transform into Afreq complex buffer
+    // d->fftwf_execute_dft_r2c(d->pf, buf, Afreq);
+    d->fftwf_execute(d->pf);
+    // auto correlation in freq domain is multiplication. Also scale down as
+    // scaleup happens in FFT
+    AutoCorrelate(Afreq, d->f2size, false);
+    float max = NormalizeSpectrum(Afreq, d->f2size, true);
+    // avoid zero or same color in block
+    if(max > 0.0001f) {
+        // inverse fft
+        // d->fftwf_execute_dft_c2r(d->pinv, Afreq, buf);
+        d->fftwf_execute(d->pinv);
+        // check if in focus
+        return checkBlur(buf, d->block, d->thresh);
+    }
+    return false;
 }
 
-
 /*************************************************/
-static void VS_CC f2qbokehInit(VSMap* in, VSMap* out, void** instanceData, VSNode* node, VSCore* core, const VSAPI* vsapi)
-{
-	F2QBokehData* d = (F2QBokehData*)*instanceData;
-	vsapi->setVideoInfo(d->vi, 1, node);
-	
-	d->block =  ( ( d->grid + 7) >> 3) << 3;
-		// for RGB or Y planes
-	d->bestR = d->block / 2 + 1;
-	d->f2size = d->block * d->bestR;
-	int bsize = d->block * d->block;
-#include "ConstructorCodeForLateBindingfft.cpp"	
-	// buffers 
-	d->inBuf = (float*)d->fftwf_malloc(sizeof(float) * bsize);
-
-	d->outBuf = (fftwf_complex*)d->fftwf_malloc(sizeof(fftwf_complex) * d->f2size);
-
-	// We require one forward for padded size   and two inverse transforms( one of best size and other for padded . As our dimensions are good (multiple of 2x3x5 measure is used.
-	d->pf = d->fftwf_plan_dft_r2c_2d(d->block, d->block, d->inBuf, d->outBuf, FFTW_MEASURE);
-	// inverse so complex to real used
-	d->pinv = d->fftwf_plan_dft_c2r_2d(d->block, d->block, d->outBuf, d->inBuf, FFTW_MEASURE);
-
-	//d->fftwf_free(inBuf);
-	//d->fftwf_free(outBuf);
-
-	const VSFrameRef* srcA = vsapi->getFrame(0, d->node, NULL, 0);
-	const VSFormat* fi = d->vi->format;
-	
-	int nBytes = fi->bytesPerSample;
-	int pitch = vsapi->getStride(srcA, 0) / nBytes;
-	int gPoints = d->grid * d->grid;
-
-	d->gridLUT = (int*)vs_aligned_malloc <int>(sizeof(int) * gPoints * 5, 32);
-	d->circleLUT = d->gridLUT + gPoints;
-
-	d->noffsets = makeRectGridLUT(d->gridLUT, pitch, d->grid);
-	// will have grid as radius. So a larger area than grid 8 grid will be treated as sharp
-	int cOffset = (d->grid / 2) * pitch + d->grid / 2;
-	d->count = makeCircularLUT(d->circleLUT, pitch, d->grid , cOffset);
-	vsapi->freeFrame(srcA);
-
-	if (d->noffsets != gPoints || d->count >=  4 * gPoints)
-	{
-		vs_aligned_free(d->gridLUT);
-		vsapi->setError(out, "bokeh: noffsets or count are in error");
-		vsapi->freeNode(d->node);
-		vsapi->freeNode(d->nodeB);
-		return;
-
-	}
-	
+static void VS_CC f2qbokehInit(VSMap *in, VSMap *out, void **instanceData,
+                               VSNode *node, VSCore *core, const VSAPI *vsapi) {
+    F2QBokehData *d = (F2QBokehData *) *instanceData;
+    vsapi->setVideoInfo(d->vi, 1, node);
+
+    d->block = ((d->grid + 7) >> 3) << 3;
+    // for RGB or Y planes
+    d->bestR = d->block / 2 + 1;
+    d->f2size = d->block * d->bestR;
+    int bsize = d->block * d->block;
+#include "ConstructorCodeForLateBindingfft.cpp"
+    // buffers
+    d->inBuf = (float *) d->fftwf_malloc(sizeof(float) * bsize);
+
+    d->outBuf =
+        (fftwf_complex *) d->fftwf_malloc(sizeof(fftwf_complex) * d->f2size);
+
+    // We require one forward for padded size   and two inverse transforms( one
+    // of best size and other for padded . As our dimensions are good (multiple
+    // of 2x3x5 measure is used.
+    d->pf = d->fftwf_plan_dft_r2c_2d(d->block, d->block, d->inBuf, d->outBuf,
+                                     FFTW_MEASURE);
+    // inverse so complex to real used
+    d->pinv = d->fftwf_plan_dft_c2r_2d(d->block, d->block, d->outBuf, d->inBuf,
+                                       FFTW_MEASURE);
+
+    // d->fftwf_free(inBuf);
+    // d->fftwf_free(outBuf);
+
+    const VSFrameRef *srcA = vsapi->getFrame(0, d->node, NULL, 0);
+    const VSFormat *fi = d->vi->format;
+
+    int nBytes = fi->bytesPerSample;
+    int pitch = vsapi->getStride(srcA, 0) / nBytes;
+    int gPoints = d->grid * d->grid;
+
+    d->gridLUT = (int *) vs_aligned_malloc<int>(sizeof(int) * gPoints * 5, 32);
+    d->circleLUT = d->gridLUT + gPoints;
+
+    d->noffsets = makeRectGridLUT(d->gridLUT, pitch, d->grid);
+    // will have grid as radius. So a larger area than grid 8 grid will be
+    // treated as sharp
+    int cOffset = (d->grid / 2) * pitch + d->grid / 2;
+    d->count = makeCircularLUT(d->circleLUT, pitch, d->grid, cOffset);
+    vsapi->freeFrame(srcA);
+
+    if(d->noffsets != gPoints || d->count >= 4 * gPoints) {
+        vs_aligned_free(d->gridLUT);
+        vsapi->setError(out, "bokeh: noffsets or count are in error");
+        vsapi->freeNode(d->node);
+        vsapi->freeNode(d->nodeB);
+        return;
+    }
 }
 //-----------------------------------------------------------------------------------------------
 
-// This is the main function that gets called when a frame should be produced. It will, in most cases, get
-// called several times to produce one frame. This state is being kept track of by the value of
-// activationReason. The first call to produce a certain frame n is always arInitial. In this state
-// you should request all the input frames you need. Always do it in ascending order to play nice with the
-// upstream filters.
-// Once all frames are ready, the filter will be called with arAllFramesReady. It is now time to
-// do the actual processing.
-static const VSFrameRef* VS_CC f2qbokehGetFrame(int n, int activationReason, void** instanceData,
-	void** frameData, VSFrameContext* frameCtx, VSCore* core, const VSAPI* vsapi)
-{
-	F2QBokehData* d = (F2QBokehData*)*instanceData;
-
-	if (activationReason == arInitial)
-	{
-		// Request the source frame on the first call
-		vsapi->requestFrameFilter(n, d->node, frameCtx);
-		vsapi->requestFrameFilter(n, d->nodeB, frameCtx);
-	}
-	else if (activationReason == arAllFramesReady)
-	{
-
-		const VSFrameRef* src = vsapi->getFrameFilter(n, d->node, frameCtx);
-		// The reason we query this on a per frame basis is because we want our filter
-		// to accept clips with varying dimensions. If we reject such content using d->vi
-		// would be better.
-		const VSFormat* fi = d->vi->format;
-		
-		// When creating a new frame for output it is VERY EXTREMELY SUPER IMPORTANT to
-		// supply the "dominant" source frame to copy properties from. Frame props
-		// are an essential part of the filter chain and you should NEVER break it.
-		const VSFrameRef* blr = vsapi->getFrameFilter(n, d->nodeB, frameCtx);
-		VSFrameRef* dst = vsapi->copyFrame(blr, core);
-
-		float* inBuf = d->inBuf; // (float*)d->fftwf_malloc(sizeof(float) * d->block * d->block);
-
-		fftwf_complex* outBuf = d->outBuf; // (fftwf_complex*)d->fftwf_malloc(sizeof(fftwf_complex) * d->f2size);
-
-		//int* offsets = (int*)vs_aligned_malloc<int>(sizeof(int) * d->block * d->block, 32);		
-
-		
-		int nbytes = fi->bytesPerSample;
-		const uint8_t* srcp[] = { NULL, NULL, NULL, NULL };
-		uint8_t* dstp[] = { NULL, NULL, NULL, NULL };
-		int stride = vsapi->getStride(src, 0);;
-		int pitch = vsapi->getStride(src, 0) / nbytes;
-		int np = fi->numPlanes > 3 ? 3 : fi->numPlanes;
-
-		bool proc[] = { true, true, true };
-
-		for (int p = 0; p < 3; p++)
-		{
-			if (fi->colorFamily == cmRGB)
-			{
-
-				if (d->rgb[p] == 0) proc[2 - p] = false;
-
-			}
-			else if (fi->colorFamily == cmYUV)
-			{
-				if (d->yuv[p] == 0) proc[p] = false;
-			}
-		}
-
-		for (int plane = 0; plane < np; plane++)
-		{
-			srcp[plane] = vsapi->getReadPtr(src, plane);
-			dstp[plane] = vsapi->getWritePtr(dst, plane);
-		}
-		int ptrInc = (d->grid / 2) * stride;
-		
-		int pht = vsapi->getFrameHeight(src, 0);
-		int pwd = vsapi->getFrameWidth(src, 0);				
-
-		int count = d->count, noffsets = d->noffsets;
-
-		// initial position offset from zero 
-		int iOffset = (d->grid ) * stride;
-
-		for (int p = 0; p < np; p++)
-		{
-			srcp[p] += iOffset;
-			dstp[p] += iOffset;
-		}
-
-		for (int h = d->grid ; h <= pht - d->grid - d->grid / 2 - 1; h += d->grid / 2)
-		{
-			for (int w = d->grid ; w <= pwd - d->grid - d->grid / 2  - 1; w += d->grid / 2)
-			{
-				bool sharp =  false;
-				// process image	
-				if (fi->sampleType == stInteger)
-				{
-					if (nbytes == 1)
-					{
-						for (int p = 0; p < np; p++)
-						{
-							if( proc[p])
-
-								sharp = isBlockSharp(d, inBuf, outBuf,
-									srcp[p] + w, pitch);
-							if (sharp)
-								break;
-						}
-
-						if (sharp)
-						{
-							// copy circular area
-							for (int p = 0; p < np; p++)
-							{
-								for (int i = 0; i < count; i++)
-
-									*(dstp[p] + w + d->circleLUT[i])
-									= *(srcp[p] + w + d->circleLUT[i]);
-							}
-						}
-					}
-
-					else if (nbytes == 2)
-					{
-						for (int p = 0; p < np; p++)
-						{
-							if( proc[p])
-
-								sharp = isBlockSharp(d, inBuf, outBuf,
-									(uint16_t*)(srcp[p]) + w, pitch);
-							if (sharp)
-								break;
-						}
-
-						if (sharp)
-						{
-							// copy circular area
-							for (int p = 0; p < np; p++)
-							{
-								for (int i = 0; i < count; i++)
-
-									*(((uint16_t*)(dstp[p])) + w + d->circleLUT[i])
-									= *(((uint16_t*)(srcp[p])) + w + d->circleLUT[i]);
-							}
-						}
-					}
-				}
-				
-
-				else if (nbytes == 4)
-				{
-					for (int p = 0; p < np; p++)
-					{
-						if( proc[p])
-
-							sharp = isBlockSharp(d, inBuf, outBuf,
-								(float*)(srcp[p]) + w, pitch);
-						if (sharp)
-							break;
-					}
-
-					if (sharp)
-					{
-						// copy circular area
-						for (int p = 0; p < np; p++)
-						{
-							for (int i = 0; i < count; i++)
-
-								*(((float*)(dstp[p])) + w + d->circleLUT[i])
-								= *(((float*)(srcp[p])) + w + d->circleLUT[i]);
-						}
-					}
-				}
-
-			}
-			for (int p = 0; p < np; p++)
-			{
-				srcp[p] += ptrInc;
-				dstp[p] += ptrInc;
-			}
-		}
-
-		// Release the source frames
-		vsapi->freeFrame(src);
-		vsapi->freeFrame(blr);
-
-		// release fft buffers
-		//d->fftwf_free(inBuf);
-		//d->fftwf_free(outBuf);
-		
-		// A reference is consumed when it is returned, so saving the dst reference somewhere
-		// and reusing it is not allowed.
-		return dst;
-	}
-
-	return 0;
-
+// This is the main function that gets called when a frame should be produced.
+// It will, in most cases, get called several times to produce one frame. This
+// state is being kept track of by the value of activationReason. The first call
+// to produce a certain frame n is always arInitial. In this state you should
+// request all the input frames you need. Always do it in ascending order to
+// play nice with the upstream filters. Once all frames are ready, the filter
+// will be called with arAllFramesReady. It is now time to do the actual
+// processing.
+static const VSFrameRef *VS_CC f2qbokehGetFrame(
+    int n, int activationReason, void **instanceData, void **frameData,
+    VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) {
+    F2QBokehData *d = (F2QBokehData *) *instanceData;
+
+    if(activationReason == arInitial) {
+        // Request the source frame on the first call
+        vsapi->requestFrameFilter(n, d->node, frameCtx);
+        vsapi->requestFrameFilter(n, d->nodeB, frameCtx);
+    } else if(activationReason == arAllFramesReady) {
+
+        const VSFrameRef *src = vsapi->getFrameFilter(n, d->node, frameCtx);
+        // The reason we query this on a per frame basis is because we want our
+        // filter to accept clips with varying dimensions. If we reject such
+        // content using d->vi would be better.
+        const VSFormat *fi = d->vi->format;
+
+        // When creating a new frame for output it is VERY EXTREMELY SUPER
+        // IMPORTANT to supply the "dominant" source frame to copy properties
+        // from. Frame props are an essential part of the filter chain and you
+        // should NEVER break it.
+        const VSFrameRef *blr = vsapi->getFrameFilter(n, d->nodeB, frameCtx);
+        VSFrameRef *dst = vsapi->copyFrame(blr, core);
+
+        float *inBuf = d->inBuf; // (float*)d->fftwf_malloc(sizeof(float) *
+                                 // d->block * d->block);
+
+        fftwf_complex *outBuf = d->outBuf; // (fftwf_complex*)d->fftwf_malloc(sizeof(fftwf_complex)
+                                           // * d->f2size);
+
+        // int* offsets = (int*)vs_aligned_malloc<int>(sizeof(int) * d->block *
+        // d->block, 32);
+
+        int nbytes = fi->bytesPerSample;
+        const uint8_t *srcp[] = {NULL, NULL, NULL, NULL};
+        uint8_t *dstp[] = {NULL, NULL, NULL, NULL};
+        int stride = vsapi->getStride(src, 0);
+        ;
+        int pitch = vsapi->getStride(src, 0) / nbytes;
+        int np = fi->numPlanes > 3 ? 3 : fi->numPlanes;
+
+        bool proc[] = {true, true, true};
+
+        for(int p = 0; p < 3; p++) {
+            if(fi->colorFamily == cmRGB) {
+
+                if(d->rgb[p] == 0)
+                    proc[2 - p] = false;
+
+            } else if(fi->colorFamily == cmYUV) {
+                if(d->yuv[p] == 0)
+                    proc[p] = false;
+            }
+        }
+
+        for(int plane = 0; plane < np; plane++) {
+            srcp[plane] = vsapi->getReadPtr(src, plane);
+            dstp[plane] = vsapi->getWritePtr(dst, plane);
+        }
+        int ptrInc = (d->grid / 2) * stride;
+
+        int pht = vsapi->getFrameHeight(src, 0);
+        int pwd = vsapi->getFrameWidth(src, 0);
+
+        int count = d->count, noffsets = d->noffsets;
+
+        // initial position offset from zero
+        int iOffset = (d->grid) * stride;
+
+        for(int p = 0; p < np; p++) {
+            srcp[p] += iOffset;
+            dstp[p] += iOffset;
+        }
+
+        for(int h = d->grid; h <= pht - d->grid - d->grid / 2 - 1;
+            h += d->grid / 2) {
+            for(int w = d->grid; w <= pwd - d->grid - d->grid / 2 - 1;
+                w += d->grid / 2) {
+                bool sharp = false;
+                // process image
+                if(fi->sampleType == stInteger) {
+                    if(nbytes == 1) {
+                        for(int p = 0; p < np; p++) {
+                            if(proc[p])
+
+                                sharp = isBlockSharp(d, inBuf, outBuf,
+                                                     srcp[p] + w, pitch);
+                            if(sharp)
+                                break;
+                        }
+
+                        if(sharp) {
+                            // copy circular area
+                            for(int p = 0; p < np; p++) {
+                                for(int i = 0; i < count; i++)
+
+                                    *(dstp[p] + w + d->circleLUT[i]) =
+                                        *(srcp[p] + w + d->circleLUT[i]);
+                            }
+                        }
+                    }
+
+                    else if(nbytes == 2) {
+                        for(int p = 0; p < np; p++) {
+                            if(proc[p])
+
+                                sharp = isBlockSharp(d, inBuf, outBuf,
+                                                     (uint16_t *) (srcp[p]) + w,
+                                                     pitch);
+                            if(sharp)
+                                break;
+                        }
+
+                        if(sharp) {
+                            // copy circular area
+                            for(int p = 0; p < np; p++) {
+                                for(int i = 0; i < count; i++)
+
+                                    *(((uint16_t *) (dstp[p])) + w +
+                                      d->circleLUT[i]) =
+                                        *(((uint16_t *) (srcp[p])) + w +
+                                          d->circleLUT[i]);
+                            }
+                        }
+                    }
+                }
+
+                else if(nbytes == 4) {
+                    for(int p = 0; p < np; p++) {
+                        if(proc[p])
+
+                            sharp =
+                                isBlockSharp(d, inBuf, outBuf,
+                                             (float *) (srcp[p]) + w, pitch);
+                        if(sharp)
+                            break;
+                    }
+
+                    if(sharp) {
+                        // copy circular area
+                        for(int p = 0; p < np; p++) {
+                            for(int i = 0; i < count; i++)
+
+                                *(((float *) (dstp[p])) + w + d->circleLUT[i]) =
+                                    *(((float *) (srcp[p])) + w +
+                                      d->circleLUT[i]);
+                        }
+                    }
+                }
+            }
+            for(int p = 0; p < np; p++) {
+                srcp[p] += ptrInc;
+                dstp[p] += ptrInc;
+            }
+        }
+
+        // Release the source frames
+        vsapi->freeFrame(src);
+        vsapi->freeFrame(blr);
+
+        // release fft buffers
+        // d->fftwf_free(inBuf);
+        // d->fftwf_free(outBuf);
+
+        // A reference is consumed when it is returned, so saving the dst
+        // reference somewhere and reusing it is not allowed.
+        return dst;
+    }
+
+    return 0;
 }
 //----------------------------------------------------------------
 // Free all allocated data on filter destruction
-static void VS_CC f2qbokehFree(void* instanceData, VSCore* core, const VSAPI* vsapi)
-{
-	F2QBokehData* d = (F2QBokehData*)instanceData;
-
-	
-	d->fftwf_destroy_plan(d->pf);
-	d->fftwf_destroy_plan(d->pinv);	
-	d->fftwf_free(d->inBuf);
-	d->fftwf_free(d->outBuf);
-
-	FreeLibrary(d->hinstLib);
-	vsapi->freeNode(d->node);
-	vsapi->freeNode(d->nodeB);
-
-	vs_aligned_free(d->gridLUT);
-	//vs_aligned_free(d->circleLUT); part of gridLUT creation
-	free(d);
+static void VS_CC f2qbokehFree(void *instanceData, VSCore *core,
+                               const VSAPI *vsapi) {
+    F2QBokehData *d = (F2QBokehData *) instanceData;
+
+    d->fftwf_destroy_plan(d->pf);
+    d->fftwf_destroy_plan(d->pinv);
+    d->fftwf_free(d->inBuf);
+    d->fftwf_free(d->outBuf);
+    // Error
+    // FreeLibrary(d->hinstLib);
+    // Fix
+    if(d->hinstLib != nullptr) {
+#ifdef _WIN32
+        FreeLibrary((HINSTANCE) d->hinstLib);
+#else
+        dlclose(d->hinstLib);
+#endif
+    }
+
+    vsapi->freeNode(d->node);
+    vsapi->freeNode(d->nodeB);
+
+    vs_aligned_free(d->gridLUT);
+    // vs_aligned_free(d->circleLUT); part of gridLUT creation
+    free(d);
 }
 
-
 /***************************************************************/
 
-
-// This function is responsible for validating arguments and creating a new filter
-static void VS_CC f2qbokehCreate(const VSMap* in, VSMap* out, void* userData, VSCore* core, const VSAPI* vsapi)
-{
-	F2QBokehData d;
-	F2QBokehData* data;
-	int err;
-	
-	// Get a clip reference from the input arguments. This must be freed later.
-	d.node = vsapi->propGetNode(in, "clip", 0, 0);
-	d.vi = vsapi->getVideoInfo(d.node);
-	// vi->format can be 0 if the input clip can change format midstream.
-	if (!isConstantFormat(d.vi) || d.vi->format->colorFamily == cmCompat
-		|| d.vi->format->colorFamily == pfRGBH || d.vi->format->colorFamily == pfYUV444PH
-		|| d.vi->format->colorFamily == pfGrayH)
-	{
-		vsapi->setError(out, "f2qBokeh: clip must have constant dimensions and in YUV or RGB or Grey format. Half float formats not allowed  ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-	if ( d.vi->format-> colorFamily == cmYUV && d.vi->format->subSamplingH != 0 
-		|| d.vi->format->subSamplingW != 0)
-	{
-		vsapi->setError(out, "f2qBokeh: YUV format clip must be type YUV444 i.e. no subsampling.");
-		vsapi->freeNode(d.node);
-		return;
-	}
-
-	d.nodeB = vsapi->propGetNode(in, "clipb", 0, 0);
-	const VSVideoInfo* bvi = vsapi->getVideoInfo(d.nodeB);
-	if (!isSameFormat(d.vi, bvi))
-	{
-		vsapi->setError(out, "f2qBokeh: blur clip must have identical format with the input clip  ");
-		vsapi->freeNode(d.node);
-		vsapi->freeNode(d.nodeB);
-		return;
-
-	}
-
-	// If a property read fails for some reason (index out of bounds/wrong type)
-	// then err will have flags set to indicate why and 0 will be returned. This
-	// can be very useful to know when having optional arguments. Since we have
-	// strict checking because of what we wrote in the argument string, the only
-	// reason this could fail is when the value wasn't set by the user.
-	// And when it's not set we want it to default to enabled.
-
-	d.grid = vsapi->propGetInt(in, "grid", 0, &err);
-	if (err)
-	{
-		d.grid = 16;
-	}
-	else if (d.grid < 3 || d.grid > 64)
-	{
-		vsapi->setError(out, "f2qBokeh:grid must be between 3 and 64");
-		vsapi->freeNode(d.node);
-		vsapi->freeNode(d.nodeB);
-		return;
-	}
-	d.thresh = vsapi->propGetFloat(in, "thresh", 0, &err);
-	if (err)
-	{
-		d.thresh = 0.45f;
-	}
-	else if (d.thresh < 0.0f || d.thresh > 1.0f)
-	{
-		vsapi->setError(out, "f2qBokeh:value of thresh must be between 0 qnd 1.0");
-		vsapi->freeNode(d.node);
-		vsapi->freeNode(d.nodeB);
-		return;
-	}
-
-
-	if (d.vi->format->colorFamily == cmRGB)
-	{
-		int count = vsapi->propNumElements(in, "rgb");
-		if (count > 3)
-		{
-			vsapi->setError(out, "f2qBokeh: rgb array cannot have more than 3 entries.");
-			vsapi->freeNode(d.node);
-			vsapi->freeNode(d.nodeB);
-			return;
-		}
-		else if (count < 1)
-		{
-			d.rgb[0] = 1;
-			d.rgb[1] = 1;
-			d.rgb[2] = 1;
-		}
-
-		for (int p = 0; p < 3; p++)
-		{
-			d.rgb[p] = vsapi->propGetInt(in, "rgb", p, &err);
-
-			 if (err)
-			{
-				d.rgb[p] = d.rgb[p - 1];
-			}
-
-			else if (d.rgb[p] < 0 || d.rgb[p] > 1)
-			{
-				vsapi->setError(out, "f2qBokeh: rgb array can have values of 0 or 1 only.");
-				vsapi->freeNode(d.node);
-				vsapi->freeNode(d.nodeB);
-				return;
-			}
-
-		}
-		if (d.rgb[0] == 0 && d.rgb[1] == 0 && d.rgb[2] == 0)
-		{
-			vsapi->setError(out, "f2qBokeh: rgb array all values should not be 0");
-			vsapi->freeNode(d.node);
-			vsapi->freeNode(d.nodeB);
-			return;
-		}
-	}
-	else if (d.vi->format->colorFamily == cmYUV)
-	{
-		int count = vsapi->propNumElements(in, "yuv");
-		if (count > 3)
-		{
-			vsapi->setError(out, "f2qBokeh: yuv array cannot have more than 3 entries.");
-			vsapi->freeNode(d.node);
-			vsapi->freeNode(d.nodeB);
-			return;
-		}
-		else if (count < 1)
-		{
-			d.yuv[0] = 1;
-			d.yuv[1] = 1;
-			d.yuv[2] = 1;
-		}
-		for (int p = 0; p < 3; p++)
-		{
-			d.yuv[p] = vsapi->propGetInt(in, "yuv", p, &err);
-
-			if (err)
-			{
-				d.yuv[p] = d.yuv[p - 1];
-			}
-
-			else if (d.yuv[p] < 0 || d.yuv[p] > 1)
-			{
-				vsapi->setError(out, "f2qBokeh: yuv array can have values of 0 or 1 only.");
-				vsapi->freeNode(d.node);
-				vsapi->freeNode(d.nodeB);
-				return;
-			}
-
-		}
-		if (d.yuv[0] == 0 && d.yuv[1] == 0 && d.yuv[2] == 0)
-		{
-			vsapi->setError(out, "f2qBokeh: yuv array all values should not be 0");
-			vsapi->freeNode(d.node);
-			vsapi->freeNode(d.nodeB);
-			return;
-		}
-	}
-	
-
-	// I usually keep the filter data struct on the stack and don't allocate it
-	// until all the input validation is done.
-	data = (F2QBokehData*)malloc(sizeof(d));
-	*data = d;
-
-	// Creates a new filter and returns a reference to it. Always pass on the in and out
-	// arguments or unexpected things may happen. The name should be something that's
-	// easy to connect to the filter, like its function name.
-	// The three function pointers handle initialization, frame processing and filter destruction.
-	// The filtermode is very important to get right as it controls how threading of the filter
-	// is handled. In general you should only use fmParallel whenever possible. This is if you
-	// need to modify no shared data at all when the filter is running.
-	// For more complicated filters, fmParallelRequests is usually easier to achieve as it can
-	// be prefetched in parallel but the actual processing is serialized.
-	// The others can be considered special cases where fmSerial is useful to source filters and
-	// fmUnordered is useful when a filter's state may change even when deciding which frames to
-	// prefetch (such as a cache filter).
-	// If your filter is really fast (such as a filter that only resorts frames) you should set the
-	// nfNoCache flag to make the caching work smoother.
-
-	vsapi->createFilter(in, out, "f2qBokeh", f2qbokehInit, f2qbokehGetFrame, f2qbokehFree, fmParallel, 0, data, core);
-
+// This function is responsible for validating arguments and creating a new
+// filter
+static void VS_CC f2qbokehCreate(const VSMap *in, VSMap *out, void *userData,
+                                 VSCore *core, const VSAPI *vsapi) {
+    F2QBokehData d;
+    F2QBokehData *data;
+    int err;
+
+    // Get a clip reference from the input arguments. This must be freed later.
+    d.node = vsapi->propGetNode(in, "clip", 0, 0);
+    d.vi = vsapi->getVideoInfo(d.node);
+    // vi->format can be 0 if the input clip can change format midstream.
+    if(!isConstantFormat(d.vi) || d.vi->format->colorFamily == cmCompat ||
+       d.vi->format->colorFamily == pfRGBH ||
+       d.vi->format->colorFamily == pfYUV444PH ||
+       d.vi->format->colorFamily == pfGrayH) {
+        vsapi->setError(
+            out, "f2qBokeh: clip must have constant dimensions and in YUV or "
+                 "RGB or Grey format. Half float formats not allowed  ");
+        vsapi->freeNode(d.node);
+        return;
+    }
+    if(d.vi->format->colorFamily == cmYUV && d.vi->format->subSamplingH != 0 ||
+       d.vi->format->subSamplingW != 0) {
+        vsapi->setError(out, "f2qBokeh: YUV format clip must be type YUV444 "
+                             "i.e. no subsampling.");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    d.nodeB = vsapi->propGetNode(in, "clipb", 0, 0);
+    const VSVideoInfo *bvi = vsapi->getVideoInfo(d.nodeB);
+    if(!isSameFormat(d.vi, bvi)) {
+        vsapi->setError(out, "f2qBokeh: blur clip must have identical format "
+                             "with the input clip  ");
+        vsapi->freeNode(d.node);
+        vsapi->freeNode(d.nodeB);
+        return;
+    }
+
+    // If a property read fails for some reason (index out of bounds/wrong type)
+    // then err will have flags set to indicate why and 0 will be returned. This
+    // can be very useful to know when having optional arguments. Since we have
+    // strict checking because of what we wrote in the argument string, the only
+    // reason this could fail is when the value wasn't set by the user.
+    // And when it's not set we want it to default to enabled.
+
+    d.grid = vsapi->propGetInt(in, "grid", 0, &err);
+    if(err) {
+        d.grid = 16;
+    } else if(d.grid < 3 || d.grid > 64) {
+        vsapi->setError(out, "f2qBokeh:grid must be between 3 and 64");
+        vsapi->freeNode(d.node);
+        vsapi->freeNode(d.nodeB);
+        return;
+    }
+    d.thresh = vsapi->propGetFloat(in, "thresh", 0, &err);
+    if(err) {
+        d.thresh = 0.45f;
+    } else if(d.thresh < 0.0f || d.thresh > 1.0f) {
+        vsapi->setError(out,
+                        "f2qBokeh:value of thresh must be between 0 qnd 1.0");
+        vsapi->freeNode(d.node);
+        vsapi->freeNode(d.nodeB);
+        return;
+    }
+
+    if(d.vi->format->colorFamily == cmRGB) {
+        int count = vsapi->propNumElements(in, "rgb");
+        if(count > 3) {
+            vsapi->setError(
+                out, "f2qBokeh: rgb array cannot have more than 3 entries.");
+            vsapi->freeNode(d.node);
+            vsapi->freeNode(d.nodeB);
+            return;
+        } else if(count < 1) {
+            d.rgb[0] = 1;
+            d.rgb[1] = 1;
+            d.rgb[2] = 1;
+        }
+
+        for(int p = 0; p < 3; p++) {
+            d.rgb[p] = vsapi->propGetInt(in, "rgb", p, &err);
+
+            if(err) {
+                d.rgb[p] = d.rgb[p - 1];
+            }
+
+            else if(d.rgb[p] < 0 || d.rgb[p] > 1) {
+                vsapi->setError(
+                    out, "f2qBokeh: rgb array can have values of 0 or 1 only.");
+                vsapi->freeNode(d.node);
+                vsapi->freeNode(d.nodeB);
+                return;
+            }
+        }
+        if(d.rgb[0] == 0 && d.rgb[1] == 0 && d.rgb[2] == 0) {
+            vsapi->setError(out,
+                            "f2qBokeh: rgb array all values should not be 0");
+            vsapi->freeNode(d.node);
+            vsapi->freeNode(d.nodeB);
+            return;
+        }
+    } else if(d.vi->format->colorFamily == cmYUV) {
+        int count = vsapi->propNumElements(in, "yuv");
+        if(count > 3) {
+            vsapi->setError(
+                out, "f2qBokeh: yuv array cannot have more than 3 entries.");
+            vsapi->freeNode(d.node);
+            vsapi->freeNode(d.nodeB);
+            return;
+        } else if(count < 1) {
+            d.yuv[0] = 1;
+            d.yuv[1] = 1;
+            d.yuv[2] = 1;
+        }
+        for(int p = 0; p < 3; p++) {
+            d.yuv[p] = vsapi->propGetInt(in, "yuv", p, &err);
+
+            if(err) {
+                d.yuv[p] = d.yuv[p - 1];
+            }
+
+            else if(d.yuv[p] < 0 || d.yuv[p] > 1) {
+                vsapi->setError(
+                    out, "f2qBokeh: yuv array can have values of 0 or 1 only.");
+                vsapi->freeNode(d.node);
+                vsapi->freeNode(d.nodeB);
+                return;
+            }
+        }
+        if(d.yuv[0] == 0 && d.yuv[1] == 0 && d.yuv[2] == 0) {
+            vsapi->setError(out,
+                            "f2qBokeh: yuv array all values should not be 0");
+            vsapi->freeNode(d.node);
+            vsapi->freeNode(d.nodeB);
+            return;
+        }
+    }
+
+    // I usually keep the filter data struct on the stack and don't allocate it
+    // until all the input validation is done.
+    data = (F2QBokehData *) malloc(sizeof(d));
+    *data = d;
+
+    // Creates a new filter and returns a reference to it. Always pass on the in
+    // and out arguments or unexpected things may happen. The name should be
+    // something that's easy to connect to the filter, like its function name.
+    // The three function pointers handle initialization, frame processing and
+    // filter destruction. The filtermode is very important to get right as it
+    // controls how threading of the filter is handled. In general you should
+    // only use fmParallel whenever possible. This is if you need to modify no
+    // shared data at all when the filter is running. For more complicated
+    // filters, fmParallelRequests is usually easier to achieve as it can be
+    // prefetched in parallel but the actual processing is serialized. The
+    // others can be considered special cases where fmSerial is useful to source
+    // filters and fmUnordered is useful when a filter's state may change even
+    // when deciding which frames to prefetch (such as a cache filter). If your
+    // filter is really fast (such as a filter that only resorts frames) you
+    // should set the nfNoCache flag to make the caching work smoother.
+
+    vsapi->createFilter(in, out, "f2qBokeh", f2qbokehInit, f2qbokehGetFrame,
+                        f2qbokehFree, fmParallel, 0, data, core);
 }
 /*
-// The following function is the function that actually registers the filter in vapoursynth
-// It is called automatically, when the plugin is loaded to see which functions this filter contains.
+// The following function is the function that actually registers the filter in
+vapoursynth
+// It is called automatically, when the plugin is loaded to see which functions
+this filter contains.
 
 
-	registerFunc("f2qBokeh", "clip:clip;clipb:clip;grid:int:opt;thresh:float:opt;rgb:int[]:opt;yuv:int[]:opt;", f2qbokehCreate, 0, plugin);
+    registerFunc("f2qBokeh",
+"clip:clip;clipb:clip;grid:int:opt;thresh:float:opt;rgb:int[]:opt;yuv:int[]:opt;",
+f2qbokehCreate, 0, plugin);
 */
diff --git a/F2QFilters.h b/F2QFilters.h
index 22c5a24..31cf0d6 100644
--- a/F2QFilters.h
+++ b/F2QFilters.h
@@ -5,675 +5,631 @@
 // Butterworth filter functions required by F2Quiver of FFTQuiver plugin
 //--------------------------------------------------------------------------------
 // declarations
-	void ButterworthCircular2D(float *filt, int * fspec, int ht,int wd);
-	void ButterworthHorizontal2D(float *filt, int * fspec, int ht,int wd);
-	void ButterworthVertical2D(float *filt, int * fspec, int ht,int wd);
-	void pointNotchFilter2D( float * freqFilter, int* spec, int ht, int wd);
-	void FanFilter2D( float * freqFilter, int* spec, int ht, int wd);
-	//------------------------------------------------------------------------------
-
-	// Definitions
+void ButterworthCircular2D(float *filt, int *fspec, int ht, int wd);
+void ButterworthHorizontal2D(float *filt, int *fspec, int ht, int wd);
+void ButterworthVertical2D(float *filt, int *fspec, int ht, int wd);
+void pointNotchFilter2D(float *freqFilter, int *spec, int ht, int wd);
+void FanFilter2D(float *freqFilter, int *spec, int ht, int wd);
+//------------------------------------------------------------------------------
+
+// Definitions
 //-----------------------------------------------------------------------------------
 
 //====================================================================================================================================
-void FanFilter2D( float * freqFilter, int* spec, int ht, int wd)
-{
-	float pi = 3.14159265f;
-	int type = spec[1];
-	int locut = 1, hicut = 2, bandpass = 3, bandreject = 4, notch = 5;
-
-	float theta1 = spec[2] * pi / 180;	// fan angle start
-	float theta2 = spec[3] * pi / 180;	// fan angle end
-	if (type == locut || type == hicut || type == notch)
-		theta2 = theta1;	// only the first angle is used
-
-	int degree = spec[4];	// sharpness
-	if ( degree == 0)
-		degree = 1;	// gaussian
-
-	if(  spec[2] < 90  )	// values range from 0 to 89
-	{
-		
-		for(int w = 0; w < wd; w ++)
-		{
-			float hfreq = (w - wd / 2) * tan (theta2) ; // sin(theta2) / cos(theta2);
-			float lfreq = (w - wd / 2) * tan (theta1); //sin(theta1) / cos(theta1);
-			float * flt = freqFilter;
-			float dsqrh = sqrt (hfreq * hfreq), dsqrl = sqrt(lfreq * lfreq);
-			
-			for( int h = 0; h < ht; h ++) 
-			{
-				float hsqr = sqrt( (float)(h - ht / 2) * (h - ht / 2));
-
-				float mfactor = 1.0;
-
-				if( (h - ht/2) * (w - wd /2) > 0)	// axial values not disturbed as they represent dc values
-				{				
-					if (type != locut)
-					{
-						if (dsqrh > 0)
-							mfactor *= 1.0f / (1.0f + pow(hsqr / dsqrh, degree));
-						//else
-						//	mfactor = 0;
-					}
-					if (type != hicut)
-					{
-
-						if (hsqr > 0)
-							mfactor *= 1.0f / (1.0f + pow(dsqrl / hsqr, degree));
-						//else
-						//	mfactor = 0;
-					}
-
-					if (type == bandreject || type == notch)
-
-						mfactor = 1.0 - mfactor;
-
-					flt[w] *= mfactor;
-				}
-				
-
-				flt += wd;
-			} 
-		}
-	}
-
-	else if(  spec[2] > 90  )	// values range from 91 to 180
-	{
-		
-		for(int w = 0; w < wd; w ++)
-		{
-			float lfreq = (w - wd / 2) * tan (pi - theta2) ; // sin(theta2) / cos(theta2);
-			float hfreq = (w - wd / 2) * tan (pi - theta1); //sin(theta1) / cos(theta1);
-			//float * flt = freqFilter;
-			float dsqrh = sqrt(hfreq * hfreq), dsqrl = sqrt(lfreq * lfreq);
-			float * flt = freqFilter + (ht - 1 ) * wd;
-
-			for( int h = ht - 1; h >= 0; h --) 
-			{
-				float hsqr = sqrt( (float)(h - ht / 2) * (h - ht / 2));
-				float mfactor = 1.0;
-
-				if ((h - ht / 2) * (w - wd / 2) < 0)	// axial values not disturbed as they represent dc values
-				{
-					if (type != hicut)
-					{
-						if (dsqrh > 0)
-							mfactor *= 1.0f / (1.0f + pow(hsqr / dsqrh, degree));
-						
-					}
-					if (type != locut)
-					{
-
-						if (hsqr > 0)
-							mfactor *= 1.0f / (1.0f + pow(dsqrl / hsqr, degree));
-						
-					}
-
-					if (type == bandreject || type == notch)
-
-						mfactor = 1.0f - mfactor;
-
-					flt[w] *= mfactor;
-				}					
-																											
-
-				flt -= wd;
-			} 
-		}
-	}	
+void FanFilter2D(float *freqFilter, int *spec, int ht, int wd) {
+    float pi = 3.14159265f;
+    int type = spec[1];
+    int locut = 1, hicut = 2, bandpass = 3, bandreject = 4, notch = 5;
+
+    float theta1 = spec[2] * pi / 180; // fan angle start
+    float theta2 = spec[3] * pi / 180; // fan angle end
+    if(type == locut || type == hicut || type == notch)
+        theta2 = theta1; // only the first angle is used
+
+    int degree = spec[4]; // sharpness
+    if(degree == 0)
+        degree = 1; // gaussian
+
+    if(spec[2] < 90) // values range from 0 to 89
+    {
+
+        for(int w = 0; w < wd; w++) {
+            float hfreq =
+                (w - wd / 2) * tan(theta2); // sin(theta2) / cos(theta2);
+            float lfreq =
+                (w - wd / 2) * tan(theta1); // sin(theta1) / cos(theta1);
+            float *flt = freqFilter;
+            float dsqrh = sqrt(hfreq * hfreq), dsqrl = sqrt(lfreq * lfreq);
+
+            for(int h = 0; h < ht; h++) {
+                float hsqr = sqrt((float) (h - ht / 2) * (h - ht / 2));
+
+                float mfactor = 1.0;
+
+                if((h - ht / 2) * (w - wd / 2) >
+                   0) // axial values not disturbed as they represent dc values
+                {
+                    if(type != locut) {
+                        if(dsqrh > 0)
+                            mfactor *=
+                                1.0f / (1.0f + pow(hsqr / dsqrh, degree));
+                        // else
+                        //	mfactor = 0;
+                    }
+                    if(type != hicut) {
+
+                        if(hsqr > 0)
+                            mfactor *=
+                                1.0f / (1.0f + pow(dsqrl / hsqr, degree));
+                        // else
+                        //	mfactor = 0;
+                    }
+
+                    if(type == bandreject || type == notch)
+
+                        mfactor = 1.0 - mfactor;
+
+                    flt[w] *= mfactor;
+                }
+
+                flt += wd;
+            }
+        }
+    }
+
+    else if(spec[2] > 90) // values range from 91 to 180
+    {
+
+        for(int w = 0; w < wd; w++) {
+            float lfreq =
+                (w - wd / 2) * tan(pi - theta2); // sin(theta2) / cos(theta2);
+            float hfreq =
+                (w - wd / 2) * tan(pi - theta1); // sin(theta1) / cos(theta1);
+            // float * flt = freqFilter;
+            float dsqrh = sqrt(hfreq * hfreq), dsqrl = sqrt(lfreq * lfreq);
+            float *flt = freqFilter + (ht - 1) * wd;
+
+            for(int h = ht - 1; h >= 0; h--) {
+                float hsqr = sqrt((float) (h - ht / 2) * (h - ht / 2));
+                float mfactor = 1.0;
+
+                if((h - ht / 2) * (w - wd / 2) <
+                   0) // axial values not disturbed as they represent dc values
+                {
+                    if(type != hicut) {
+                        if(dsqrh > 0)
+                            mfactor *=
+                                1.0f / (1.0f + pow(hsqr / dsqrh, degree));
+                    }
+                    if(type != locut) {
+
+                        if(hsqr > 0)
+                            mfactor *=
+                                1.0f / (1.0f + pow(dsqrl / hsqr, degree));
+                    }
+
+                    if(type == bandreject || type == notch)
+
+                        mfactor = 1.0f - mfactor;
+
+                    flt[w] *= mfactor;
+                }
+
+                flt -= wd;
+            }
+        }
+    }
 }
 //...................................................................................................................
 
 //-------------------------------------------------------------------------------------------------------------------------------------------------
-void pointNotchFilter2D( float * freqFilter, int* spec, int ht, int wd)
-{
-	// point centered notch filter
-	float xf = (spec[2] * wd) / (NYQUIST);
-
-	float yf = (spec[3] * ht) / (NYQUIST );
-
-	int degree = spec[4];
-	if (degree == 0)
-		degree = 1;
-	// calculate notch radial sqr
-	//float d0sq = sqrt (xf*xf + yf*yf);
-	//d0sq = (ht * ht + wd * wd)/ 4;
-	for(int h = 0; h < ht; h ++)
-	{
-		for(int w = 0; w < wd; w ++)
-		{
-			float d1 = sqrt( (h - ht / 2 - yf) * (h - ht / 2 - yf) + (w - wd / 2 - xf) * (w - wd / 2 - xf) );
-			float d2 = sqrt( (h - ht / 2 + yf) * (h - ht / 2 + yf) + (w - wd / 2 + xf) * (w - wd / 2 + xf) );
-		
-			if(d1 * d2 > 0.0 )
-		
-				freqFilter[ w] *= float(1.0 /( pow(1 + 1/ d1 , degree)) * 1.0/ ( pow(1 + 1.0/d2, degree))) ;
-			else
-				freqFilter[ w] = 0.0;
-				
-		}
-
-		freqFilter += wd;
-	}
+void pointNotchFilter2D(float *freqFilter, int *spec, int ht, int wd) {
+    // point centered notch filter
+    float xf = (spec[2] * wd) / (NYQUIST);
+
+    float yf = (spec[3] * ht) / (NYQUIST);
+
+    int degree = spec[4];
+    if(degree == 0)
+        degree = 1;
+    // calculate notch radial sqr
+    // float d0sq = sqrt (xf*xf + yf*yf);
+    // d0sq = (ht * ht + wd * wd)/ 4;
+    for(int h = 0; h < ht; h++) {
+        for(int w = 0; w < wd; w++) {
+            float d1 = sqrt((h - ht / 2 - yf) * (h - ht / 2 - yf) +
+                            (w - wd / 2 - xf) * (w - wd / 2 - xf));
+            float d2 = sqrt((h - ht / 2 + yf) * (h - ht / 2 + yf) +
+                            (w - wd / 2 + xf) * (w - wd / 2 + xf));
+
+            if(d1 * d2 > 0.0)
+
+                freqFilter[w] *= float(1.0 / (pow(1 + 1 / d1, degree)) * 1.0 /
+                                       (pow(1 + 1.0 / d2, degree)));
+            else
+                freqFilter[w] = 0.0;
+        }
+
+        freqFilter += wd;
+    }
 }
-			
+
 //--------------------------------------------------------------------------------
 
-void ButterworthCircular2D(float *filt, int * fspec, int ht,int wd)
-{
-	int type = fspec[1];	// 1 locut, 2 hicut, 3 band pass 4 band stop 5 Notch
-	float vf1 = (fspec[2] * wd ) /(NYQUIST);
-	float hf1 = (fspec[2] * ht ) / (NYQUIST);
-	float vf2 = (fspec[3] * wd ) /( NYQUIST);
-	float hf2 = (fspec[3] * ht ) /(NYQUIST);
-	int degree = fspec[4] == 0 ? 1 : fspec[4];
-	float dsqr = (vf1 * vf1); 
-	float dsqrband = (vf2 * vf2) ; 
-	float ratiow2h = (1.0f * wd * wd ) /( ht * ht);
-	switch (type)
-	{
-		case 1 :	// locut or high freq pass
-		{
-			
-
-			for (int h = 0; h < ht ; h ++)
-			{
-				float d1sqr = ( h  - ht / 2 ) * ( h  - ht / 2 ) * ratiow2h;				
+void ButterworthCircular2D(float *filt, int *fspec, int ht, int wd) {
+    int type = fspec[1]; // 1 locut, 2 hicut, 3 band pass 4 band stop 5 Notch
+    float vf1 = (fspec[2] * wd) / (NYQUIST);
+    float hf1 = (fspec[2] * ht) / (NYQUIST);
+    float vf2 = (fspec[3] * wd) / (NYQUIST);
+    float hf2 = (fspec[3] * ht) / (NYQUIST);
+    int degree = fspec[4] == 0 ? 1 : fspec[4];
+    float dsqr = (vf1 * vf1);
+    float dsqrband = (vf2 * vf2);
+    float ratiow2h = (1.0f * wd * wd) / (ht * ht);
+    switch(type) {
+    case 1: // locut or high freq pass
+    {
+
+        for(int h = 0; h < ht; h++) {
+            float d1sqr = (h - ht / 2) * (h - ht / 2) * ratiow2h;
+
+            for(int w = 0; w < wd; w++) {
+                float d2sqr = (w - wd / 2) * (w - wd / 2);
+
+                if(d1sqr + d2sqr > 0)
+
+                    filt[w] *= float(
+                        1.0 / (1.0 + pow(dsqr / (d1sqr + d2sqr), degree)));
+                else
+                    filt[w] = 0;
+            }
+
+            filt += wd;
+        }
+
+        break;
+    }
+
+    case 2: // highcut or low freq pass 1.0 - locut filter
+    {
+
+        for(int h = 0; h < ht; h++) {
+            float d1sqr = (h - ht / 2) * (h - ht / 2) * ratiow2h;
+
+            for(int w = 0; w < wd; w++) {
+                float d2sqr = (w - wd / 2) * (w - wd / 2);
+
+                if(dsqr > 0)
+
+                    filt[w] *= float(
+                        1.0 / (1.0 + pow((d1sqr + d2sqr) / dsqr, degree)));
+                else
+                    filt[w] = 0;
+            }
+
+            filt += wd;
+        }
+
+        break;
+    }
 
-				for ( int w = 0; w < wd ; w ++)
-				{
-					float d2sqr = ( w - wd / 2 ) * ( w - wd / 2 ); 
+    case 3: // band pass (locut * hicut)
+    {
+        for(int h = 0; h < ht; h++) {
+            float d1sqr = (h - ht / 2) * (h - ht / 2) * ratiow2h;
+            //	float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
+            float mfactor = 1.0;
 
-					if ( d1sqr + d2sqr > 0 )
-
-						filt[w] *= float(1.0 / (1.0 + pow( dsqr / ( d1sqr + d2sqr) , degree)) );
-					else
-						filt[w] = 0;
-				}
-
-				filt += wd;
-			}
-
-			break;
-		}
-
-		case 2 : // highcut or low freq pass 1.0 - locut filter
-		{
-
-			for (int h = 0; h < ht ; h ++)
-			{
-				float d1sqr = ( h  - ht / 2 ) *( h - ht / 2 ) *  ratiow2h;				
-
-				for ( int w = 0; w < wd ; w ++)
-				{
-					float d2sqr = ( w - wd / 2 ) * ( w - wd / 2 ); 
-
-					if ( dsqr > 0 )
-
-						filt[w] *=  float(1.0 / (1.0 + pow( ( d1sqr + d2sqr)/ dsqr , degree)) );
-					else
-						filt[w] = 0;
-				}
-
-				filt += wd;
-			}
-
-			break;
-		}
-
-		case 3 :	// band pass (locut * hicut)
-		{
-			for (int h = 0; h < ht ; h ++)
-			{
-				float d1sqr = ( h  - ht / 2 ) * ( h - ht / 2 ) *  ratiow2h;				
-			//	float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
-				float mfactor = 1.0;
-
-				for ( int w = 0; w < wd ; w ++)
-				{
-					float d2sqr = ( w - wd / 2 ) * ( w - wd / 2 ); 
-			//		float d2sqrband = ( w - wd / 2 ) * ( w - wd / 2 );
-					if ( d1sqr + d2sqr > 0 )
-
-						mfactor = float(1.0 / (1.0 + pow( dsqr / ( d1sqr + d2sqr) , degree)) );
-					else
-						mfactor = 0;
-
-					if ( dsqr > 0 )
-
-						mfactor *=  float(1.0 / ( 1.0 + pow (  ( d1sqr + d2sqr) / dsqrband , degree)) );
-
-					filt[w] *= mfactor;
-				}
-
-				filt += wd;
-			}
-
-			break;
-		}
-
-		case 4 :	// band reject (locut * hicut)
-		{
-			for (int h = 0; h < ht ; h ++)
-			{
-				float d1sqr = ( h  - ht / 2 ) *( h - ht / 2 ) * ratiow2h;				
-			//	float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
-				float mfactor = 1.0f;
-
-				for ( int w = 0; w < wd ; w ++)
-				{
-					float d2sqr = ( w - wd / 2 ) * ( w - wd / 2 ); 
-				//	float d2sqrband = ( w - wd / 2 ) * ( w - wd / 2 );
-					if ( d1sqr + d2sqr > 0 )
-
-						mfactor = float(1.0 / (1.0 + pow( dsqr / ( d1sqr + d2sqr) , degree)) );
-					else
-						mfactor = 0;
+            for(int w = 0; w < wd; w++) {
+                float d2sqr = (w - wd / 2) * (w - wd / 2);
+                //		float d2sqrband = ( w - wd / 2 ) * ( w - wd / 2 );
+                if(d1sqr + d2sqr > 0)
 
-					if ( dsqrband > 0 )
+                    mfactor = float(
+                        1.0 / (1.0 + pow(dsqr / (d1sqr + d2sqr), degree)));
+                else
+                    mfactor = 0;
 
-						mfactor *= float(1.0 / ( 1.0 + pow (  ( d1sqr + d2sqr) / dsqrband , degree)) );
+                if(dsqr > 0)
 
-					filt[w] *= 1.0f - mfactor;
-				}
+                    mfactor *= float(
+                        1.0 / (1.0 + pow((d1sqr + d2sqr) / dsqrband, degree)));
 
-				filt += wd;
-			}
+                filt[w] *= mfactor;
+            }
 
-			break;
-		}
+            filt += wd;
+        }
 
-		case 5 :	// notch reject (locut * hicut)
-		{
-			for (int h = 0; h < ht ; h ++)
-			{
-				float d1sqr = ( h  - ht / 2 ) *( h - ht / 2 ) * ratiow2h;				
-			//	float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
-				float mfactor = 1.0;
+        break;
+    }
 
-				for ( int w = 0; w < wd ; w ++)
-				{
-					float d2sqr = ( w - wd / 2 ) * ( w - wd / 2 ); 
-				//	float d2sqrband = ( w - wd / 2 ) * ( w - wd / 2 );
-					if ( d1sqr + d2sqr > 0 )
-					{
+    case 4: // band reject (locut * hicut)
+    {
+        for(int h = 0; h < ht; h++) {
+            float d1sqr = (h - ht / 2) * (h - ht / 2) * ratiow2h;
+            //	float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
+            float mfactor = 1.0f;
 
-						mfactor = float(1.0 / (1.0 + pow( dsqr / ( d1sqr + d2sqr) , degree)) );
-					
-						mfactor *= float(1.0 - 1.0 / ( 1.0 + pow ( dsqr / ( d1sqr + d2sqr) , degree)) );
-					}
-					else
-						mfactor = 0;
+            for(int w = 0; w < wd; w++) {
+                float d2sqr = (w - wd / 2) * (w - wd / 2);
+                //	float d2sqrband = ( w - wd / 2 ) * ( w - wd / 2 );
+                if(d1sqr + d2sqr > 0)
 
-					filt[w] *= 1.0f - mfactor;
-				}
+                    mfactor = float(
+                        1.0 / (1.0 + pow(dsqr / (d1sqr + d2sqr), degree)));
+                else
+                    mfactor = 0;
 
-				filt += wd;
-			}
+                if(dsqrband > 0)
 
-		}
-		
-		default : {}
+                    mfactor *= float(
+                        1.0 / (1.0 + pow((d1sqr + d2sqr) / dsqrband, degree)));
 
+                filt[w] *= 1.0f - mfactor;
+            }
 
-	}
+            filt += wd;
+        }
+
+        break;
+    }
+
+    case 5: // notch reject (locut * hicut)
+    {
+        for(int h = 0; h < ht; h++) {
+            float d1sqr = (h - ht / 2) * (h - ht / 2) * ratiow2h;
+            //	float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
+            float mfactor = 1.0;
+
+            for(int w = 0; w < wd; w++) {
+                float d2sqr = (w - wd / 2) * (w - wd / 2);
+                //	float d2sqrband = ( w - wd / 2 ) * ( w - wd / 2 );
+                if(d1sqr + d2sqr > 0) {
+
+                    mfactor = float(
+                        1.0 / (1.0 + pow(dsqr / (d1sqr + d2sqr), degree)));
+
+                    mfactor *=
+                        float(1.0 - 1.0 / (1.0 + pow(dsqr / (d1sqr + d2sqr),
+                                                     degree)));
+                } else
+                    mfactor = 0;
+
+                filt[w] *= 1.0f - mfactor;
+            }
+
+            filt += wd;
+        }
+    }
+
+    default: {
+    }
+    }
 }
 
 //--------------------------------------------------------------------------------
 
-void ButterworthHorizontal2D(float *filt, int * fspec, int ht,int wd)
-{
-	int type = fspec[1];	// 1 locut, 2 hicut, 3 band pass 4 band stop 5 Notch
-	int vf1 = (fspec[2] * ht ) /(NYQUIST);
-//	int hf1 = (fspec[2] * ht ) / NYQUIST;
-	int vf2 = (fspec[3] * ht ) /( NYQUIST);
-//	int hf2 = (fspec[3] * ht ) / NYQUIST;
-	int degree = fspec[4] == 0 ? 1 : 2 * fspec[4];
-	float dsqr = (vf1 );
-	float dsqrband =(vf2 );
-	
-	switch (type)
-	{
-		case 1 :	// locut or high freq pass
-		{
-			for (int h = 0; h < ht ; h ++)
-			{
-				float d1sqr = abs( h - ht / 2 ) ;				
-				float mfactor = 1.0f;
-				
-					if ( d1sqr > 0 )
-
-						mfactor *= float(1.0 / (1.0 + pow(dsqr / (d1sqr), degree)));
-					else
-						mfactor = 0;
-
-				for ( int w = 0; w < wd ; w ++)
-				{
-					filt[w] *= mfactor;
-				}
-
-				filt += wd;
-			}
-
-			break;
-		}
-
-		case 2 : // highcut or low freq pass 1.0 - locut filter
-		{
-
-			for (int h = 0; h < ht ; h ++)
-			{
-				float d1sqr =  abs( h - ht / 2 ) ;			
-				float mfactor = 1.0f;
-				
-				if ( d1sqr > 0 )
-
-					mfactor = float(1.0 / (1.0 + pow(d1sqr / (dsqr), degree)));
-
-				else
-
-					mfactor = 1.0f;
-					
-				for ( int w = 0; w < wd ; w ++)
-				{
-					filt[w] *= mfactor;
-				}
-
-				filt += wd;
-			}
-
-			break;
-		}
-
-		case 3 :	// band pass (locut * hicut)
-		{
-			for (int h = 0; h < ht ; h ++)
-			{
-				float d1sqr =  abs( h - ht / 2 ) ;			
-				//float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
-				float mfactor = 1.0f;
-
-				
-					if ( d1sqr  > 0 )					
-
-						mfactor = float(1.0 / (1.0 + pow(dsqr / (d1sqr), degree)));
-					else
-
-						mfactor = 0.0;
-					
-					mfactor *= float(1.0 / (1.0 + pow(d1sqr / (dsqrband), degree)));
-					
-				for ( int w = 0; w < wd ; w ++)
-				{
-
-					filt[w] *= mfactor;
-				}
-
-				filt += wd;
-			}
-
-			break;
-		}
-
-		case 4 :	// band reject (locut * hicut)
-		{
-			for (int h = 0; h < ht ; h ++)
-			{
-				float d1sqr =  abs( h - ht / 2 ) ;		
-			//	float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
-				float mfactor = 1.0f;
-
-				
-					if ( d1sqr  > 0 )
-
-						mfactor = float(1.0 / (1.0 + pow(dsqr / (d1sqr), degree)));
-					else
-						mfactor = 0.0;
+void ButterworthHorizontal2D(float *filt, int *fspec, int ht, int wd) {
+    int type = fspec[1]; // 1 locut, 2 hicut, 3 band pass 4 band stop 5 Notch
+    int vf1 = (fspec[2] * ht) / (NYQUIST);
+    //	int hf1 = (fspec[2] * ht ) / NYQUIST;
+    int vf2 = (fspec[3] * ht) / (NYQUIST);
+    //	int hf2 = (fspec[3] * ht ) / NYQUIST;
+    int degree = fspec[4] == 0 ? 1 : 2 * fspec[4];
+    float dsqr = (vf1);
+    float dsqrband = (vf2);
+
+    switch(type) {
+    case 1: // locut or high freq pass
+    {
+        for(int h = 0; h < ht; h++) {
+            float d1sqr = abs(h - ht / 2);
+            float mfactor = 1.0f;
+
+            if(d1sqr > 0)
+
+                mfactor *= float(1.0 / (1.0 + pow(dsqr / (d1sqr), degree)));
+            else
+                mfactor = 0;
+
+            for(int w = 0; w < wd; w++) {
+                filt[w] *= mfactor;
+            }
+
+            filt += wd;
+        }
+
+        break;
+    }
 
-					if ( dsqrband  > 0 )
+    case 2: // highcut or low freq pass 1.0 - locut filter
+    {
 
-						mfactor *= float(1.0 / (1.0 + pow(d1sqr / (dsqrband), degree)));
-					else
-						mfactor = 0.0;
+        for(int h = 0; h < ht; h++) {
+            float d1sqr = abs(h - ht / 2);
+            float mfactor = 1.0f;
 
-				for ( int w = 0; w < wd ; w ++)
-				{
+            if(d1sqr > 0)
 
-					filt[w] *= 1.0f - mfactor;
-				}
+                mfactor = float(1.0 / (1.0 + pow(d1sqr / (dsqr), degree)));
 
-				filt += wd;
-			}
+            else
 
-			break;
-		}
+                mfactor = 1.0f;
 
-		case 5 :	// notch reject (locut * hicut)
-		{
-			for (int h = 0; h < ht ; h ++)
-			{
-				float d1sqr =  abs( h - ht / 2 ) ;														
-			//	float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
-				float mfactor = 1.0f;				
-					
-					if ( d1sqr  > 0 )
+            for(int w = 0; w < wd; w++) {
+                filt[w] *= mfactor;
+            }
 
-						mfactor = float(1.0 / (1.0 + pow(dsqr / (d1sqr), degree)));
-					else
-						mfactor = 0.0;
+            filt += wd;
+        }
 
-					if ( dsqr > 0 )
+        break;
+    }
 
-						mfactor *= float(1.0 / (1.0 + pow(d1sqr / (dsqr), degree)));
+    case 3: // band pass (locut * hicut)
+    {
+        for(int h = 0; h < ht; h++) {
+            float d1sqr = abs(h - ht / 2);
+            // float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
+            float mfactor = 1.0f;
 
-					else
-						mfactor = 0.0;
+            if(d1sqr > 0)
 
-				for ( int w = 0; w < wd ; w ++)
-				{
+                mfactor = float(1.0 / (1.0 + pow(dsqr / (d1sqr), degree)));
+            else
 
-					filt[w] *= 1.0f - mfactor;
-				}
+                mfactor = 0.0;
 
-				filt += wd;
-			}
+            mfactor *= float(1.0 / (1.0 + pow(d1sqr / (dsqrband), degree)));
 
-		}
-		
-		default : {}
+            for(int w = 0; w < wd; w++) {
 
+                filt[w] *= mfactor;
+            }
 
-	}
+            filt += wd;
+        }
+
+        break;
+    }
+
+    case 4: // band reject (locut * hicut)
+    {
+        for(int h = 0; h < ht; h++) {
+            float d1sqr = abs(h - ht / 2);
+            //	float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
+            float mfactor = 1.0f;
+
+            if(d1sqr > 0)
+
+                mfactor = float(1.0 / (1.0 + pow(dsqr / (d1sqr), degree)));
+            else
+                mfactor = 0.0;
+
+            if(dsqrband > 0)
+
+                mfactor *= float(1.0 / (1.0 + pow(d1sqr / (dsqrband), degree)));
+            else
+                mfactor = 0.0;
+
+            for(int w = 0; w < wd; w++) {
+
+                filt[w] *= 1.0f - mfactor;
+            }
+
+            filt += wd;
+        }
+
+        break;
+    }
+
+    case 5: // notch reject (locut * hicut)
+    {
+        for(int h = 0; h < ht; h++) {
+            float d1sqr = abs(h - ht / 2);
+            //	float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
+            float mfactor = 1.0f;
+
+            if(d1sqr > 0)
+
+                mfactor = float(1.0 / (1.0 + pow(dsqr / (d1sqr), degree)));
+            else
+                mfactor = 0.0;
+
+            if(dsqr > 0)
+
+                mfactor *= float(1.0 / (1.0 + pow(d1sqr / (dsqr), degree)));
+
+            else
+                mfactor = 0.0;
+
+            for(int w = 0; w < wd; w++) {
+
+                filt[w] *= 1.0f - mfactor;
+            }
+
+            filt += wd;
+        }
+    }
+
+    default: {
+    }
+    }
 }
 
 //--------------------------------------------------------------------------------
 
-void ButterworthVertical2D(float *filt, int * fspec, int ht,int wd)
-{
-	int type = fspec[1];	// 1 locut, 2 hicut, 3 band pass 4 band stop 5 Notch
-	//int vf1 = (fspec[2] * ht ) /(2 * NYQUIST);
-	int hf1 = (fspec[2] * wd ) / NYQUIST; 
-	//int vf2 = (fspec[3] * ht ) /(2 * NYQUIST);
-	int hf2 = (fspec[3] * wd ) / NYQUIST; 
-	int degree = fspec[4] == 0 ? 1 : 2 * fspec[4];
-	float dsqr = ( hf1 );
-	float dsqrband =( hf2  );
+void ButterworthVertical2D(float *filt, int *fspec, int ht, int wd) {
+    int type = fspec[1]; // 1 locut, 2 hicut, 3 band pass 4 band stop 5 Notch
+    // int vf1 = (fspec[2] * ht ) /(2 * NYQUIST);
+    int hf1 = (fspec[2] * wd) / NYQUIST;
+    // int vf2 = (fspec[3] * ht ) /(2 * NYQUIST);
+    int hf2 = (fspec[3] * wd) / NYQUIST;
+    int degree = fspec[4] == 0 ? 1 : 2 * fspec[4];
+    float dsqr = (hf1);
+    float dsqrband = (hf2);
 
-	switch (type)
-	{
-		case 1 :	// locut or high freq pass
-		{			
+    switch(type) {
+    case 1: // locut or high freq pass
+    {
 
-			for (int w = 0; w < wd ; w ++)
-			{
-				float * flt = filt + w;
+        for(int w = 0; w < wd; w++) {
+            float *flt = filt + w;
 
-				float d2sqr = abs( w - wd / 2 ) ;
+            float d2sqr = abs(w - wd / 2);
 
-				float mfactor;
+            float mfactor;
 
-				
-					if (  d2sqr > 0 )
+            if(d2sqr > 0)
 
-						mfactor = float(1.0 / (1.0 + pow(dsqr / (d2sqr), degree)));
-					else
-						mfactor = 0;
+                mfactor = float(1.0 / (1.0 + pow(dsqr / (d2sqr), degree)));
+            else
+                mfactor = 0;
 
-				for ( int h = 0; h < ht ; h ++)
-				{
-					flt[0] *= mfactor;
+            for(int h = 0; h < ht; h++) {
+                flt[0] *= mfactor;
 
-					flt += wd;
-				}
-			}
+                flt += wd;
+            }
+        }
 
-			break;
-		}
+        break;
+    }
 
-		case 2 : // highcut or low freq pass 1.0 - locut filter
-		{
+    case 2: // highcut or low freq pass 1.0 - locut filter
+    {
 
-			for (int w = 0; w < wd ; w ++)
-			{
-				float * flt = filt + w;
+        for(int w = 0; w < wd; w++) {
+            float *flt = filt + w;
 
-				float d2sqr =  abs( w - wd / 2 ) ;			
+            float d2sqr = abs(w - wd / 2);
 
-				float mfactor;
+            float mfactor;
 
-					if (  d2sqr > 0 ) 					
+            if(d2sqr > 0)
 
-						mfactor = float(1.0 / (1.0 + pow(d2sqr / (dsqr), degree)));
-					else
-						mfactor = 1.0f;
+                mfactor = float(1.0 / (1.0 + pow(d2sqr / (dsqr), degree)));
+            else
+                mfactor = 1.0f;
 
-				for ( int h = 0; h < ht ; h ++)
-				{
-					flt[0] *= mfactor;
+            for(int h = 0; h < ht; h++) {
+                flt[0] *= mfactor;
 
-					flt += wd;
-				}
-			}
+                flt += wd;
+            }
+        }
 
-			break;
-		}
+        break;
+    }
 
-		case 3 :	// band pass (locut * hicut)
-		{
-			for (int w = 0; w < wd ; w ++)
-			{
-				float * flt = filt + w;
+    case 3: // band pass (locut * hicut)
+    {
+        for(int w = 0; w < wd; w++) {
+            float *flt = filt + w;
 
-				float d2sqr = abs( w - wd / 2 ) ;				
-			//	float d2sqrband = abs( w - wd / 2 );
+            float d2sqr = abs(w - wd / 2);
+            //	float d2sqrband = abs( w - wd / 2 );
 
-				float mfactor = 1.0f;				
-					
-					if ( d2sqr > 0 )
+            float mfactor = 1.0f;
 
-						mfactor = float(1.0 / (1.0 + pow(dsqr / (d2sqr), degree)));
-							   
-					else
-						mfactor = 0.0;
+            if(d2sqr > 0)
 
-					if ( dsqrband > 0)
+                mfactor = float(1.0 / (1.0 + pow(dsqr / (d2sqr), degree)));
 
-						mfactor *= float(1.0 / (1.0 + pow(d2sqr / (dsqrband), degree)));
-				//	else
-				//		mfactor = 1.00;
-					
-				for ( int h = 0; h < ht ; h ++)
-				{
+            else
+                mfactor = 0.0;
 
-					flt[0] *= mfactor;				
+            if(dsqrband > 0)
 
-					flt += wd;
-				}
-			}
+                mfactor *= float(1.0 / (1.0 + pow(d2sqr / (dsqrband), degree)));
+            //	else
+            //		mfactor = 1.00;
 
-			break;
-		}
+            for(int h = 0; h < ht; h++) {
 
-		case 4 :	// band reject (locut * hicut)
-		{
-			for (int w = 0; w < wd ; w ++)
-			{
-				float * flt = filt + w;
+                flt[0] *= mfactor;
 
-				float d2sqr = abs( w - wd / 2 ) ;		
-			//	float d2sqrband = abs( w - wd / 2 );
+                flt += wd;
+            }
+        }
 
-				float mfactor = 1.0f;										
-				if (d2sqr > 0)
+        break;
+    }
 
-					mfactor = float(1.0 / (1.0 + pow(dsqr / (d2sqr), degree)));
-				else
-					mfactor = 0;
+    case 4: // band reject (locut * hicut)
+    {
+        for(int w = 0; w < wd; w++) {
+            float *flt = filt + w;
 
-					if(dsqrband > 0)
+            float d2sqr = abs(w - wd / 2);
+            //	float d2sqrband = abs( w - wd / 2 );
 
-						mfactor *= float(1.0 / (1.0 + pow(d2sqr / (dsqrband), degree)));
+            float mfactor = 1.0f;
+            if(d2sqr > 0)
 
-					else
-						mfactor = 0;
-					
-				for ( int h = 0; h < ht ; h ++)
-				{
+                mfactor = float(1.0 / (1.0 + pow(dsqr / (d2sqr), degree)));
+            else
+                mfactor = 0;
 
-					flt[0] *= 1 -  mfactor;				
+            if(dsqrband > 0)
 
-					flt += wd;
-				}
-			}
+                mfactor *= float(1.0 / (1.0 + pow(d2sqr / (dsqrband), degree)));
 
-			break;
-		}
+            else
+                mfactor = 0;
 
-		case 5 :	// notch reject (locut * hicut)
-		{
-			
-			float mfactor = 1.0;
+            for(int h = 0; h < ht; h++) {
 
-			for (int w = 0; w < wd ; w ++)
-			{
-				float * flt = filt + w;
+                flt[0] *= 1 - mfactor;
 
-				float d2sqr = abs( w - wd / 2 ) ;			
+                flt += wd;
+            }
+        }
 
-				float mfactor = 1.0f;				
-					
-					if ( d2sqr > 0 )					
+        break;
+    }
 
-						mfactor = float(1.0 / (1.0 + pow(dsqr / (d2sqr), degree)));
-							 
-					else
-						mfactor = 0.0;
+    case 5: // notch reject (locut * hicut)
+    {
 
-					if ( dsqr > 0)
+        float mfactor = 1.0;
 
-						mfactor *= float(1.0 / (1.0 + pow(d2sqr / (dsqr), degree)));
-					else
-						mfactor = 0;
-					
-				for ( int h = 0; h < ht ; h ++)
-				{
+        for(int w = 0; w < wd; w++) {
+            float *flt = filt + w;
 
-					flt[0] *= 1.0f - mfactor;				
+            float d2sqr = abs(w - wd / 2);
 
-					flt += wd;
-				}
-			}
+            float mfactor = 1.0f;
 
-			break;
-		}
-		
-		default : {}
+            if(d2sqr > 0)
 
+                mfactor = float(1.0 / (1.0 + pow(dsqr / (d2sqr), degree)));
 
-	}
-}
+            else
+                mfactor = 0.0;
 
+            if(dsqr > 0)
 
+                mfactor *= float(1.0 / (1.0 + pow(d2sqr / (dsqr), degree)));
+            else
+                mfactor = 0;
+
+            for(int h = 0; h < ht; h++) {
+
+                flt[0] *= 1.0f - mfactor;
+
+                flt += wd;
+            }
+        }
+
+        break;
+    }
+
+    default: {
+    }
+    }
+}
 
 #endif
\ No newline at end of file
diff --git a/F2QLimit.cpp b/F2QLimit.cpp
index e0b24f3..16edc8a 100644
--- a/F2QLimit.cpp
+++ b/F2QLimit.cpp
@@ -1,8 +1,8 @@
-// This file contains a  F2QLimit filter which transforms frame into 2D freq domain through fft
-// and limits values after searching for local maximum
+// This file contains a  F2QLimit filter which transforms frame into 2D freq
+// domain through fft and limits values after searching for local maximum
 /*
-This plugin needs any one of libfftw3f-3.dll, FFTW3 dll, fftw.dll to reside in path
-(may be windows\system32 folder)
+This plugin needs any one of libfftw3f-3.dll, FFTW3 dll, fftw.dll to reside in
+path (may be windows\system32 folder)
 
 Author V.C.Mohan.
 Jun 2015, 22 May 2021
@@ -24,286 +24,297 @@ see <http://www.gnu.org/licenses/>.
 
 ********************************************************************************/
 /*
-#include <stdlib.h>
-#include "VapourSynth.h"
+#include "F2QFilters.h"
+#include "F2QuiverSpectralDisplay.h"
+#include "Factorize.cpp"
 #include "VSHelper.h"
+#include "VapourSynth.h"
+#include "fftwlite.h"
+#include "windows.h"
 #include  <math.h>
+#include <stdlib.h>
 #include <vector>
-#include "windows.h"
-#include "fftwlite.h"
-#include "Factorize.cpp"
-#include "F2QFilters.h"
-#include "F2QuiverSpectralDisplay.h"
 */
 typedef struct {
-		VSNodeRef *node;
-		const VSVideoInfo *vi;
-		
-		int	fspec[60];
-		int npoints;		// number of filters or for custo pairs specified
-		int	grid;		// square from -grid to grid horizontal and vertical search 
-		int	inner;		// - inner to inner limited
-		int warn;		// warning level 0 no warning, 1 warns if close to origin, 2 warns if close to axis
-		int xgrid, ygrid;
-		int xinner, yinner;
-						// late binding of fft dll
+    VSNodeRef *node;
+    const VSVideoInfo *vi;
+
+    int fspec[60];
+    int npoints; // number of filters or for custo pairs specified
+    int grid;    // square from -grid to grid horizontal and vertical search
+    int inner;   // - inner to inner limited
+    int warn; // warning level 0 no warning, 1 warns if close to origin, 2 warns
+              // if close to axis
+    int xgrid, ygrid;
+    int xinner, yinner;
+    // late binding of fft dll
 #include "fftLateBindingClassParams.cpp"
-		float* inBuf;
-		fftwf_complex* outBuf;	
-		fftwf_plan 	pf, pinv;		// fftwf creates a plan of process. pointer to it	
-		int	 hbest, wbest;	// best dimension for speed
-		int frqwidth;		// width in freq domain;
+    float *inBuf;
+    fftwf_complex *outBuf;
+    fftwf_plan pf, pinv; // fftwf creates a plan of process. pointer to it
+    int hbest, wbest;    // best dimension for speed
+    int frqwidth;        // width in freq domain;
 } F2QLimitData;
 //------------------------------------------------------------------------------
 template <typename finc>
-void F2QLimitProcess(F2QLimitData *d,finc* wp, const int wpitch,
-	const int ht, const int wd, 
-	const finc min, const finc max);
-int getOffsetOfMaxInSearchArea(fftwf_complex* center, int pitch,
-								int x, int y, int xgrid, int ygrid);
-void limitValuesInner(fftwf_complex* center,  int pitch, int xinner,int yinner, int limit);
+void F2QLimitProcess(F2QLimitData *d, finc *wp, const int wpitch, const int ht,
+                     const int wd, const finc min, const finc max);
+int getOffsetOfMaxInSearchArea(fftwf_complex *center, int pitch, int x, int y,
+                               int xgrid, int ygrid);
+void limitValuesInner(fftwf_complex *center, int pitch, int xinner, int yinner,
+                      int limit);
 
-void applyLimits(F2QLimitData* d, int i);
+void applyLimits(F2QLimitData *d, int i);
 
 //====================================================================================
 
-// This function is called immediately after vsapi->createFilter(). This is the only place where the video
-// properties may be set. In this case we simply use the same as the input clip. You may pass an array
-// of VSVideoInfo if the filter has more than one output, like rgb+alpha as two separate clips.
-static void VS_CC f2qlimitInit(VSMap *in, VSMap *out, void **instanceData, VSNode *node, VSCore *core, const VSAPI *vsapi)
-{
-    F2QLimitData *d = (F2QLimitData *) * instanceData;
-    vsapi->setVideoInfo(d->vi, 1, node);	
-
-	int * facbuf =  vs_aligned_malloc<int> (sizeof(int) * 64, 32);	//maximum 64 factors, first is factor, second is dividend to be factored. At 
-								
-				
-	// make sure we have even numbers as starting values of width and height
-	int wdEven = ((d->vi->width + 3) >> 2) << 2;
-	int htEven = ((d->vi->height + 3) >> 2) << 2;
-	//	best dimensions for speed// a value of 1 no more factors		
-	d->wbest = getBestDim(wdEven + ADDSAFE, facbuf);
-	d->hbest = getBestDim(htEven + ADDSAFE, facbuf);
-
-	vs_aligned_free(facbuf);
-	
-	d->frqwidth = (d->wbest / 2) + 1;
-	int f2qsize = d->hbest * d->frqwidth;
-	d->xgrid = (d->grid * d->frqwidth) / NYQUIST;
-	d->ygrid = (d->grid * d->hbest) / NYQUIST;
-	d->xinner = (d->inner * d->frqwidth) / NYQUIST;
-	d->yinner = (d->inner * d->hbest) / NYQUIST;
-	// set up points to limit
-	for (int i = 0; i < d->npoints; i += 3)
-	{
-		d->fspec[i] = (d->fspec[i] * d->frqwidth) / NYQUIST;	// freq along width
-		d->fspec[i + 1] = (d->fspec[i + 1] * d->hbest) / NYQUIST; // freq along height
-		
-		if (d->warn > 0)
-		{
-			bool xtrue = (d->fspec[i] + d->xgrid >= 0 && d->fspec[i] - d->xgrid <= 0);
-			bool ytrue = (d->fspec[i + 1] + d->ygrid >= 0 && d->fspec[i + 1] - d->ygrid <= 0);
-			if (d->warn == 1)
-			{
-				if (xtrue && ytrue)
-				{
-					vsapi->setError(out, "F2QLimit: search area includes origin");
-					vsapi->freeNode(d->node);					
-					free(d);
-					return;
-				}
-			}
-			else if (xtrue || ytrue)
-			{
-				vsapi->setError(out, "F2QLimit: search area includes axis");
-				vsapi->freeNode(d->node);
-				free(d);
-				return;
-			}
-
-		}
-	}
+// This function is called immediately after vsapi->createFilter(). This is the
+// only place where the video properties may be set. In this case we simply use
+// the same as the input clip. You may pass an array of VSVideoInfo if the
+// filter has more than one output, like rgb+alpha as two separate clips.
+static void VS_CC f2qlimitInit(VSMap *in, VSMap *out, void **instanceData,
+                               VSNode *node, VSCore *core, const VSAPI *vsapi) {
+    F2QLimitData *d = (F2QLimitData *) *instanceData;
+    vsapi->setVideoInfo(d->vi, 1, node);
+
+    int *facbuf = vs_aligned_malloc<int>(
+        sizeof(int) * 64, 32); // maximum 64 factors, first is factor, second is
+                               // dividend to be factored. At
+
+    // make sure we have even numbers as starting values of width and height
+    int wdEven = ((d->vi->width + 3) >> 2) << 2;
+    int htEven = ((d->vi->height + 3) >> 2) << 2;
+    //	best dimensions for speed// a value of 1 no more factors
+    d->wbest = getBestDim(wdEven + ADDSAFE, facbuf);
+    d->hbest = getBestDim(htEven + ADDSAFE, facbuf);
+
+    vs_aligned_free(facbuf);
+
+    d->frqwidth = (d->wbest / 2) + 1;
+    int f2qsize = d->hbest * d->frqwidth;
+    d->xgrid = (d->grid * d->frqwidth) / NYQUIST;
+    d->ygrid = (d->grid * d->hbest) / NYQUIST;
+    d->xinner = (d->inner * d->frqwidth) / NYQUIST;
+    d->yinner = (d->inner * d->hbest) / NYQUIST;
+    // set up points to limit
+    for(int i = 0; i < d->npoints; i += 3) {
+        d->fspec[i] = (d->fspec[i] * d->frqwidth) / NYQUIST; // freq along width
+        d->fspec[i + 1] =
+            (d->fspec[i + 1] * d->hbest) / NYQUIST; // freq along height
+
+        if(d->warn > 0) {
+            bool xtrue =
+                (d->fspec[i] + d->xgrid >= 0 && d->fspec[i] - d->xgrid <= 0);
+            bool ytrue = (d->fspec[i + 1] + d->ygrid >= 0 &&
+                          d->fspec[i + 1] - d->ygrid <= 0);
+            if(d->warn == 1) {
+                if(xtrue && ytrue) {
+                    vsapi->setError(out,
+                                    "F2QLimit: search area includes origin");
+                    vsapi->freeNode(d->node);
+                    free(d);
+                    return;
+                }
+            } else if(xtrue || ytrue) {
+                vsapi->setError(out, "F2QLimit: search area includes axis");
+                vsapi->freeNode(d->node);
+                free(d);
+                return;
+            }
+        }
+    }
 
 #include "ConstructorCodeForLateBindingfft.cpp"
 
-	if (!ok)
-	{
-		vsapi->setError(out, "F2QLimit: could not load any of the fft dll or get required fnctions");
-		if (d->hinstLib != NULL)
-			FreeLibrary(d->hinstLib);
-		vsapi->freeNode(d->node);
-		return;
-	}
-	// buffers 
-	d->inBuf = (float*)d->fftwf_malloc(sizeof(float) * d->wbest * d->hbest);
-	
-	d->outBuf = (fftwf_complex*)d->fftwf_malloc (sizeof(fftwf_complex) * f2qsize);//  is only a safeguard not really reqd
-	
-
-	if(d->inBuf == NULL || d->outBuf == NULL )
-	{
-		vsapi->setError(out, "F2QLimit: unexpectedly buffers not allocated error");
-		vsapi->freeNode(d->node);
-		FreeLibrary(d->hinstLib);
-		free(d);
-		return;
-	}
-	
-
-	d->pf = d->fftwf_plan_dft_r2c_2d(d->hbest, d->wbest, d->inBuf, d->outBuf, FFTW_MEASURE );
-	d->pinv = d->fftwf_plan_dft_c2r_2d(d->hbest, d->wbest, d->outBuf, d->inBuf, FFTW_MEASURE );
-
-	if(  d->pf == NULL || d->pinv == NULL)
-	{
-		vsapi->setError(out, "F2QLimit: unexpected  fft plans  error");
-		vsapi->freeNode(d->node);
-		d->fftwf_free(d->inBuf);
-		d->fftwf_free(d->outBuf);
-		FreeLibrary(d->hinstLib);
-		free(d);
-		return;
-	}
-	
-
-	
+    if(!ok) {
+        vsapi->setError(out, "F2QLimit: could not load any of the fft dll or "
+                             "get required fnctions");
+        if(d->hinstLib != NULL)
+            // Error
+            //    FreeLibrary(d->hinstLib);
+            // Fix
+            if(d->hinstLib != nullptr) {
+#ifdef _WIN32
+                FreeLibrary((HINSTANCE) d->hinstLib);
+#else
+                dlclose(d->hinstLib);
+#endif
+            }
+        vsapi->freeNode(d->node);
+        return;
+    }
+    // buffers
+    d->inBuf = (float *) d->fftwf_malloc(sizeof(float) * d->wbest * d->hbest);
+
+    d->outBuf = (fftwf_complex *) d->fftwf_malloc(
+        sizeof(fftwf_complex) *
+        f2qsize); //  is only a safeguard not really reqd
+
+    if(d->inBuf == NULL || d->outBuf == NULL) {
+        vsapi->setError(out,
+                        "F2QLimit: unexpectedly buffers not allocated error");
+        vsapi->freeNode(d->node);
+        // Error
+        //		FreeLibrary(d->hinstLib);
+        // Fix
+        if(d->hinstLib != nullptr) {
+#ifdef _WIN32
+            FreeLibrary((HINSTANCE) d->hinstLib);
+#else
+            dlclose(d->hinstLib);
+#endif
+        }
+        free(d);
+        return;
+    }
+
+    d->pf = d->fftwf_plan_dft_r2c_2d(d->hbest, d->wbest, d->inBuf, d->outBuf,
+                                     FFTW_MEASURE);
+    d->pinv = d->fftwf_plan_dft_c2r_2d(d->hbest, d->wbest, d->outBuf, d->inBuf,
+                                       FFTW_MEASURE);
+
+    if(d->pf == NULL || d->pinv == NULL) {
+        vsapi->setError(out, "F2QLimit: unexpected  fft plans  error");
+        vsapi->freeNode(d->node);
+        d->fftwf_free(d->inBuf);
+        d->fftwf_free(d->outBuf);
+        // Error
+        //		FreeLibrary(d->hinstLib);
+        // Fix
+        if(d->hinstLib != nullptr) {
+#ifdef _WIN32
+            FreeLibrary((HINSTANCE) d->hinstLib);
+#else
+            dlclose(d->hinstLib);
+#endif
+        }
+
+        free(d);
+        return;
+    }
 }
 //-----------...........................................
 
-int getOffsetOfMaxInSearchArea(fftwf_complex* center, int pitch, 
-								int x, int y, int xgrid, int ygrid)
-{
-	int searchOffset = y * pitch + x;
-	//int hmax, wmax;
-	int offsetMax;
-	float maximum = 0.0f, local = 0.0f;
-	for (int h = - ygrid; h <=  ygrid; h++)
-	{
-		for (int w = - xgrid; w <=  xgrid; w++)
-		{
-			local = getAmpSquareOfComplex(center + searchOffset + h * pitch + w);
-			if (local > maximum)
-			{
-				maximum = local;
-				
-				offsetMax = searchOffset + h * pitch + w;
-			}
-		}
-	}
-	return offsetMax;
+int getOffsetOfMaxInSearchArea(fftwf_complex *center, int pitch, int x, int y,
+                               int xgrid, int ygrid) {
+    int searchOffset = y * pitch + x;
+    // int hmax, wmax;
+    int offsetMax;
+    float maximum = 0.0f, local = 0.0f;
+    for(int h = -ygrid; h <= ygrid; h++) {
+        for(int w = -xgrid; w <= xgrid; w++) {
+            local =
+                getAmpSquareOfComplex(center + searchOffset + h * pitch + w);
+            if(local > maximum) {
+                maximum = local;
+
+                offsetMax = searchOffset + h * pitch + w;
+            }
+        }
+    }
+    return offsetMax;
 }
 
-void limitValuesInner(fftwf_complex* maxC, int pitch, int xinner, int yinner, int limit)
-{
-	for (int h = -yinner; h <= yinner; h++)
-	{
-		for (int w = -xinner; w <= xinner; w++)
-		{
-			maxC[h * pitch + w][0] *= limit / 100.0f;
-			maxC[h * pitch + w][1] *= limit / 100.0f;			
-		}
-	}
+void limitValuesInner(fftwf_complex *maxC, int pitch, int xinner, int yinner,
+                      int limit) {
+    for(int h = -yinner; h <= yinner; h++) {
+        for(int w = -xinner; w <= xinner; w++) {
+            maxC[h * pitch + w][0] *= limit / 100.0f;
+            maxC[h * pitch + w][1] *= limit / 100.0f;
+        }
+    }
 }
 template <typename finc>
-void F2QLimitProcess(F2QLimitData * d, finc* wp, const int wpitch,
-	const int ht, const int wd, const finc min, const finc max)	
-{
-	// get input in float form and padded with required zeroes
-	getRealInput2D(d->inBuf, wp, wpitch,
-		ht, wd, d->hbest, d->wbest, true);
-	// forward fft transform
-	d->fftwf_execute(d->pf);
-	// search grid around points, apply limits to inner square
-	for (int i = 0; i < d->npoints; i += 3)
-		applyLimits(d, i);
-	// inverse fft
-	d->fftwf_execute(d->pinv);
-
-	removeInputCentering(d->inBuf, d->wbest, d->hbest ); // also scales down as fft twice will scale up by wbest * hbest
-	
-	getRealOutput2D(d->inBuf, wp, wpitch, 
-		ht, wd, d->hbest, d->wbest, min, max);
-	
+void F2QLimitProcess(F2QLimitData *d, finc *wp, const int wpitch, const int ht,
+                     const int wd, const finc min, const finc max) {
+    // get input in float form and padded with required zeroes
+    getRealInput2D(d->inBuf, wp, wpitch, ht, wd, d->hbest, d->wbest, true);
+    // forward fft transform
+    d->fftwf_execute(d->pf);
+    // search grid around points, apply limits to inner square
+    for(int i = 0; i < d->npoints; i += 3)
+        applyLimits(d, i);
+    // inverse fft
+    d->fftwf_execute(d->pinv);
+
+    removeInputCentering(d->inBuf, d->wbest,
+                         d->hbest); // also scales down as fft twice will scale
+                                    // up by wbest * hbest
+
+    getRealOutput2D(d->inBuf, wp, wpitch, ht, wd, d->hbest, d->wbest, min, max);
 }
 //................................................................
-void applyLimits(F2QLimitData* d, int nf)
-{
-	float max = 0.0f;
-	
-	int centerOffset = (d->hbest / 2) * d->frqwidth + d->frqwidth / 2;
-
-	int offMax = getOffsetOfMaxInSearchArea(d->outBuf + centerOffset,
-		d->frqwidth, d->fspec[nf], d->fspec[nf + 1], d->xgrid, d->ygrid);	
-
-	limitValuesInner(d->outBuf + centerOffset + offMax, 
-						d->frqwidth, d->xinner, d->yinner, d->fspec[nf + 2]);
-		// diagonally opposite
-	limitValuesInner(d->outBuf + centerOffset - offMax,
-		d->frqwidth, d->xinner,d->yinner, d->fspec[nf + 2]);
-	
+void applyLimits(F2QLimitData *d, int nf) {
+    float max = 0.0f;
+
+    int centerOffset = (d->hbest / 2) * d->frqwidth + d->frqwidth / 2;
+
+    int offMax = getOffsetOfMaxInSearchArea(
+        d->outBuf + centerOffset, d->frqwidth, d->fspec[nf], d->fspec[nf + 1],
+        d->xgrid, d->ygrid);
+
+    limitValuesInner(d->outBuf + centerOffset + offMax, d->frqwidth, d->xinner,
+                     d->yinner, d->fspec[nf + 2]);
+    // diagonally opposite
+    limitValuesInner(d->outBuf + centerOffset - offMax, d->frqwidth, d->xinner,
+                     d->yinner, d->fspec[nf + 2]);
 }
 //......................................................................
 
 //---------------------------------------------------------------------------------------------------------------------------
-static const VSFrameRef *VS_CC f2qlimitGetFrame(int n, int activationReason, void **instanceData, 
-						void **frameData, VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) 
-{
-    F2QLimitData *d = (F2QLimitData *) * instanceData;
+static const VSFrameRef *VS_CC f2qlimitGetFrame(
+    int n, int activationReason, void **instanceData, void **frameData,
+    VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) {
+    F2QLimitData *d = (F2QLimitData *) *instanceData;
 
-    if (activationReason == arInitial) {
+    if(activationReason == arInitial) {
         // Request the source frame on the first call
         vsapi->requestFrameFilter(n, d->node, frameCtx);
-    } 
-	else if (activationReason == arAllFramesReady) 
-	{
+    } else if(activationReason == arAllFramesReady) {
         const VSFrameRef *src = vsapi->getFrameFilter(n, d->node, frameCtx);
-        // The reason we query this on a per frame basis is because we want our filter
-        // to accept clips with varying dimensions. If we reject such content using d->vi
-        // would be better.
+        // The reason we query this on a per frame basis is because we want our
+        // filter to accept clips with varying dimensions. If we reject such
+        // content using d->vi would be better.
         const VSFormat *fi = d->vi->format;
         int ht = vsapi->getFrameHeight(src, 0);
         int wd = vsapi->getFrameWidth(src, 0);
         VSFrameRef *dst = vsapi->copyFrame(src, core);
-		
-		// process all of RGB and Y of YUV or Gray
+
+        // process all of RGB and Y of YUV or Gray
         int np = fi->colorFamily == cmRGB ? 3 : 1;
-		int nbits = fi->sampleType == stInteger ? fi->bitsPerSample : 0;
-		int nbytes = fi->bytesPerSample;
-
-		for (int p = 0; p < np; p++)
-		{
-			const uint8_t* srcp = vsapi->getReadPtr(src, p);
-			int dst_stride = vsapi->getStride(dst, p);
-			uint8_t* dstp = vsapi->getWritePtr(dst, p);
-			int pitch = dst_stride / fi->bytesPerSample;
-
-			if (fi->sampleType == stInteger && nbits == 8)
-			{
-				uint8_t max = (1 << nbits) - 1, min = 0;				
-
-				F2QLimitProcess(d, dstp, pitch, ht, wd,  min, max);
-			}
-
-			else if (fi->sampleType == stInteger && nbytes == 2)
-			{
-				uint16_t max = (1 << nbits) - 1, min = 0;
-				uint16_t* dp = (uint16_t*)dstp;
-				F2QLimitProcess(d, dp, pitch, ht, wd,  min, max);
-			}
-
-			else if (fi->sampleType == stFloat)
-			{
-				float max = 1.0, min = 0.0f;
-				float* dp = (float*)dstp;
-				F2QLimitProcess(d, dp, pitch, ht, wd,  min, max);
-			}
-		}
-        
+        int nbits = fi->sampleType == stInteger ? fi->bitsPerSample : 0;
+        int nbytes = fi->bytesPerSample;
+
+        for(int p = 0; p < np; p++) {
+            const uint8_t *srcp = vsapi->getReadPtr(src, p);
+            int dst_stride = vsapi->getStride(dst, p);
+            uint8_t *dstp = vsapi->getWritePtr(dst, p);
+            int pitch = dst_stride / fi->bytesPerSample;
+
+            if(fi->sampleType == stInteger && nbits == 8) {
+                uint8_t max = (1 << nbits) - 1, min = 0;
+
+                F2QLimitProcess(d, dstp, pitch, ht, wd, min, max);
+            }
+
+            else if(fi->sampleType == stInteger && nbytes == 2) {
+                uint16_t max = (1 << nbits) - 1, min = 0;
+                uint16_t *dp = (uint16_t *) dstp;
+                F2QLimitProcess(d, dp, pitch, ht, wd, min, max);
+            }
+
+            else if(fi->sampleType == stFloat) {
+                float max = 1.0, min = 0.0f;
+                float *dp = (float *) dstp;
+                F2QLimitProcess(d, dp, pitch, ht, wd, min, max);
+            }
+        }
 
         // Release the source frame
         vsapi->freeFrame(src);
 
-        // A reference is consumed when it is returned, so saving the dst reference somewhere
-        // and reusing it is not allowed.
+        // A reference is consumed when it is returned, so saving the dst
+        // reference somewhere and reusing it is not allowed.
         return dst;
     }
 
@@ -311,123 +322,132 @@ static const VSFrameRef *VS_CC f2qlimitGetFrame(int n, int activationReason, voi
 }
 //-----------------------------------------------------------------------------------------------------
 // Free all allocated data on filter destruction
-static void VS_CC f2qlimitFree(void *instanceData, VSCore *core, const VSAPI *vsapi) 
-{
-    F2QLimitData *d = (F2QLimitData *)instanceData;
+static void VS_CC f2qlimitFree(void *instanceData, VSCore *core,
+                               const VSAPI *vsapi) {
+    F2QLimitData *d = (F2QLimitData *) instanceData;
     vsapi->freeNode(d->node);
-	d->fftwf_destroy_plan (d->pf);
-	d->fftwf_destroy_plan ( d->pinv);
-	d->fftwf_free(d->inBuf);
-	d->fftwf_free(d->outBuf);
-
-	FreeLibrary(d->hinstLib);
+    d->fftwf_destroy_plan(d->pf);
+    d->fftwf_destroy_plan(d->pinv);
+    d->fftwf_free(d->inBuf);
+    d->fftwf_free(d->outBuf);
+    // Error
+    //	FreeLibrary(d->hinstLib);
+    // Fix
+    if(d->hinstLib != nullptr) {
+#ifdef _WIN32
+        FreeLibrary((HINSTANCE) d->hinstLib);
+#else
+        dlclose(d->hinstLib);
+#endif
+    }
 
     free(d);
 }
 
 //--------------------------------------------------------------------------------------------------------------
-// This function is responsible for validating arguments and creating a new filter
-static void VS_CC f2qlimitCreate(const VSMap *in, VSMap *out, void *userData, VSCore *core, const VSAPI *vsapi)
-{
+// This function is responsible for validating arguments and creating a new
+// filter
+static void VS_CC f2qlimitCreate(const VSMap *in, VSMap *out, void *userData,
+                                 VSCore *core, const VSAPI *vsapi) {
     F2QLimitData d;
     F2QLimitData *data;
     int err;
-	int temp;
-	
+    int temp;
+
     // Get a clip reference from the input arguments. This must be freed later.
     d.node = vsapi->propGetNode(in, "clip", 0, 0);
     d.vi = vsapi->getVideoInfo(d.node);
 
-   
-	if (!isConstantFormat(d.vi) && (d.vi->format->colorFamily != cmRGB 
-						&& d.vi->format->colorFamily != cmYUV 	
-						&& d.vi->format->colorFamily != cmGray))
-	{
-        vsapi->setError(out, "F2QLimit: only constant format RGB YUV or Gray  input supported");
+    if(!isConstantFormat(d.vi) && (d.vi->format->colorFamily != cmRGB &&
+                                   d.vi->format->colorFamily != cmYUV &&
+                                   d.vi->format->colorFamily != cmGray)) {
+        vsapi->setError(
+            out,
+            "F2QLimit: only constant format RGB YUV or Gray  input supported");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    if(d.vi->format->sampleType == stFloat &&
+       d.vi->format->bitsPerSample == 16) {
+        vsapi->setError(out, "F2QLimit: Half float formats not allowed ");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    d.grid = int64ToIntS(vsapi->propGetInt(in, "grid", 0, &err));
+    if(err)
+        d.grid = 10;
+    else if(d.grid < 1 || d.grid > 50) {
+        vsapi->setError(
+            out, "F2QLimit: grid specifies search area and be 1 to 50 only");
+        vsapi->freeNode(d.node);
+        return;
+    }
+    d.inner = int64ToIntS(vsapi->propGetInt(in, "inner", 0, &err));
+    if(err)
+        d.inner = d.grid / 10;
+    else if(d.inner < 0 || d.inner > d.grid) {
+        vsapi->setError(
+            out,
+            "F2QLimit: inner area of limiting can be 0 to value of grid only");
+        vsapi->freeNode(d.node);
+        return;
+    }
+    d.warn = int64ToIntS(vsapi->propGetInt(in, "warn", 0, &err));
+    if(err)
+        d.warn = 1;
+    else if(d.warn < 0 || d.warn > 2) {
+        vsapi->setError(out, "F2QLimit: warn level can be 0 or 1 or 2 only");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    d.npoints = vsapi->propNumElements(in, "fspec");
+
+    if(d.npoints < 3 || (d.npoints % 3) != 0 || d.npoints > 60) {
+        vsapi->setError(
+            out,
+            "F2QLimit: fspec at least one and upto 20 filter specifications be "
+            "given. Each filter is specified as a set of 5 integer values.");
         vsapi->freeNode(d.node);
         return;
     }
-	
-	if (d.vi->format->sampleType == stFloat && d.vi->format->bitsPerSample == 16)
-	{
-		vsapi->setError(out, "F2QLimit: Half float formats not allowed ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-	
-		
-	d.grid = int64ToIntS(vsapi->propGetInt(in, "grid", 0, &err));
-	if (err)
-		d.grid = 10;
-	else if (d.grid < 1 || d.grid > 50)
-	{
-		vsapi->setError(out, "F2QLimit: grid specifies search area and be 1 to 50 only");
-		vsapi->freeNode(d.node);
-		return;
-	}
-	d.inner = int64ToIntS(vsapi->propGetInt(in, "inner", 0, &err));
-	if (err)
-		d.inner = d.grid / 10;
-	else if (d.inner < 0 || d.inner > d.grid )
-	{
-		vsapi->setError(out, "F2QLimit: inner area of limiting can be 0 to value of grid only");
-		vsapi->freeNode(d.node);
-		return;
-	}
-	d.warn = int64ToIntS(vsapi->propGetInt(in, "warn", 0, &err));
-	if (err)
-		d.warn = 1;
-	else if (d.warn < 0 || d.warn > 2)
-	{
-		vsapi->setError(out, "F2QLimit: warn level can be 0 or 1 or 2 only");
-		vsapi->freeNode(d.node);
-		return;
-	}
-
-	d.npoints = vsapi->propNumElements(in, "fspec");
-
-	if(d.npoints < 3 || (d.npoints % 3 ) != 0 || d.npoints > 60)
-	{		
-		vsapi->setError(out, "F2QLimit: fspec at least one and upto 20 filter specifications be given. Each filter is specified as a set of 5 integer values.");
-		vsapi->freeNode(d.node);
-		return;
-	}
-
-	for ( int i = 0; i < d.npoints; i ++)
-		d.fspec[i] = int64ToIntS(vsapi->propGetInt(in, "fspec", i, 0));
-	
-	for (int i = 0; i < d.npoints; i += 3)
-	{		
-		//int wfreq = d.fspec[i];
-		//int hfreq = d.fspec[i + 1];
-		//int limit = d.fspec[i + 2];
-
-		if (d.fspec[i] < 0 || d.fspec[i] >= NYQUIST / 2 )
-		{
-			vsapi->setError(out, "F2QLimit:the first number horizontal freq of each filter must  be from 0 to nyquist / 2 here  250");
-			vsapi->freeNode(d.node);
-			return;
-		}
-		if (d.fspec[i + 1] < - NYQUIST / 2 || d.fspec[i + 1] >= NYQUIST /2)
-		{
-			vsapi->setError(out, "F2QLimit:the second number vertical freq of each filter must be -nyqiust/2 to nyquist / 2 here -250 to 250");
-			vsapi->freeNode(d.node);
-			return;
-		}
-
-		if (d.fspec[i + 2] < 0 || d.fspec[i + 2] > 99)
-		{
-			vsapi->setError(out, "F2QLimit:the third number  specifying freq1 of each filter must be between 0 and %d");
-			vsapi->freeNode(d.node);
-			return;
-
-		}
-	}		
-	
+
+    for(int i = 0; i < d.npoints; i++)
+        d.fspec[i] = int64ToIntS(vsapi->propGetInt(in, "fspec", i, 0));
+
+    for(int i = 0; i < d.npoints; i += 3) {
+        // int wfreq = d.fspec[i];
+        // int hfreq = d.fspec[i + 1];
+        // int limit = d.fspec[i + 2];
+
+        if(d.fspec[i] < 0 || d.fspec[i] >= NYQUIST / 2) {
+            vsapi->setError(out,
+                            "F2QLimit:the first number horizontal freq of each "
+                            "filter must  be from 0 to nyquist / 2 here  250");
+            vsapi->freeNode(d.node);
+            return;
+        }
+        if(d.fspec[i + 1] < -NYQUIST / 2 || d.fspec[i + 1] >= NYQUIST / 2) {
+            vsapi->setError(
+                out, "F2QLimit:the second number vertical freq of each filter "
+                     "must be -nyqiust/2 to nyquist / 2 here -250 to 250");
+            vsapi->freeNode(d.node);
+            return;
+        }
+
+        if(d.fspec[i + 2] < 0 || d.fspec[i + 2] > 99) {
+            vsapi->setError(out, "F2QLimit:the third number  specifying freq1 "
+                                 "of each filter must be between 0 and %d");
+            vsapi->freeNode(d.node);
+            return;
+        }
+    }
+
     data = (F2QLimitData *) malloc(sizeof(d));
     *data = d;
-	
-	vsapi->createFilter(in, out, "F2QLimit", f2qlimitInit, f2qlimitGetFrame, f2qlimitFree, fmParallelRequests, 0, data, core);
-}
-
 
+    vsapi->createFilter(in, out, "F2QLimit", f2qlimitInit, f2qlimitGetFrame,
+                        f2qlimitFree, fmParallelRequests, 0, data, core);
+}
diff --git a/F2Quiver.cpp b/F2Quiver.cpp
index 946c095..86690e0 100644
--- a/F2Quiver.cpp
+++ b/F2Quiver.cpp
@@ -1,17 +1,15 @@
-// This file contains a  f2quiver filter which transforms frame into 2D freq domain through fft
-// frequency filters included are low cut, high cut, band pass, band stop and noth. 
-// 2D domain symmetry of circular, vertical, horizntal or point can be opted,
-// The frequency at which these are positioned are to be specified. 
-// Depending on the strength of filter Gauss or butterworth filters are designed. 
-// upto 16 such filters can be specified simultaneously. All will be cascaded
-// In the test mode the Frequency spectrum is displayed in left part of frame. 
-// On the right Designed filters are displayed.
-// the basics of the filter api.
-// This file may make more sense when
-// read from the bottom and up.
+// This file contains a  f2quiver filter which transforms frame into 2D freq
+// domain through fft frequency filters included are low cut, high cut, band
+// pass, band stop and noth. 2D domain symmetry of circular, vertical, horizntal
+// or point can be opted, The frequency at which these are positioned are to be
+// specified. Depending on the strength of filter Gauss or butterworth filters
+// are designed. upto 16 such filters can be specified simultaneously. All will
+// be cascaded In the test mode the Frequency spectrum is displayed in left part
+// of frame. On the right Designed filters are displayed. the basics of the
+// filter api. This file may make more sense when read from the bottom and up.
 /*
-This plugin needs any one of libfftw3f-3.dll, FFTW3 dll, fftw.dll to reside in path
-(may be windows\system32 folder)
+This plugin needs any one of libfftw3f-3.dll, FFTW3 dll, fftw.dll to reside in
+path (may be windows\system32 folder)
 
 Author V.C.Mohan.
 Jun 2015, 18 May 2021
@@ -33,537 +31,552 @@ see <http://www.gnu.org/licenses/>.
 
 ********************************************************************************/
 /*
-#include <stdlib.h>
-#include "VapourSynth.h"
+#include "F2QFilters.h"
+#include "F2QuiverSpectralDisplay.h"
+#include "Factorize.cpp"
 #include "VSHelper.h"
+#include "VapourSynth.h"
+#include "fftwlite.h"
+#include "windows.h"
 #include  <math.h>
+#include <stdlib.h>
 #include <vector>
-#include "windows.h"
-#include "fftwlite.h"
-#include "Factorize.cpp"
-#include "F2QFilters.h"
-#include "F2QuiverSpectralDisplay.h"
 */
 typedef struct {
-		VSNodeRef *node;
-		const VSVideoInfo *vi;
-		
-		bool  	test;		// is this a test?
-		float 	gamma;		// for spectrum scaling
-		bool 	morph;		// is homomorphic process required
-		int		Fspec[60];
-		int 	npoints;		// number of filters or for custo pairs specified		
-		float	*logLUT;		// log look up table for morph
-		bool	ham;		// flag for hamming the filter 
-		int		frad;		// radius of filter in image domain
-
-		// late binding of fft dll
+    VSNodeRef *node;
+    const VSVideoInfo *vi;
+
+    bool test;   // is this a test?
+    float gamma; // for spectrum scaling
+    bool morph;  // is homomorphic process required
+    int Fspec[60];
+    int npoints;   // number of filters or for custo pairs specified
+    float *logLUT; // log look up table for morph
+    bool ham;      // flag for hamming the filter
+    int frad;      // radius of filter in image domain
+
+    // late binding of fft dll
 #include "fftLateBindingClassParams.cpp"
-		float* inBuf;
-		fftwf_complex* outBuf;
-		float  * FreqFilter;	//  freq response of filter and powerspectrum buffer pointers
-		fftwf_plan 	pf, pinv;		// fftwf creates a plan of process. pointer to it	
-		int		hbest, wbest, frqwidth;	// best dimension for speed
-
+    float *inBuf;
+    fftwf_complex *outBuf;
+    float *FreqFilter;   //  freq response of filter and powerspectrum buffer
+                         //  pointers
+    fftwf_plan pf, pinv; // fftwf creates a plan of process. pointer to it
+    int hbest, wbest, frqwidth; // best dimension for speed
 
-
-
-	
 } F2QuiverData;
 //------------------------------------------------------------------------------
 template <typename finc>
-void displaySpectraAndFilters2D(F2QuiverData* d, float* inBuf, fftwf_complex* outBuf, const finc* sp, finc * dp,
-								int pitch, int ht, int wd, finc Grey, finc max);
+void displaySpectraAndFilters2D(F2QuiverData *d, float *inBuf,
+                                fftwf_complex *outBuf, const finc *sp, finc *dp,
+                                int pitch, int ht, int wd, finc Grey, finc max);
 template <typename finc>
-void getFilteredOutput2D(F2QuiverData* d, float* inBuf, fftwf_complex* outBuf,
-	const finc* sp, finc* dp, const int pitch, const int ht, const int wd, finc min, finc max);
+void getFilteredOutput2D(F2QuiverData *d, float *inBuf, fftwf_complex *outBuf,
+                         const finc *sp, finc *dp, const int pitch,
+                         const int ht, const int wd, finc min, finc max);
 
-void designFilter2D(int* FSpec, int npts, float* filter, int ht, int wd);
+void designFilter2D(int *FSpec, int npts, float *filter, int ht, int wd);
 
 //====================================================================================
 
-// This function is called immediately after vsapi->createFilter(). This is the only place where the video
-// properties may be set. In this case we simply use the same as the input clip. You may pass an array
-// of VSVideoInfo if the filter has more than one output, like rgb+alpha as two separate clips.
-static void VS_CC f2quiverInit(VSMap *in, VSMap *out, void **instanceData, VSNode *node, VSCore *core, const VSAPI *vsapi)
-{
-    F2QuiverData *d = (F2QuiverData *) * instanceData;
+// This function is called immediately after vsapi->createFilter(). This is the
+// only place where the video properties may be set. In this case we simply use
+// the same as the input clip. You may pass an array of VSVideoInfo if the
+// filter has more than one output, like rgb+alpha as two separate clips.
+static void VS_CC f2quiverInit(VSMap *in, VSMap *out, void **instanceData,
+                               VSNode *node, VSCore *core, const VSAPI *vsapi) {
+    F2QuiverData *d = (F2QuiverData *) *instanceData;
     vsapi->setVideoInfo(d->vi, 1, node);
-	
-
-	int * facbuf =  vs_aligned_malloc<int> (sizeof(int) * 64, 32);	//maximum 64 factors, first is factor, second is dividend to be factored. At 
-								// a value of 1 no more factors
-	
-			//	best dimensions for speed
-	// make sure we have even numbers as starting values of width and height
-	int wdEven = ((d->vi->width + 3) >> 2) << 2;
-	int htEven = ((d->vi->height + 3) >> 2) << 2;
-			// As we are not filtering we use nearest to frame frame
-	d->wbest = getBestDim(wdEven + ADDSAFE, facbuf);
-	d->hbest = getBestDim(htEven + ADDSAFE, facbuf);
-
-	vs_aligned_free(facbuf);
-
-	if( d->test)
-	{
-		d->wbest = getBestDim(d->vi->width , facbuf);
-		d->hbest = getBestDim(d->vi->height ,facbuf);
-	}
-	d->frqwidth = (d->wbest / 2) + 1;
-	int f2qsize = d->hbest * d->frqwidth;
+
+    int *facbuf = vs_aligned_malloc<int>(
+        sizeof(int) * 64, 32); // maximum 64 factors, first is factor, second is
+                               // dividend to be factored. At
+                               //  a value of 1 no more factors
+
+    //	best dimensions for speed
+    // make sure we have even numbers as starting values of width and height
+    int wdEven = ((d->vi->width + 3) >> 2) << 2;
+    int htEven = ((d->vi->height + 3) >> 2) << 2;
+    // As we are not filtering we use nearest to frame frame
+    d->wbest = getBestDim(wdEven + ADDSAFE, facbuf);
+    d->hbest = getBestDim(htEven + ADDSAFE, facbuf);
+
+    vs_aligned_free(facbuf);
+
+    if(d->test) {
+        d->wbest = getBestDim(d->vi->width, facbuf);
+        d->hbest = getBestDim(d->vi->height, facbuf);
+    }
+    d->frqwidth = (d->wbest / 2) + 1;
+    int f2qsize = d->hbest * d->frqwidth;
 
 #include "ConstructorCodeForLateBindingfft.cpp"
 
+    if(!ok) {
+        vsapi->setError(out, "vcm.f2quiver: could not load any of the fft dll "
+                             "or get required fnctions");
+        // Error
+        // if (d->hinstLib != NULL)
+        //     FreeLibrary(d->hinstLib);
+        // Fix
+        if(d->hinstLib != NULL) {
+#ifdef _WIN32
+            FreeLibrary((HINSTANCE) d->hinstLib);
+#else
+            if(d->hinstLib)
+                dlclose(d->hinstLib);
+#endif
+        }
+        vsapi->freeNode(d->node);
+        return;
+    }
+
+    // buffers
+    d->inBuf = (float *) d->fftwf_malloc(sizeof(float) * d->wbest * d->hbest);
+
+    d->outBuf = (fftwf_complex *) d->fftwf_malloc(
+        sizeof(fftwf_complex) *
+        f2qsize); //  is only a safeguard not really reqd
+
+    if(d->inBuf == NULL || d->outBuf == NULL) {
+        vsapi->setError(out,
+                        "F2Quiver: unexpectedly buffers not allocated error");
+        vsapi->freeNode(d->node);
+        // Error
+        // FreeLibrary(d->hinstLib);
+        // Fix
+        if(d->hinstLib != nullptr) {
+#ifdef _WIN32
+            FreeLibrary((HINSTANCE) d->hinstLib);
+#else
+            dlclose(d->hinstLib);
+#endif
+        }
+
+        free(d);
+        return;
+    }
+
+    d->pf = d->fftwf_plan_dft_r2c_2d(d->hbest, d->wbest, d->inBuf, d->outBuf,
+                                     FFTW_MEASURE);
+    d->pinv = d->fftwf_plan_dft_c2r_2d(d->hbest, d->wbest, d->outBuf, d->inBuf,
+                                       FFTW_MEASURE);
+
+    if(d->pf == NULL || d->pinv == NULL) {
+        vsapi->setError(out, "F2Quiver: unexpected  fft plans  error");
+        vsapi->freeNode(d->node);
+        d->fftwf_free(d->inBuf);
+        d->fftwf_free(d->outBuf);
+        // Error
+        // FreeLibrary(d->hinstLib);
+        // Fix
+        if(d->hinstLib != nullptr) {
+#ifdef _WIN32
+            FreeLibrary((HINSTANCE) d->hinstLib);
+#else
+            dlclose(d->hinstLib);
+#endif
+        }
+
+        free(d);
+        return;
+    }
+    int nbits = d->vi->format->bitsPerSample;
+
+    d->logLUT = NULL;
+    if(d->morph && nbits <= 12) {
+        // only up to 12 bits input this buffer is used
+        int nval = 1 << nbits;
+
+        d->logLUT = vs_aligned_malloc<float>(sizeof(float) * nval, 32);
+
+        for(int i = 0; i < nval; i++) {
+            d->logLUT[i] =
+                log((float) i +
+                    1.0f); // 1 added to prevent log 0. In output reduce by 2.0
+        }
+    }
+
+    d->FreqFilter = vs_aligned_malloc<float>(sizeof(float) * f2qsize, 32);
 
-	if (!ok)
-	{
-		vsapi->setError(out, "vcm.f2quiver: could not load any of the fft dll or get required fnctions");
-		if (d->hinstLib != NULL)
-			FreeLibrary(d->hinstLib);
-		vsapi->freeNode(d->node);
-		return;
-	}
-	// buffers 
-	d->inBuf = (float*)d->fftwf_malloc(sizeof(float) * d->wbest * d->hbest);
-	
-	d->outBuf = (fftwf_complex*)d->fftwf_malloc (sizeof(fftwf_complex) * f2qsize);//  is only a safeguard not really reqd
-	
-
-	if(d->inBuf == NULL || d->outBuf == NULL )
-	{
-		vsapi->setError(out, "F2Quiver: unexpectedly buffers not allocated error");
-		vsapi->freeNode(d->node);
-		FreeLibrary(d->hinstLib);
-		free(d);
-		return;
-	}
-	
-
-	d->pf = d->fftwf_plan_dft_r2c_2d(d->hbest, d->wbest, d->inBuf, d->outBuf, FFTW_MEASURE );
-	d->pinv = d->fftwf_plan_dft_c2r_2d(d->hbest, d->wbest, d->outBuf, d->inBuf, FFTW_MEASURE );
-
-	if(  d->pf == NULL || d->pinv == NULL)
-	{
-		vsapi->setError(out, "F2Quiver: unexpected  fft plans  error");
-		vsapi->freeNode(d->node);
-		d->fftwf_free(d->inBuf);
-		d->fftwf_free(d->outBuf);
-		FreeLibrary(d->hinstLib);
-		free(d);
-		return;
-	}
-	int nbits = d->vi->format->bitsPerSample;
-
-	d->logLUT = NULL;
-	if(d->morph && nbits <= 12 )
-	{
-		// only up to 12 bits input this buffer is used
-		int nval = 1 << nbits;
-
-		d->logLUT = vs_aligned_malloc <float>( sizeof(float) * nval, 32);
-
-		for (int i = 0; i < nval; i ++)
-		{
-			d->logLUT[i] = log((float)i + 1.0f);	// 1 added to prevent log 0. In output reduce by 2.0
-		}
-	}
-	
-	d->FreqFilter = vs_aligned_malloc <float>(sizeof(float) * f2qsize, 32);
-
-		// initialize 
-	for (int i = 0; i < f2qsize; i ++)
-	{
-		// initialize with value of 1. All cascading filters multiply the value
-		d->FreqFilter[i] = 1.0f;
-	}
-	
-	designFilter2D(d->Fspec, d->npoints, d->FreqFilter, d-> hbest, d->frqwidth );
-
-		// normalize filter
-	float * filt = d->FreqFilter;
-	float fmax = filt[0];
-
-	for(int i = 0; i < f2qsize; i ++)
-	{			
-		if (fmax < filt[i])
-			fmax = filt[i];	
-	}
-
-	float fscale = d->test ? 1.0f / fmax : 1.0f / (fmax * d->wbest * d->hbest); 
-	
-		// normalize for display
-		
-	for ( int i = 0; i < f2qsize; i ++)
-	{
-		
-		filt[i] *= fscale;
-	}
-	if (d->ham)
-	{
+    // initialize
+    for(int i = 0; i < f2qsize; i++) {
+        // initialize with value of 1. All cascading filters multiply the value
+        d->FreqFilter[i] = 1.0f;
+    }
+
+    designFilter2D(d->Fspec, d->npoints, d->FreqFilter, d->hbest, d->frqwidth);
+
+    // normalize filter
+    float *filt = d->FreqFilter;
+    float fmax = filt[0];
+
+    for(int i = 0; i < f2qsize; i++) {
+        if(fmax < filt[i])
+            fmax = filt[i];
+    }
+
+    float fscale = d->test ? 1.0f / fmax : 1.0f / (fmax * d->wbest * d->hbest);
+
+    // normalize for display
+
+    for(int i = 0; i < f2qsize; i++) {
+
+        filt[i] *= fscale;
+    }
+    if(d->ham) {
 #include "hammingCodeInsert.cpp"
-	}
-	/*if (! d->test)
-	{
-		// the filter was designed with origin at center of frame. We need to reposition it
-		// transform to space domain , remove centering 
-		// we can limit length of filter, at cost of effectiveness. 
-		// Ensure no wrap around convolution takes place
-		// transfer filter to complex buffer. Our filter is zero phase, so imaginary part = 0;
-
-		for ( int i = 0; i < f2qsize; i ++)
-		{
-			d->outBuf[i][0] = d->FreqFilter[i];
-			d->outBuf[i][1] = 0.0;
-		}
-
-		// now inverse fft
-		
-		d->fftwf_execute(d->pinv);
-
-		// remove centering sign
-		float * imageSpace = d->inBuf;
-		int start = 1;
-
-		for ( int h = 0; h < d->hbest; h ++)
-		{
-			int wstart = start;
-			for (int w = 0; w < d->wbest; w += 2)
-			{
-					
-				imageSpace[w] *= wstart;  // getSign(h, w);
-				imageSpace[w + 1] *= wstart;
-				wstart = -wstart;
-			}
-			imageSpace += d->wbest;
-			start = -start;
-		}
-
-		// zero out central part leaving a margin of frad;
-		// = inBuf + d->filterRadius * d->wbest;
-
-		for ( int h = d->filterRadius; h < d->hbest - d->filterRadius; h ++)
-		{
-			for ( int w = d->filterRadius; w < d->wbest - d->filterRadius; w ++)
-			{
-				imageSpace[w] = 0.0;
-			}
-			imageSpace += d->wbest;
-		}
-
-		// now transform (back) to frequency domain		
-		d->fftwf_execute(d->pf);
-
-		fmax = 0.0;
-		for (int i = 0; i < f2qsize; i++)
-		{
-			if (fmax < d->outBuf[i][0])
-				fmax = d->outBuf[i][0];
-				
-		}
-
-		// transfer real part to freq buffer. We also remove scaling of hbest * wbest due to inverse and forward fft
-		fscale = 1.0f / (fmax * d->hbest * d->wbest);
-
-		for( int i = 0; i < f2qsize; i ++)
-		{
-			d->FreqFilter[i] = d->outBuf[i][0] * fscale;
-		}
-			
-	}*/	// not test
+    }
+    /*if (! d->test)
+    {
+        // the filter was designed with origin at center of frame. We need to
+    reposition it
+        // transform to space domain , remove centering
+        // we can limit length of filter, at cost of effectiveness.
+        // Ensure no wrap around convolution takes place
+        // transfer filter to complex buffer. Our filter is zero phase, so
+    imaginary part = 0;
+
+        for ( int i = 0; i < f2qsize; i ++)
+        {
+            d->outBuf[i][0] = d->FreqFilter[i];
+            d->outBuf[i][1] = 0.0;
+        }
+
+        // now inverse fft
+
+        d->fftwf_execute(d->pinv);
+
+        // remove centering sign
+        float * imageSpace = d->inBuf;
+        int start = 1;
+
+        for ( int h = 0; h < d->hbest; h ++)
+        {
+            int wstart = start;
+            for (int w = 0; w < d->wbest; w += 2)
+            {
+
+                imageSpace[w] *= wstart;  // getSign(h, w);
+                imageSpace[w + 1] *= wstart;
+                wstart = -wstart;
+            }
+            imageSpace += d->wbest;
+            start = -start;
+        }
+
+        // zero out central part leaving a margin of frad;
+        // = inBuf + d->filterRadius * d->wbest;
+
+        for ( int h = d->filterRadius; h < d->hbest - d->filterRadius; h ++)
+        {
+            for ( int w = d->filterRadius; w < d->wbest - d->filterRadius; w ++)
+            {
+                imageSpace[w] = 0.0;
+            }
+            imageSpace += d->wbest;
+        }
+
+        // now transform (back) to frequency domain
+        d->fftwf_execute(d->pf);
+
+        fmax = 0.0;
+        for (int i = 0; i < f2qsize; i++)
+        {
+            if (fmax < d->outBuf[i][0])
+                fmax = d->outBuf[i][0];
+
+        }
+
+        // transfer real part to freq buffer. We also remove scaling of hbest *
+    wbest due to inverse and forward fft fscale = 1.0f / (fmax * d->hbest *
+    d->wbest);
+
+        for( int i = 0; i < f2qsize; i ++)
+        {
+            d->FreqFilter[i] = d->outBuf[i][0] * fscale;
+        }
+
+    }*/	// not test
 }
 
 //--------------------------------------------------------------------------
 // butterworth 2D filters
-void designFilter2D( int * spec, int npts,float * freqFilt, int ht, int wd)
-{
-	
-	for ( int i = 0; i < npts; i += 5)
-	{	
-		int symmetry = spec[i]; // 1 circular, 2 horizontal, 3 vertical 4  Fan  through axis 5 point
-		//	int type = spec[i + 1];	// 1 locut, 2 hicut, 3 band pass 4 band stop 5 Notch
-		switch (symmetry)
-		{
-			case 1 : ButterworthCircular2D(freqFilt, spec + i, ht, wd);
-					break;
-			case 2: ButterworthHorizontal2D(freqFilt, spec + i, ht, wd);
-					break;
-			case 3: ButterworthVertical2D(freqFilt, spec + i, ht, wd);
-					break;
-			case 4: FanFilter2D(freqFilt, spec + i, ht, wd);
-					break;
-			case 5: pointNotchFilter2D(freqFilt, spec + i, ht, wd);
-		}					
-	}
+void designFilter2D(int *spec, int npts, float *freqFilt, int ht, int wd) {
+
+    for(int i = 0; i < npts; i += 5) {
+        int symmetry = spec[i]; // 1 circular, 2 horizontal, 3 vertical 4  Fan
+                                // through axis 5 point
+        //	int type = spec[i + 1];	// 1 locut, 2 hicut, 3 band pass 4 band stop
+        //5 Notch
+        switch(symmetry) {
+        case 1: ButterworthCircular2D(freqFilt, spec + i, ht, wd); break;
+        case 2: ButterworthHorizontal2D(freqFilt, spec + i, ht, wd); break;
+        case 3: ButterworthVertical2D(freqFilt, spec + i, ht, wd); break;
+        case 4: FanFilter2D(freqFilt, spec + i, ht, wd); break;
+        case 5: pointNotchFilter2D(freqFilt, spec + i, ht, wd);
+        }
+    }
 }
 //-------------------------------------------------------------------------------------------------
 template <typename finc>
-void displaySpectraAndFilters2D(F2QuiverData * d, float * inBuf, fftwf_complex * outBuf, const finc* sp, finc* dp,
-	int pitch, int ht, int wd, finc Grey, finc max)
-{
-	displayFilter2D(dp + wd / 2, pitch, d->FreqFilter, d->frqwidth, wd / 2, ht, max, d->wbest * d->hbest);
+void displaySpectraAndFilters2D(F2QuiverData *d, float *inBuf,
+                                fftwf_complex *outBuf, const finc *sp, finc *dp,
+                                int pitch, int ht, int wd, finc Grey,
+                                finc max) {
+    displayFilter2D(dp + wd / 2, pitch, d->FreqFilter, d->frqwidth, wd / 2, ht,
+                    max, d->wbest * d->hbest);
 
-	if (d->morph)
+    if(d->morph)
 
-		getHMRealInput2D(inBuf, sp, pitch, ht, wd, d->hbest, d->wbest, true, d->logLUT);
-	else
-		getRealInput2D(inBuf, sp, pitch, ht, wd, d->hbest, d->wbest, true);
+        getHMRealInput2D(inBuf, sp, pitch, ht, wd, d->hbest, d->wbest, true,
+                         d->logLUT);
+    else
+        getRealInput2D(inBuf, sp, pitch, ht, wd, d->hbest, d->wbest, true);
 
-	d->fftwf_execute(d->pf);
+    d->fftwf_execute(d->pf);
 
-	// gets a normalized powerspectrum
-	float* powerSpectrum = inBuf;	// inBuf is available
-	getPowerSpectrum2D(powerSpectrum, outBuf, d->hbest * d->frqwidth);
+    // gets a normalized powerspectrum
+    float *powerSpectrum = inBuf; // inBuf is available
+    getPowerSpectrum2D(powerSpectrum, outBuf, d->hbest * d->frqwidth);
 
-	displayPowerSpectrum2D(dp, pitch, powerSpectrum, wd / 2, ht, d->frqwidth, max, d->gamma);
+    displayPowerSpectrum2D(dp, pitch, powerSpectrum, wd / 2, ht, d->frqwidth,
+                           max, d->gamma);
 
-	// draw scales on powerspectrum
-	drawHorizontalRuler2D(dp, pitch, wd, d->frqwidth, max, NYQUIST);
-	drawVerticalRuler2D(dp, pitch, ht, d->hbest, max, NYQUIST);
+    // draw scales on powerspectrum
+    drawHorizontalRuler2D(dp, pitch, wd, d->frqwidth, max, NYQUIST);
+    drawVerticalRuler2D(dp, pitch, ht, d->hbest, max, NYQUIST);
 
-	// draw scales on filter
-	drawHorizontalRuler2D(dp + wd / 2, pitch, wd, d->frqwidth, Grey, NYQUIST);
-	drawVerticalRuler2D(dp + wd / 2, pitch, ht, d->hbest, Grey, NYQUIST);
+    // draw scales on filter
+    drawHorizontalRuler2D(dp + wd / 2, pitch, wd, d->frqwidth, Grey, NYQUIST);
+    drawVerticalRuler2D(dp + wd / 2, pitch, ht, d->hbest, Grey, NYQUIST);
 }
 //-----------------------------------------------------------------------------------------------
 template <typename finc>
-void getFilteredOutput2D(F2QuiverData* d, float* inBuf, fftwf_complex* outBuf,
-	const finc* sp, finc* dp, const int pitch, const int ht, const int wd, finc min, finc max)
-{
-	if (d->morph)
-		getHMRealInput2D(inBuf, sp, pitch, ht, wd, d->hbest, d->wbest, false, d->logLUT);
-	else
-		getRealInput2D(inBuf, sp, pitch, ht, wd, d->hbest, d->wbest, false);
-
-	d->fftwf_execute(d->pf);
-
-
-	ApplyFilter2D(outBuf, d->FreqFilter, d->hbest, d->frqwidth);
-
-	d->fftwf_execute(d->pinv);
-
-	if (d->morph)
-		getHMRealOutput2D(inBuf, dp, pitch, ht, wd, d->hbest, d->wbest, min, max);
-	else
-		getRealOutput2D(inBuf, dp, pitch, ht, wd, d->hbest, d->wbest, min, max);
-
+void getFilteredOutput2D(F2QuiverData *d, float *inBuf, fftwf_complex *outBuf,
+                         const finc *sp, finc *dp, const int pitch,
+                         const int ht, const int wd, finc min, finc max) {
+    if(d->morph)
+        getHMRealInput2D(inBuf, sp, pitch, ht, wd, d->hbest, d->wbest, false,
+                         d->logLUT);
+    else
+        getRealInput2D(inBuf, sp, pitch, ht, wd, d->hbest, d->wbest, false);
+
+    d->fftwf_execute(d->pf);
+
+    ApplyFilter2D(outBuf, d->FreqFilter, d->hbest, d->frqwidth);
+
+    d->fftwf_execute(d->pinv);
+
+    if(d->morph)
+        getHMRealOutput2D(inBuf, dp, pitch, ht, wd, d->hbest, d->wbest, min,
+                          max);
+    else
+        getRealOutput2D(inBuf, dp, pitch, ht, wd, d->hbest, d->wbest, min, max);
 }
 //--------------------------------------------------------------------------------------------------------------------------
-static const VSFrameRef* VS_CC f2qtestGetFrame(int n, int activationReason, void** instanceData,
-	void** frameData, VSFrameContext* frameCtx, VSCore* core, const VSAPI* vsapi)
-{
-	F2QuiverData* d = (F2QuiverData*)*instanceData;
-
-	if (activationReason == arInitial) {
-		// Request the source frame on the first call
-		vsapi->requestFrameFilter(n, d->node, frameCtx);
-	}
-	else if (activationReason == arAllFramesReady)
-	{
-		const VSFrameRef* src = vsapi->getFrameFilter(n, d->node, frameCtx);
-		// The reason we query this on a per frame basis is because we want our filter
-		// to accept clips with varying dimensions. If we reject such content using d->vi
-		// would be better.
-		const VSFormat* fi = d->vi->format;
-		int ht = vsapi->getFrameHeight(src, 0);
-		int wd = vsapi->getFrameWidth(src, 0);
-		VSFrameRef* dst = vsapi->copyFrame(src, core);
-		// float input
-		int iwidth = d->wbest;
-		int owidth = 2 + d->wbest / 2;
-
-		//float* inBuf = (float*)d->fftwf_malloc(sizeof(float) * iwidth * d->hbest);
-		//fftwf_complex* outBuf = (fftwf_complex*)d->fftwf_malloc(sizeof(fftwf_complex) * owidth * d->hbest);
-		// process Green of RGB or Y of YUV or Grey
-		int plane = fi->colorFamily == cmRGB ? 1 : 0;
-
-		const uint8_t* srcp = vsapi->getReadPtr(src, plane);
-		int src_stride = vsapi->getStride(src, plane);
-		uint8_t* dstp = vsapi->getWritePtr(dst, plane);
-		int pitch = src_stride / fi->bytesPerSample;
-		int nbits = fi->sampleType == stInteger ? fi->bitsPerSample : 0;
-		int nbytes = fi->bytesPerSample;
-		int npl = fi->numPlanes > 3 ? 3 : fi->numPlanes;
-
-		float* powerSpectrum = d->inBuf; // in will be available  // (float *) malloc (sizeof(float) * d->hbest * (d->wbest / 2 + 1) );
-
-		if (fi->sampleType == stInteger && nbits == 8)
-		{
-			uint8_t max = (1 << nbits) - 1;
-			uint8_t Grey = 1 << (nbits - 1);
-			uint8_t min = 0;
-			// display filter on right
-			
-			displaySpectraAndFilters2D(d, d->inBuf, d->outBuf, srcp, dstp,
-				pitch, ht, wd, Grey, max);
-			
-			if (fi->colorFamily != cmRGB)
-			{
-				for (int plane = 1; plane < npl; plane++)
-				{
-
-					uint8_t* dstp = vsapi->getWritePtr(dst, plane);
-					int dst_stride = vsapi->getStride(dst, plane);
-					int ht = vsapi->getFrameHeight(dst, plane);
-					int wd = vsapi->getFrameWidth(dst, plane);
-					int pitch = dst_stride / nbytes;
-
-					// black background 
-
-					fillPlaneWithVal(dstp, pitch, wd, ht, Grey);
-				}
-			}
-		}
-
-		else if (fi->sampleType == stInteger && nbits > 8)
-		{
-			const uint16_t* sp = (const uint16_t*)srcp;
-			uint16_t* dp = (uint16_t*)dstp;
-			uint16_t max = (1 << nbits) - 1;
-			uint16_t Grey = 1 << (nbits - 1);
-			uint16_t min = 0;
-			// display filter on right
-
-			displaySpectraAndFilters2D(d, d->inBuf, d->outBuf, sp, dp,
-				pitch, ht, wd, Grey, max);
-			if (fi->colorFamily != cmRGB)
-			{
-				for (int plane = 1; plane < npl; plane++)
-				{
-
-					uint16_t* dp = (uint16_t*)vsapi->getWritePtr(dst, plane);
-					int dst_stride = vsapi->getStride(dst, plane);
-					int ht = vsapi->getFrameHeight(dst, plane);
-					int wd = vsapi->getFrameWidth(dst, plane);
-					int pitch = dst_stride / nbytes;
-
-					// black background 
-
-					fillPlaneWithVal(dp, pitch, wd, ht, Grey);
-				}
-			}
-
-		}
-
-		else if (fi->sampleType == stFloat)
-		{
-			const float* sp = (const float*)srcp;
-			float* dp = (float*)dstp;
-			float max = 1.0;
-			float Grey = 0.0;
-			float min = 0;
-			// display filter on right
-
-			displaySpectraAndFilters2D(d, d->inBuf, d->outBuf, sp, dp,
-				pitch, ht, wd, Grey, max);
-			if (fi->colorFamily != cmRGB)
-			{
-				for (int plane = 1; plane < npl; plane++)
-				{
-
-					float* dp = (float*)vsapi->getWritePtr(dst, plane);
-					int dst_stride = vsapi->getStride(dst, plane);
-					int ht = vsapi->getFrameHeight(dst, plane);
-					int wd = vsapi->getFrameWidth(dst, plane);
-					int pitch = dst_stride / nbytes;
-
-					// black background 
-
-					fillPlaneWithVal(dp, pitch, wd, ht, Grey);
-				}
-			}
-		}
-
-
-		if (fi->colorFamily == cmRGB)
-		{
-			// copy Green on to Blu and Red planes
-			vs_bitblt(vsapi->getWritePtr(dst, 0), vsapi->getStride(dst, 0),
-				vsapi->getWritePtr(dst, 1), vsapi->getStride(dst, 1),
-				wd * nbytes, ht);
-			vs_bitblt(vsapi->getWritePtr(dst, 2), vsapi->getStride(dst, 2),
-				vsapi->getWritePtr(dst, 1), vsapi->getStride(dst, 1),
-				wd * nbytes, ht);
-		}
-		
-		vsapi->freeFrame(src);
-		return (dst);
-	}
-	return 0;
-}
+static const VSFrameRef *VS_CC f2qtestGetFrame(
+    int n, int activationReason, void **instanceData, void **frameData,
+    VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) {
+    F2QuiverData *d = (F2QuiverData *) *instanceData;
 
+    if(activationReason == arInitial) {
+        // Request the source frame on the first call
+        vsapi->requestFrameFilter(n, d->node, frameCtx);
+    } else if(activationReason == arAllFramesReady) {
+        const VSFrameRef *src = vsapi->getFrameFilter(n, d->node, frameCtx);
+        // The reason we query this on a per frame basis is because we want our
+        // filter to accept clips with varying dimensions. If we reject such
+        // content using d->vi would be better.
+        const VSFormat *fi = d->vi->format;
+        int ht = vsapi->getFrameHeight(src, 0);
+        int wd = vsapi->getFrameWidth(src, 0);
+        VSFrameRef *dst = vsapi->copyFrame(src, core);
+        // float input
+        int iwidth = d->wbest;
+        int owidth = 2 + d->wbest / 2;
+
+        // float* inBuf = (float*)d->fftwf_malloc(sizeof(float) * iwidth *
+        // d->hbest); fftwf_complex* outBuf =
+        // (fftwf_complex*)d->fftwf_malloc(sizeof(fftwf_complex) * owidth *
+        // d->hbest);
+        //  process Green of RGB or Y of YUV or Grey
+        int plane = fi->colorFamily == cmRGB ? 1 : 0;
+
+        const uint8_t *srcp = vsapi->getReadPtr(src, plane);
+        int src_stride = vsapi->getStride(src, plane);
+        uint8_t *dstp = vsapi->getWritePtr(dst, plane);
+        int pitch = src_stride / fi->bytesPerSample;
+        int nbits = fi->sampleType == stInteger ? fi->bitsPerSample : 0;
+        int nbytes = fi->bytesPerSample;
+        int npl = fi->numPlanes > 3 ? 3 : fi->numPlanes;
+
+        float *powerSpectrum =
+            d->inBuf; // in will be available  // (float *) malloc
+                      // (sizeof(float) * d->hbest * (d->wbest / 2 + 1) );
+
+        if(fi->sampleType == stInteger && nbits == 8) {
+            uint8_t max = (1 << nbits) - 1;
+            uint8_t Grey = 1 << (nbits - 1);
+            uint8_t min = 0;
+            // display filter on right
+
+            displaySpectraAndFilters2D(d, d->inBuf, d->outBuf, srcp, dstp,
+                                       pitch, ht, wd, Grey, max);
+
+            if(fi->colorFamily != cmRGB) {
+                for(int plane = 1; plane < npl; plane++) {
+
+                    uint8_t *dstp = vsapi->getWritePtr(dst, plane);
+                    int dst_stride = vsapi->getStride(dst, plane);
+                    int ht = vsapi->getFrameHeight(dst, plane);
+                    int wd = vsapi->getFrameWidth(dst, plane);
+                    int pitch = dst_stride / nbytes;
+
+                    // black background
+
+                    fillPlaneWithVal(dstp, pitch, wd, ht, Grey);
+                }
+            }
+        }
+
+        else if(fi->sampleType == stInteger && nbits > 8) {
+            const uint16_t *sp = (const uint16_t *) srcp;
+            uint16_t *dp = (uint16_t *) dstp;
+            uint16_t max = (1 << nbits) - 1;
+            uint16_t Grey = 1 << (nbits - 1);
+            uint16_t min = 0;
+            // display filter on right
+
+            displaySpectraAndFilters2D(d, d->inBuf, d->outBuf, sp, dp, pitch,
+                                       ht, wd, Grey, max);
+            if(fi->colorFamily != cmRGB) {
+                for(int plane = 1; plane < npl; plane++) {
+
+                    uint16_t *dp = (uint16_t *) vsapi->getWritePtr(dst, plane);
+                    int dst_stride = vsapi->getStride(dst, plane);
+                    int ht = vsapi->getFrameHeight(dst, plane);
+                    int wd = vsapi->getFrameWidth(dst, plane);
+                    int pitch = dst_stride / nbytes;
+
+                    // black background
+
+                    fillPlaneWithVal(dp, pitch, wd, ht, Grey);
+                }
+            }
+
+        }
+
+        else if(fi->sampleType == stFloat) {
+            const float *sp = (const float *) srcp;
+            float *dp = (float *) dstp;
+            float max = 1.0;
+            float Grey = 0.0;
+            float min = 0;
+            // display filter on right
+
+            displaySpectraAndFilters2D(d, d->inBuf, d->outBuf, sp, dp, pitch,
+                                       ht, wd, Grey, max);
+            if(fi->colorFamily != cmRGB) {
+                for(int plane = 1; plane < npl; plane++) {
+
+                    float *dp = (float *) vsapi->getWritePtr(dst, plane);
+                    int dst_stride = vsapi->getStride(dst, plane);
+                    int ht = vsapi->getFrameHeight(dst, plane);
+                    int wd = vsapi->getFrameWidth(dst, plane);
+                    int pitch = dst_stride / nbytes;
+
+                    // black background
+
+                    fillPlaneWithVal(dp, pitch, wd, ht, Grey);
+                }
+            }
+        }
+
+        if(fi->colorFamily == cmRGB) {
+            // copy Green on to Blu and Red planes
+            vs_bitblt(vsapi->getWritePtr(dst, 0), vsapi->getStride(dst, 0),
+                      vsapi->getWritePtr(dst, 1), vsapi->getStride(dst, 1),
+                      wd * nbytes, ht);
+            vs_bitblt(vsapi->getWritePtr(dst, 2), vsapi->getStride(dst, 2),
+                      vsapi->getWritePtr(dst, 1), vsapi->getStride(dst, 1),
+                      wd * nbytes, ht);
+        }
 
+        vsapi->freeFrame(src);
+        return (dst);
+    }
+    return 0;
+}
 
 //---------------------------------------------------------------------------------------------------------------------------
-static const VSFrameRef *VS_CC f2quiverGetFrame(int n, int activationReason, void **instanceData, 
-						void **frameData, VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) 
-{
-    F2QuiverData *d = (F2QuiverData *) * instanceData;
+static const VSFrameRef *VS_CC f2quiverGetFrame(
+    int n, int activationReason, void **instanceData, void **frameData,
+    VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) {
+    F2QuiverData *d = (F2QuiverData *) *instanceData;
 
-    if (activationReason == arInitial) {
+    if(activationReason == arInitial) {
         // Request the source frame on the first call
         vsapi->requestFrameFilter(n, d->node, frameCtx);
-    } 
-	else if (activationReason == arAllFramesReady) 
-	{
+    } else if(activationReason == arAllFramesReady) {
         const VSFrameRef *src = vsapi->getFrameFilter(n, d->node, frameCtx);
-        // The reason we query this on a per frame basis is because we want our filter
-        // to accept clips with varying dimensions. If we reject such content using d->vi
-        // would be better.
+        // The reason we query this on a per frame basis is because we want our
+        // filter to accept clips with varying dimensions. If we reject such
+        // content using d->vi would be better.
         const VSFormat *fi = d->vi->format;
         int ht = vsapi->getFrameHeight(src, 0);
         int wd = vsapi->getFrameWidth(src, 0);
         VSFrameRef *dst = vsapi->copyFrame(src, core);
-		// float input
-		int iwidth = d->wbest;
-		int owidth = 2 + d->wbest / 2;		
-
-		//inBuf = (float*)d->fftwf_malloc (sizeof(float) * iwidth * d->hbest);
-		//outBuf = (fftwf_complex*)d->fftwf_malloc(sizeof(fftwf_complex)* owidth * d->hbest);
-		// process all of RGB and Y of YUV or Gray
+        // float input
+        int iwidth = d->wbest;
+        int owidth = 2 + d->wbest / 2;
+
+        // inBuf = (float*)d->fftwf_malloc (sizeof(float) * iwidth * d->hbest);
+        // outBuf = (fftwf_complex*)d->fftwf_malloc(sizeof(fftwf_complex)*
+        // owidth * d->hbest);
+        //  process all of RGB and Y of YUV or Gray
         int np = fi->colorFamily == cmRGB ? 3 : 1;
-		int nbits = fi->sampleType == stInteger ? fi->bitsPerSample : 0;
-		int nbytes = fi->bytesPerSample;
+        int nbits = fi->sampleType == stInteger ? fi->bitsPerSample : 0;
+        int nbytes = fi->bytesPerSample;
 
-		for (int p = 0; p < np; p++)
-		{
-			const uint8_t* srcp = vsapi->getReadPtr(src, p);
-			int src_stride = vsapi->getStride(src, p);
-			uint8_t* dstp = vsapi->getWritePtr(dst, p);
-			int pitch = src_stride / fi->bytesPerSample;
+        for(int p = 0; p < np; p++) {
+            const uint8_t *srcp = vsapi->getReadPtr(src, p);
+            int src_stride = vsapi->getStride(src, p);
+            uint8_t *dstp = vsapi->getWritePtr(dst, p);
+            int pitch = src_stride / fi->bytesPerSample;
 
-			if (fi->sampleType == stInteger && nbits == 8)
-			{
-				uint8_t max = (1 << nbits) - 1, min = 0;
+            if(fi->sampleType == stInteger && nbits == 8) {
+                uint8_t max = (1 << nbits) - 1, min = 0;
 
-				getFilteredOutput2D(d, d->inBuf, d->outBuf, srcp, dstp, pitch, ht, wd, min, max);
+                getFilteredOutput2D(d, d->inBuf, d->outBuf, srcp, dstp, pitch,
+                                    ht, wd, min, max);
 
-			}
+            }
 
-			else if (fi->sampleType == stInteger && nbytes == 2)
-			{
-				uint16_t max = (1 << nbits) - 1, min = 0;
-				uint16_t* dp = (uint16_t*)dstp;
-				const uint16_t* sp = (const uint16_t*)srcp;
+            else if(fi->sampleType == stInteger && nbytes == 2) {
+                uint16_t max = (1 << nbits) - 1, min = 0;
+                uint16_t *dp = (uint16_t *) dstp;
+                const uint16_t *sp = (const uint16_t *) srcp;
 
-				getFilteredOutput2D(d, d->inBuf, d->outBuf, sp, dp, pitch, ht, wd, min, max);
-			}
+                getFilteredOutput2D(d, d->inBuf, d->outBuf, sp, dp, pitch, ht,
+                                    wd, min, max);
+            }
 
-			else if (fi->sampleType == stFloat)
-			{
-				float max = 1.0, min = 0.0f;
-				float* dp = (float*)dstp;
-				const float* sp = (const float*)srcp;
+            else if(fi->sampleType == stFloat) {
+                float max = 1.0, min = 0.0f;
+                float *dp = (float *) dstp;
+                const float *sp = (const float *) srcp;
 
-				getFilteredOutput2D(d, d->inBuf, d->outBuf, sp, dp, pitch, ht, wd, min, max);
-			}
-		}
-        
+                getFilteredOutput2D(d, d->inBuf, d->outBuf, sp, dp, pitch, ht,
+                                    wd, min, max);
+            }
+        }
 
         // Release the source frame
         vsapi->freeFrame(src);
 
-        // A reference is consumed when it is returned, so saving the dst reference somewhere
-        // and reusing it is not allowed.
+        // A reference is consumed when it is returned, so saving the dst
+        // reference somewhere and reusing it is not allowed.
         return dst;
     }
 
@@ -571,233 +584,235 @@ static const VSFrameRef *VS_CC f2quiverGetFrame(int n, int activationReason, voi
 }
 //-----------------------------------------------------------------------------------------------------
 // Free all allocated data on filter destruction
-static void VS_CC f2quiverFree(void *instanceData, VSCore *core, const VSAPI *vsapi) 
-{
-    F2QuiverData *d = (F2QuiverData *)instanceData;
+static void VS_CC f2quiverFree(void *instanceData, VSCore *core,
+                               const VSAPI *vsapi) {
+    F2QuiverData *d = (F2QuiverData *) instanceData;
     vsapi->freeNode(d->node);
-	if (d->FreqFilter != NULL)
-		vs_aligned_free(d->FreqFilter);
-	if( d->logLUT != NULL)
-		vs_aligned_free(d->logLUT);
-	d->fftwf_destroy_plan (d->pf);
-	d->fftwf_destroy_plan ( d->pinv);
-	d->fftwf_free(d->inBuf);
-	d->fftwf_free(d->outBuf);
-
-	FreeLibrary(d->hinstLib);
+    if(d->FreqFilter != NULL)
+        vs_aligned_free(d->FreqFilter);
+    if(d->logLUT != NULL)
+        vs_aligned_free(d->logLUT);
+    d->fftwf_destroy_plan(d->pf);
+    d->fftwf_destroy_plan(d->pinv);
+    d->fftwf_free(d->inBuf);
+    d->fftwf_free(d->outBuf);
+
+    // Error
+    // FreeLibrary(d->hinstLib);
+    // Fix
+    if(d->hinstLib != nullptr) {
+#ifdef _WIN32
+        FreeLibrary((HINSTANCE) d->hinstLib);
+#else
+        dlclose(d->hinstLib);
+#endif
+    }
 
     free(d);
 }
 
 //--------------------------------------------------------------------------------------------------------------
-// This function is responsible for validating arguments and creating a new filter
-static void VS_CC f2quiverCreate(const VSMap *in, VSMap *out, void *userData, VSCore *core, const VSAPI *vsapi)
-{
+// This function is responsible for validating arguments and creating a new
+// filter
+static void VS_CC f2quiverCreate(const VSMap *in, VSMap *out, void *userData,
+                                 VSCore *core, const VSAPI *vsapi) {
     F2QuiverData d;
     F2QuiverData *data;
     int err;
-	int temp;
-	
+    int temp;
+
     // Get a clip reference from the input arguments. This must be freed later.
     d.node = vsapi->propGetNode(in, "clip", 0, 0);
     d.vi = vsapi->getVideoInfo(d.node);
 
-   
-	if (!isConstantFormat(d.vi) && (d.vi->format->colorFamily != cmRGB 
-						&& d.vi->format->colorFamily != cmYUV 	
-						&& d.vi->format->colorFamily != cmGray))
-	{
-        vsapi->setError(out, "F2Quiver: only constant format RGB YUV or Gray  input supported");
+    if(!isConstantFormat(d.vi) && (d.vi->format->colorFamily != cmRGB &&
+                                   d.vi->format->colorFamily != cmYUV &&
+                                   d.vi->format->colorFamily != cmGray)) {
+        vsapi->setError(
+            out,
+            "F2Quiver: only constant format RGB YUV or Gray  input supported");
         vsapi->freeNode(d.node);
         return;
     }
-	
-	if (d.vi->format->sampleType == stFloat && d.vi->format->bitsPerSample == 16)
-	{
-		vsapi->setError(out, "F2Quiver: Half float formats not allowed ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-	temp = !!vsapi->propGetInt(in, "ham", 0, &err);
-	if (err)
-		d.ham = false;
-	else
-		d.ham = temp == 0 ? false : true;
-	if (d.ham)
-	{
-		int maxfrad = (d.vi->height > d.vi->width ? d.vi->height : d.vi->width);
-		temp = vsapi->propGetInt(in, "frad", 0, &err);
-		if (err)
-			temp = 32;
-		else
-		{
-			if (temp < 10 || temp > 50)
-			{
-				vsapi->setError(out, "F2Quiver: frad being %age of min dimension be 10 to 50 only");
-				vsapi->freeNode(d.node);
-				return;
-			}
-		}
-		d.frad = (maxfrad * temp) / 100;
-	}
-
-	temp = !!vsapi->propGetInt(in, "test", 0, &err);
-	if(err)
-		d.test = false;
-	else
-		d.test = temp == 0 ? false: true;
-	
-
-	d.npoints = vsapi->propNumElements(in, "fspec");
-
-	if(d.npoints < 5 || (d.npoints % 5 ) != 0 || d.npoints > 60)
-	{
-		
-		vsapi->setError(out, "F2Quiver: fspec at least one and upto 12 filter specifications be given. Each filter is specified as a set of 5 integer values.");
-		vsapi->freeNode(d.node);
-		return;
-	}
-
-	for ( int i = 0; i < d.npoints; i ++)
-		d.Fspec[i] = vsapi->propGetInt(in, "fspec", i, 0);
-	
-	for ( int i = 0; i < d.npoints; i += 5)
-	{
-		int nfilt = i / 5 + 1;
-		int sym = d.Fspec[i];
-		int type = d.Fspec[i + 1];
-		int frq1 = d.Fspec[i + 2];
-		int frq2 = d.Fspec[i + 3];
-		int fan1 = d.Fspec[i + 2];
-		int fan2 = d.Fspec[i + 3];
-		int deg = d.Fspec[i + 4];
-
-		if (sym < 1 || sym > 5)
-		{
-		
-			
-			vsapi->setError(out, "F2Quiver:the first number specifying symmetry of each filter must  be from 1 to 5");
-			vsapi->freeNode(d.node);
-			return;
-		}
-		if (type < 1 || type > 5)
-		{			
-			vsapi->setError(out, "F2Quiver:the second number specifying type of each filter must be from 1 to 5");
-			vsapi->freeNode(d.node);
-			return;
-		}
-
-		if (sym < 4 && (type < 3 || type == 5))	// locut, high cut or notch
-		{
-			if (frq1 < 0 || frq1 >= NYQUIST / 2)
-			{
-				
-				vsapi->setError(out, "F2Quiver:the third number  specifying freq1 of each filter must be between 0 and %d");
-				vsapi->freeNode(d.node);
-				return;
-			}
-		}
-		else if (sym < 4 && type < 5)	// band pass, band reject
-		{
-			if (frq1 < 0 || frq2 > NYQUIST / 2 || frq2 <= frq1)
-			{
-				
-				vsapi->setError(out, "F2Quiver:for  symetry 4 and type 5 filter 3rd value freq1 must be positive and less than the 4th value freq2.");
-				vsapi->freeNode(d.node);
-				return;
-			}
-		}
-		else if (sym == 4)	// fan filter
-		{
-			if (type == 5 || type < 3)	// only one angle used
-			{
-				if (fan1 < 1 || fan1 > 179 || (fan1 > 89 && fan1 < 91))
-				{
-					vsapi->setError(out, "F2Quiver:for the fan filter the third number specifying angle1 must be between 1 and 89 or 91 to 179.");
-					vsapi->freeNode(d.node);
-					return;
-				}
-			}
-			else
-			{
-				// band pass or reject
-				if (fan1 < 1 || fan1 > 178 || (fan1 > 88 && fan1 < 91))
-				{
-					vsapi->setError(out, "F2Quiver:for the fan filter the angle1 must be between 1 and 88 or 91 and 178");
-					vsapi->freeNode(d.node);	
-					return;
-				}
-				if (fan2 <= fan1 || (fan1 < 89 && fan2 > 89) || fan2 > 179)
-				{
-					vsapi->setError(out, "F2Quiver:for the fan filter the third number specifying angle1 must be between 1 and 88 or 91 to 178.");
-					vsapi->freeNode(d.node);
-					return;
-				}
-			}
-		}
-
-		else if (sym == 5)
-		{
-			if (frq1 < -NYQUIST / 2 || frq1 > NYQUIST / 2 || frq2 < -NYQUIST / 2 || frq2 > NYQUIST / 2)
-			{
-				vsapi->setError(out, "F2Quiver:for the filterof symetry 5, the xfreq  and yfreq must be within + or - 250");
-				vsapi->freeNode(d.node);
-				return;
-			}
-		}
-
-		if (deg < 1 || deg > 24)
-		{			
-			vsapi->setError(out, "F2Quiver: the fifth value of each filter  must be from 1 to 24 only.");
-			vsapi->freeNode(d.node);
-			return;
-		}
-	}
-
-	temp = vsapi->propGetInt(in, "morph", 0, &err);
-
-	if(err)
-	{ 
-		d.morph = false;
-	}
-	else
-	{
-		if ( temp < 0 || temp > 1)
-		{
-			vsapi->setError(out, "F2Quiver: hm must be  either 0 or 1");
-			vsapi->freeNode(d.node);
-			return;
-		}
-
-		d.morph = temp == 0 ? false: true;
-	}
-
-	if( d.test)
-	{
-		d.gamma = vsapi->propGetFloat(in, "gamma", 0, &err);
-		if(err)
-			d.gamma = 0.05;
-		else
-		{
-			if ( d.gamma < 1e-5 || d.gamma > 5.0)
-			{
-				vsapi->setError(out, "F2Quiver: gamma must be non zero +ve and less than 5.0");
-				vsapi->freeNode(d.node);
-				return;
-			}
-
-		}
-	}
-
-	
-	
-	
+
+    if(d.vi->format->sampleType == stFloat &&
+       d.vi->format->bitsPerSample == 16) {
+        vsapi->setError(out, "F2Quiver: Half float formats not allowed ");
+        vsapi->freeNode(d.node);
+        return;
+    }
+    temp = !!vsapi->propGetInt(in, "ham", 0, &err);
+    if(err)
+        d.ham = false;
+    else
+        d.ham = temp == 0 ? false : true;
+    if(d.ham) {
+        int maxfrad = (d.vi->height > d.vi->width ? d.vi->height : d.vi->width);
+        temp = vsapi->propGetInt(in, "frad", 0, &err);
+        if(err)
+            temp = 32;
+        else {
+            if(temp < 10 || temp > 50) {
+                vsapi->setError(out, "F2Quiver: frad being %age of min "
+                                     "dimension be 10 to 50 only");
+                vsapi->freeNode(d.node);
+                return;
+            }
+        }
+        d.frad = (maxfrad * temp) / 100;
+    }
+
+    temp = !!vsapi->propGetInt(in, "test", 0, &err);
+    if(err)
+        d.test = false;
+    else
+        d.test = temp == 0 ? false : true;
+
+    d.npoints = vsapi->propNumElements(in, "fspec");
+
+    if(d.npoints < 5 || (d.npoints % 5) != 0 || d.npoints > 60) {
+
+        vsapi->setError(
+            out,
+            "F2Quiver: fspec at least one and upto 12 filter specifications be "
+            "given. Each filter is specified as a set of 5 integer values.");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    for(int i = 0; i < d.npoints; i++)
+        d.Fspec[i] = vsapi->propGetInt(in, "fspec", i, 0);
+
+    for(int i = 0; i < d.npoints; i += 5) {
+        int nfilt = i / 5 + 1;
+        int sym = d.Fspec[i];
+        int type = d.Fspec[i + 1];
+        int frq1 = d.Fspec[i + 2];
+        int frq2 = d.Fspec[i + 3];
+        int fan1 = d.Fspec[i + 2];
+        int fan2 = d.Fspec[i + 3];
+        int deg = d.Fspec[i + 4];
+
+        if(sym < 1 || sym > 5) {
+
+            vsapi->setError(out,
+                            "F2Quiver:the first number specifying symmetry of "
+                            "each filter must  be from 1 to 5");
+            vsapi->freeNode(d.node);
+            return;
+        }
+        if(type < 1 || type > 5) {
+            vsapi->setError(out, "F2Quiver:the second number specifying type "
+                                 "of each filter must be from 1 to 5");
+            vsapi->freeNode(d.node);
+            return;
+        }
+
+        if(sym < 4 && (type < 3 || type == 5)) // locut, high cut or notch
+        {
+            if(frq1 < 0 || frq1 >= NYQUIST / 2) {
+
+                vsapi->setError(out,
+                                "F2Quiver:the third number  specifying freq1 "
+                                "of each filter must be between 0 and %d");
+                vsapi->freeNode(d.node);
+                return;
+            }
+        } else if(sym < 4 && type < 5) // band pass, band reject
+        {
+            if(frq1 < 0 || frq2 > NYQUIST / 2 || frq2 <= frq1) {
+
+                vsapi->setError(
+                    out,
+                    "F2Quiver:for  symetry 4 and type 5 filter 3rd value freq1 "
+                    "must be positive and less than the 4th value freq2.");
+                vsapi->freeNode(d.node);
+                return;
+            }
+        } else if(sym == 4) // fan filter
+        {
+            if(type == 5 || type < 3) // only one angle used
+            {
+                if(fan1 < 1 || fan1 > 179 || (fan1 > 89 && fan1 < 91)) {
+                    vsapi->setError(out, "F2Quiver:for the fan filter the "
+                                         "third number specifying angle1 must "
+                                         "be between 1 and 89 or 91 to 179.");
+                    vsapi->freeNode(d.node);
+                    return;
+                }
+            } else {
+                // band pass or reject
+                if(fan1 < 1 || fan1 > 178 || (fan1 > 88 && fan1 < 91)) {
+                    vsapi->setError(out,
+                                    "F2Quiver:for the fan filter the angle1 "
+                                    "must be between 1 and 88 or 91 and 178");
+                    vsapi->freeNode(d.node);
+                    return;
+                }
+                if(fan2 <= fan1 || (fan1 < 89 && fan2 > 89) || fan2 > 179) {
+                    vsapi->setError(out, "F2Quiver:for the fan filter the "
+                                         "third number specifying angle1 must "
+                                         "be between 1 and 88 or 91 to 178.");
+                    vsapi->freeNode(d.node);
+                    return;
+                }
+            }
+        }
+
+        else if(sym == 5) {
+            if(frq1 < -NYQUIST / 2 || frq1 > NYQUIST / 2 ||
+               frq2 < -NYQUIST / 2 || frq2 > NYQUIST / 2) {
+                vsapi->setError(out,
+                                "F2Quiver:for the filterof symetry 5, the "
+                                "xfreq  and yfreq must be within + or - 250");
+                vsapi->freeNode(d.node);
+                return;
+            }
+        }
+
+        if(deg < 1 || deg > 24) {
+            vsapi->setError(out, "F2Quiver: the fifth value of each filter  "
+                                 "must be from 1 to 24 only.");
+            vsapi->freeNode(d.node);
+            return;
+        }
+    }
+
+    temp = vsapi->propGetInt(in, "morph", 0, &err);
+
+    if(err) {
+        d.morph = false;
+    } else {
+        if(temp < 0 || temp > 1) {
+            vsapi->setError(out, "F2Quiver: hm must be  either 0 or 1");
+            vsapi->freeNode(d.node);
+            return;
+        }
+
+        d.morph = temp == 0 ? false : true;
+    }
+
+    if(d.test) {
+        d.gamma = vsapi->propGetFloat(in, "gamma", 0, &err);
+        if(err)
+            d.gamma = 0.05;
+        else {
+            if(d.gamma < 1e-5 || d.gamma > 5.0) {
+                vsapi->setError(
+                    out,
+                    "F2Quiver: gamma must be non zero +ve and less than 5.0");
+                vsapi->freeNode(d.node);
+                return;
+            }
+        }
+    }
+
     data = (F2QuiverData *) malloc(sizeof(d));
     *data = d;
-	if (d.test)
-		vsapi->createFilter(in, out, "F2Quiver", f2quiverInit, f2qtestGetFrame, f2quiverFree, fmParallelRequests, 0, data, core);
-	else
-		vsapi->createFilter(in, out, "F2Quiver", f2quiverInit, f2quiverGetFrame, f2quiverFree, fmParallelRequests, 0, data, core);
+    if(d.test)
+        vsapi->createFilter(in, out, "F2Quiver", f2quiverInit, f2qtestGetFrame,
+                            f2quiverFree, fmParallelRequests, 0, data, core);
+    else
+        vsapi->createFilter(in, out, "F2Quiver", f2quiverInit, f2quiverGetFrame,
+                            f2quiverFree, fmParallelRequests, 0, data, core);
 }
-
-
diff --git a/F2QuiverFilters.h b/F2QuiverFilters.h
index 540f8c4..8457cba 100644
--- a/F2QuiverFilters.h
+++ b/F2QuiverFilters.h
@@ -5,645 +5,596 @@
 // Butterworth filter functions required by F2Quiver of FFTQuiver plugin
 //--------------------------------------------------------------------------------
 // declarations
-	void ButterworthCircular2D(float *filt, int * fspec, int ht,int wd);
-	void ButterworthHorizontal2D(float *filt, int * fspec, int ht,int wd);
-	void ButterworthVertical2D(float *filt, int * fspec, int ht,int wd);
-	void pointNotchFilter2D( float * freqFilter, int* spec, int ht, int wd);
-	void FanFilter2D( float * freqFilter, int* spec, int ht, int wd);
-	//------------------------------------------------------------------------------
-
-	// Definitions
+void ButterworthCircular2D(float *filt, int *fspec, int ht, int wd);
+void ButterworthHorizontal2D(float *filt, int *fspec, int ht, int wd);
+void ButterworthVertical2D(float *filt, int *fspec, int ht, int wd);
+void pointNotchFilter2D(float *freqFilter, int *spec, int ht, int wd);
+void FanFilter2D(float *freqFilter, int *spec, int ht, int wd);
+//------------------------------------------------------------------------------
+
+// Definitions
 //-----------------------------------------------------------------------------------
 
 //====================================================================================================================================
-void FanFilter2D( float * freqFilter, int* spec, int ht, int wd)
-{
-	float pi = M_PI;
-	int type = spec[1];
-
-	float theta1 = spec[2] * pi / 180;	// fan angle start
-	float theta2 = spec[3] * pi / 180;	// fan angle end
-
-	int degree = 2 * spec[4];
-
-	if(  spec[2] <= 88  )	// values range from 0 to 180
-	{
-		
-		for(int w = 0; w < wd; w ++)
-		{
-			float hfreq = (w - wd / 2) * tan (theta2) ; // sin(theta2) / cos(theta2);
-			float lfreq = (w - wd / 2) * tan (theta1); //sin(theta1) / cos(theta1);
-			float * flt = freqFilter;
-			float dsqrh = hfreq * hfreq, dsqrl = lfreq * lfreq;
-			
-			for( int h = 0; h < ht; h ++) 
-			{
-				float hsqr = (h - ht / 2) * (h - ht / 2);
-				float mfactor = 1.0;
-				if( (h - ht/2) * (w - wd /2) > 0) 
-				{				
-
-					if ( dsqrh > 0)
-						mfactor *=   1.0 / ( 1.0 + pow ( hsqr /dsqrh, degree) );
-					else  					mfactor = 0;
-					if (hsqr > 0)
-						mfactor *= 1.0 / ( 1.0 + pow( dsqrl / hsqr, degree) ) ;
-				else 
-					mfactor = 0;
-
-				flt[w] *= 1.0 - mfactor;
-				}																								
-
-				flt += wd;
-			} 
-		}
-	}
-
-		else if(  spec[2] > 90  )	// values range from 0 to 180
-		{
-		
-			for(int w = 0; w < wd; w ++)
-			{
-				float lfreq = (w - wd / 2) * tan (pi - theta2) ; // sin(theta2) / cos(theta2);
-				float hfreq = (w - wd / 2) * tan (pi - theta1); //sin(theta1) / cos(theta1);
-				//float * flt = freqFilter;
-				float dsqrh = hfreq * hfreq, dsqrl = lfreq * lfreq;
-				float * flt = freqFilter + (ht - 1 ) * wd;
-
-				for( int h = ht - 1; h >= 0; h --) 
-				{
-					float hsqr = (h - ht / 2) * (h - ht / 2);
-					float mfactor = 1.0;
-					if( (h - ht/2) * (w - wd /2) < 0) 
-					{				
-
-					if ( dsqrh > 0)
-						mfactor *=   1.0 / ( 1.0 + pow ( hsqr /dsqrh, degree) );
-					else
-						mfactor = 0;
-					if (hsqr > 0)
-						mfactor *= 1.0 / ( 1.0 + pow( dsqrl / hsqr, degree) ) ;
-					else 
-						mfactor = 0;
-
-					flt[w] *= 1.0 - mfactor;
-				}																								
-
-				flt -= wd;
-			} 
-		}
-	}	
+void FanFilter2D(float *freqFilter, int *spec, int ht, int wd) {
+    float pi = M_PI;
+    int type = spec[1];
+
+    float theta1 = spec[2] * pi / 180; // fan angle start
+    float theta2 = spec[3] * pi / 180; // fan angle end
+
+    int degree = 2 * spec[4];
+
+    if(spec[2] <= 88) // values range from 0 to 180
+    {
+
+        for(int w = 0; w < wd; w++) {
+            float hfreq =
+                (w - wd / 2) * tan(theta2); // sin(theta2) / cos(theta2);
+            float lfreq =
+                (w - wd / 2) * tan(theta1); // sin(theta1) / cos(theta1);
+            float *flt = freqFilter;
+            float dsqrh = hfreq * hfreq, dsqrl = lfreq * lfreq;
+
+            for(int h = 0; h < ht; h++) {
+                float hsqr = (h - ht / 2) * (h - ht / 2);
+                float mfactor = 1.0;
+                if((h - ht / 2) * (w - wd / 2) > 0) {
+
+                    if(dsqrh > 0)
+                        mfactor *= 1.0 / (1.0 + pow(hsqr / dsqrh, degree));
+                    else
+                        mfactor = 0;
+                    if(hsqr > 0)
+                        mfactor *= 1.0 / (1.0 + pow(dsqrl / hsqr, degree));
+                    else
+                        mfactor = 0;
+
+                    flt[w] *= 1.0 - mfactor;
+                }
+
+                flt += wd;
+            }
+        }
+    }
+
+    else if(spec[2] > 90) // values range from 0 to 180
+    {
+
+        for(int w = 0; w < wd; w++) {
+            float lfreq =
+                (w - wd / 2) * tan(pi - theta2); // sin(theta2) / cos(theta2);
+            float hfreq =
+                (w - wd / 2) * tan(pi - theta1); // sin(theta1) / cos(theta1);
+            // float * flt = freqFilter;
+            float dsqrh = hfreq * hfreq, dsqrl = lfreq * lfreq;
+            float *flt = freqFilter + (ht - 1) * wd;
+
+            for(int h = ht - 1; h >= 0; h--) {
+                float hsqr = (h - ht / 2) * (h - ht / 2);
+                float mfactor = 1.0;
+                if((h - ht / 2) * (w - wd / 2) < 0) {
+
+                    if(dsqrh > 0)
+                        mfactor *= 1.0 / (1.0 + pow(hsqr / dsqrh, degree));
+                    else
+                        mfactor = 0;
+                    if(hsqr > 0)
+                        mfactor *= 1.0 / (1.0 + pow(dsqrl / hsqr, degree));
+                    else
+                        mfactor = 0;
+
+                    flt[w] *= 1.0 - mfactor;
+                }
+
+                flt -= wd;
+            }
+        }
+    }
 }
 //-------------------------------------------------------------------------------------------------------------------------------------------------
-void pointNotchFilter2D( float * freqFilter, int* spec, int ht, int wd)
-{
-	// point centered notch filter
-	float xf = spec[2] * wd / (NYQUIST);
-
-	float yf = spec[3] * ht / (NYQUIST );
-
-	int degree = 2 * spec[4];
-
-	// calculate notch radial sqr
-	float d0sq = sqrt (xf*xf + yf*yf);
-	d0sq = (ht * ht + wd * wd)/ 4;
-	for(int h = 0; h < ht; h ++)
-	{
-		for(int w = 0; w < wd; w ++)
-		{
-			float d1 = ( (h - ht / 2 - yf) * (h - ht / 2 - yf) + (w - wd / 2 - xf) * (w - wd / 2 - xf) );
-			float d2 = ( (h - ht / 2 + yf) * (h - ht / 2 + yf) + (w - wd / 2 + xf) * (w - wd / 2 + xf) );
-		
-			if(d1 * d2 > 0.0 )
-		
-				freqFilter[ w] *= 1.0 / (( 1.0 + pow(1 + 1/d1, degree)) * (1.0 +  pow(1 + 1.0/d2, degree)) );
-			else
-				freqFilter[ w] = 0.0;
-				
-		}
-
-		freqFilter += wd;
-	}
+void pointNotchFilter2D(float *freqFilter, int *spec, int ht, int wd) {
+    // point centered notch filter
+    float xf = spec[2] * wd / (NYQUIST);
+
+    float yf = spec[3] * ht / (NYQUIST);
+
+    int degree = 2 * spec[4];
+
+    // calculate notch radial sqr
+    float d0sq = sqrt(xf * xf + yf * yf);
+    d0sq = (ht * ht + wd * wd) / 4;
+    for(int h = 0; h < ht; h++) {
+        for(int w = 0; w < wd; w++) {
+            float d1 = ((h - ht / 2 - yf) * (h - ht / 2 - yf) +
+                        (w - wd / 2 - xf) * (w - wd / 2 - xf));
+            float d2 = ((h - ht / 2 + yf) * (h - ht / 2 + yf) +
+                        (w - wd / 2 + xf) * (w - wd / 2 + xf));
+
+            if(d1 * d2 > 0.0)
+
+                freqFilter[w] *= 1.0 / ((1.0 + pow(1 + 1 / d1, degree)) *
+                                        (1.0 + pow(1 + 1.0 / d2, degree)));
+            else
+                freqFilter[w] = 0.0;
+        }
+
+        freqFilter += wd;
+    }
 }
-			
+
 //--------------------------------------------------------------------------------
 
-void ButterworthCircular2D(float *filt, int * fspec, int ht,int wd)
-{
-	int type = fspec[1];	// 1 locut, 2 hicut, 3 band pass 4 band stop 5 Notch
-	int vf1 = (fspec[2] * wd ) /(NYQUIST);
-	int hf1 = (fspec[2] * ht ) / (NYQUIST);
-	int vf2 = (fspec[3] * wd ) /( NYQUIST);
-	int hf2 = (fspec[3] * ht ) /(NYQUIST);
-	int degree = fspec[4] == 0 ? 1 : 2 * fspec[4];
-	float dsqr = (vf1 * vf1); 
-	float dsqrband =(vf2 * vf2) ; 
-	float ratiow2h = (1.0 * wd * wd) /(ht * ht);
-	switch (type)
-	{
-		case 1 :	// locut or high freq pass
-		{
-			
-
-			for (int h = 0; h < ht ; h ++)
-			{
-				float d1sqr = ( h  - ht / 2 ) * ( h  - ht / 2 ) * ratiow2h;				
+void ButterworthCircular2D(float *filt, int *fspec, int ht, int wd) {
+    int type = fspec[1]; // 1 locut, 2 hicut, 3 band pass 4 band stop 5 Notch
+    int vf1 = (fspec[2] * wd) / (NYQUIST);
+    int hf1 = (fspec[2] * ht) / (NYQUIST);
+    int vf2 = (fspec[3] * wd) / (NYQUIST);
+    int hf2 = (fspec[3] * ht) / (NYQUIST);
+    int degree = fspec[4] == 0 ? 1 : 2 * fspec[4];
+    float dsqr = (vf1 * vf1);
+    float dsqrband = (vf2 * vf2);
+    float ratiow2h = (1.0 * wd * wd) / (ht * ht);
+    switch(type) {
+    case 1: // locut or high freq pass
+    {
+
+        for(int h = 0; h < ht; h++) {
+            float d1sqr = (h - ht / 2) * (h - ht / 2) * ratiow2h;
+
+            for(int w = 0; w < wd; w++) {
+                float d2sqr = (w - wd / 2) * (w - wd / 2);
+
+                if(d1sqr + d2sqr > 0)
+
+                    filt[w] *=
+                        1.0 / (1.0 + pow(dsqr / (d1sqr + d2sqr), degree));
+                else
+                    filt[w] = 0;
+            }
+
+            filt += wd;
+        }
+
+        break;
+    }
+
+    case 2: // highcut or low freq pass 1.0 - locut filter
+    {
+
+        for(int h = 0; h < ht; h++) {
+            float d1sqr = (h - ht / 2) * (h - ht / 2) * ratiow2h;
+
+            for(int w = 0; w < wd; w++) {
+                float d2sqr = (w - wd / 2) * (w - wd / 2);
+
+                if(dsqr > 0)
+
+                    filt[w] *=
+                        1.0 / (1.0 + pow((d1sqr + d2sqr) / dsqr, degree));
+                else
+                    filt[w] = 0;
+            }
+
+            filt += wd;
+        }
+
+        break;
+    }
 
-				for ( int w = 0; w < wd ; w ++)
-				{
-					float d2sqr = ( w - wd / 2 ) * ( w - wd / 2 ); 
+    case 3: // band pass (locut * hicut)
+    {
+        for(int h = 0; h < ht; h++) {
+            float d1sqr = (h - ht / 2) * (h - ht / 2) * ratiow2h;
+            //	float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
+            float mfactor = 1.0;
 
-					if ( d1sqr + d2sqr > 0 )
-
-						filt[w] *= 1.0 / (1.0 + pow( dsqr / ( d1sqr + d2sqr) , degree) );
-					else
-						filt[w] = 0;
-				}
-
-				filt += wd;
-			}
-
-			break;
-		}
-
-		case 2 : // highcut or low freq pass 1.0 - locut filter
-		{
-
-			for (int h = 0; h < ht ; h ++)
-			{
-				float d1sqr = ( h - ht / 2 ) * ( h - ht / 2 ) * ratiow2h;				
-
-				for ( int w = 0; w < wd ; w ++)
-				{
-					float d2sqr = ( w - wd / 2 ) * ( w - wd / 2 ); 
-
-					if ( dsqr > 0 )
-
-						filt[w] *=  1.0 / (1.0 + pow( ( d1sqr + d2sqr)/ dsqr , degree) );
-					else
-						filt[w] = 0;
-				}
-
-				filt += wd;
-			}
-
-			break;
-		}
-
-		case 3 :	// band pass (locut * hicut)
-		{
-			for (int h = 0; h < ht ; h ++)
-			{
-				float d1sqr = ( h - ht / 2 ) * ( h - ht / 2 ) * ratiow2h;				
-			//	float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
-				float mfactor = 1.0;
-
-				for ( int w = 0; w < wd ; w ++)
-				{
-					float d2sqr = ( w - wd / 2 ) * ( w - wd / 2 ); 
-			//		float d2sqrband = ( w - wd / 2 ) * ( w - wd / 2 );
-					if ( d1sqr + d2sqr > 0 )
-
-						mfactor = 1.0 / (1.0 + pow( dsqr / ( d1sqr + d2sqr) , degree) );
-					else
-						mfactor = 0;
-
-					if ( dsqr > 0 )
-
-						mfactor *=  1.0 / ( 1.0 + pow (  ( d1sqr + d2sqr) / dsqrband , degree) );
-
-					filt[w] *= mfactor;
-				}
-
-				filt += wd;
-			}
-
-			break;
-		}
-
-		case 4 :	// band reject (locut * hicut)
-		{
-			for (int h = 0; h < ht ; h ++)
-			{
-				float d1sqr = ( h - ht / 2 ) * ( h - ht / 2 ) * ratiow2h;				
-			//	float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
-				float mfactor = 1.0;
-
-				for ( int w = 0; w < wd ; w ++)
-				{
-					float d2sqr = ( w - wd / 2 ) * ( w - wd / 2 ); 
-				//	float d2sqrband = ( w - wd / 2 ) * ( w - wd / 2 );
-					if ( d1sqr + d2sqr > 0 )
-
-						mfactor = 1.0 / (1.0 + pow( dsqr / ( d1sqr + d2sqr) , degree) );
-					else
-						mfactor = 0;
+            for(int w = 0; w < wd; w++) {
+                float d2sqr = (w - wd / 2) * (w - wd / 2);
+                //		float d2sqrband = ( w - wd / 2 ) * ( w - wd / 2 );
+                if(d1sqr + d2sqr > 0)
 
-					if ( dsqrband > 0 )
+                    mfactor = 1.0 / (1.0 + pow(dsqr / (d1sqr + d2sqr), degree));
+                else
+                    mfactor = 0;
 
-						mfactor *= 1.0 / ( 1.0 + pow (  ( d1sqr + d2sqr) / dsqrband , degree) );
+                if(dsqr > 0)
 
-					filt[w] *= 1.0 - mfactor;
-				}
+                    mfactor *=
+                        1.0 / (1.0 + pow((d1sqr + d2sqr) / dsqrband, degree));
 
-				filt += wd;
-			}
+                filt[w] *= mfactor;
+            }
 
-			break;
-		}
+            filt += wd;
+        }
 
-		case 5 :	// notch reject (locut * hicut)
-		{
-			for (int h = 0; h < ht ; h ++)
-			{
-				float d1sqr = ( h - ht / 2 ) * ( h - ht / 2 ) * ratiow2h;				
-			//	float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
-				float mfactor = 1.0;
+        break;
+    }
 
-				for ( int w = 0; w < wd ; w ++)
-				{
-					float d2sqr = ( w - wd / 2 ) * ( w - wd / 2 ); 
-				//	float d2sqrband = ( w - wd / 2 ) * ( w - wd / 2 );
-					if ( d1sqr + d2sqr > 0 )
-					{
+    case 4: // band reject (locut * hicut)
+    {
+        for(int h = 0; h < ht; h++) {
+            float d1sqr = (h - ht / 2) * (h - ht / 2) * ratiow2h;
+            //	float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
+            float mfactor = 1.0;
 
-						mfactor = 1.0 / (1.0 + pow( dsqr / ( d1sqr + d2sqr) , degree) );
-					
-						mfactor *= 1.0 - 1.0 / ( 1.0 + pow ( dsqr / ( d1sqr + d2sqr) , degree) );
-					}
-					else
-						mfactor = 0;
+            for(int w = 0; w < wd; w++) {
+                float d2sqr = (w - wd / 2) * (w - wd / 2);
+                //	float d2sqrband = ( w - wd / 2 ) * ( w - wd / 2 );
+                if(d1sqr + d2sqr > 0)
 
-					filt[w] *= 1.0 - mfactor;
-				}
+                    mfactor = 1.0 / (1.0 + pow(dsqr / (d1sqr + d2sqr), degree));
+                else
+                    mfactor = 0;
 
-				filt += wd;
-			}
+                if(dsqrband > 0)
 
-		}
-		
-		default : {}
+                    mfactor *=
+                        1.0 / (1.0 + pow((d1sqr + d2sqr) / dsqrband, degree));
 
+                filt[w] *= 1.0 - mfactor;
+            }
 
-	}
+            filt += wd;
+        }
+
+        break;
+    }
+
+    case 5: // notch reject (locut * hicut)
+    {
+        for(int h = 0; h < ht; h++) {
+            float d1sqr = (h - ht / 2) * (h - ht / 2) * ratiow2h;
+            //	float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
+            float mfactor = 1.0;
+
+            for(int w = 0; w < wd; w++) {
+                float d2sqr = (w - wd / 2) * (w - wd / 2);
+                //	float d2sqrband = ( w - wd / 2 ) * ( w - wd / 2 );
+                if(d1sqr + d2sqr > 0) {
+
+                    mfactor = 1.0 / (1.0 + pow(dsqr / (d1sqr + d2sqr), degree));
+
+                    mfactor *=
+                        1.0 - 1.0 / (1.0 + pow(dsqr / (d1sqr + d2sqr), degree));
+                } else
+                    mfactor = 0;
+
+                filt[w] *= 1.0 - mfactor;
+            }
+
+            filt += wd;
+        }
+    }
+
+    default: {
+    }
+    }
 }
 
 //--------------------------------------------------------------------------------
 
-void ButterworthHorizontal2D(float *filt, int * fspec, int ht,int wd)
-{
-	int type = fspec[1];	// 1 locut, 2 hicut, 3 band pass 4 band stop 5 Notch
-	int vf1 = (fspec[2] * ht ) /(NYQUIST);
-//	int hf1 = (fspec[2] * ht ) / NYQUIST;
-	int vf2 = (fspec[3] * ht ) /( NYQUIST);
-//	int hf2 = (fspec[3] * ht ) / NYQUIST;
-	int degree = fspec[4] == 0 ? 1 : 2 * fspec[4];
-	float dsqr = (vf1 * vf1 );
-	float dsqrband =(vf2 * vf2  );
-	
-	switch (type)
-	{
-		case 1 :	// locut or high freq pass
-		{
-			for (int h = 0; h < ht ; h ++)
-			{
-				float d1sqr = ( h - ht / 2 ) * ( h - ht / 2) ;				
-				float mfactor = 1.0;
-				
-					if ( d1sqr > 0 )
-
-						mfactor *= 1.0 / (1.0 + pow( dsqr / ( d1sqr ) , degree) );
-					else
-						mfactor = 0;
-
-				for ( int w = 0; w < wd ; w ++)
-				{
-					filt[w] *= mfactor;
-				}
-
-				filt += wd;
-			}
-
-			break;
-		}
-
-		case 2 : // highcut or low freq pass 1.0 - locut filter
-		{
-
-			for (int h = 0; h < ht ; h ++)
-			{
-				float d1sqr =  ( h - ht / 2 )*( h - ht / 2)  ;				
-				float mfactor = 1.0;
-				
-				if ( d1sqr > 0 )
-
-					mfactor =   1.0 / (1.0 + pow( d1sqr / ( dsqr) , degree) );
-
-				else
-
-					mfactor = 1.0;
-					
-				for ( int w = 0; w < wd ; w ++)
-				{
-					filt[w] *= mfactor;
-				}
-
-				filt += wd;
-			}
-
-			break;
-		}
-
-		case 3 :	// band pass (locut * hicut)
-		{
-			for (int h = 0; h < ht ; h ++)
-			{
-				float d1sqr =  ( h - ht / 2 )*( h - ht / 2)  ;				
-				//float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
-				float mfactor = 1.0;
-
-				
-					if ( d1sqr  > 0 )					
-
-						mfactor = 1.0 / (1.0 + pow( dsqr / ( d1sqr ) , degree) );
-					else
-
-						mfactor = 0.0;
-					
-					mfactor *= 1.0 / ( 1.0 + pow ( d1sqr / ( dsqrband ) , degree) );
-					
-				for ( int w = 0; w < wd ; w ++)
-				{
-
-					filt[w] *= mfactor;
-				}
-
-				filt += wd;
-			}
-
-			break;
-		}
-
-		case 4 :	// band reject (locut * hicut)
-		{
-			for (int h = 0; h < ht ; h ++)
-			{
-				float d1sqr =  ( h - ht / 2 )*( h - ht / 2)  ;				
-			//	float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
-				float mfactor = 1.0;
-
-				
-					if ( d1sqr  > 0 )
-
-						mfactor = 1.0 / (1.0 + pow( dsqr / ( d1sqr ) , degree) );
-					else
-						mfactor = 0.0;
+void ButterworthHorizontal2D(float *filt, int *fspec, int ht, int wd) {
+    int type = fspec[1]; // 1 locut, 2 hicut, 3 band pass 4 band stop 5 Notch
+    int vf1 = (fspec[2] * ht) / (NYQUIST);
+    //	int hf1 = (fspec[2] * ht ) / NYQUIST;
+    int vf2 = (fspec[3] * ht) / (NYQUIST);
+    //	int hf2 = (fspec[3] * ht ) / NYQUIST;
+    int degree = fspec[4] == 0 ? 1 : 2 * fspec[4];
+    float dsqr = (vf1 * vf1);
+    float dsqrband = (vf2 * vf2);
+
+    switch(type) {
+    case 1: // locut or high freq pass
+    {
+        for(int h = 0; h < ht; h++) {
+            float d1sqr = (h - ht / 2) * (h - ht / 2);
+            float mfactor = 1.0;
+
+            if(d1sqr > 0)
+
+                mfactor *= 1.0 / (1.0 + pow(dsqr / (d1sqr), degree));
+            else
+                mfactor = 0;
+
+            for(int w = 0; w < wd; w++) {
+                filt[w] *= mfactor;
+            }
+
+            filt += wd;
+        }
 
-					if ( dsqrband  > 0 )
+        break;
+    }
 
-						mfactor *=  1.0 / ( 1.0 + pow ( d1sqr / ( dsqrband ) , degree) );
-					else
-						mfactor = 0.0;
+    case 2: // highcut or low freq pass 1.0 - locut filter
+    {
 
-				for ( int w = 0; w < wd ; w ++)
-				{
+        for(int h = 0; h < ht; h++) {
+            float d1sqr = (h - ht / 2) * (h - ht / 2);
+            float mfactor = 1.0;
 
-					filt[w] *= 1.0 - mfactor;
-				}
+            if(d1sqr > 0)
 
-				filt += wd;
-			}
+                mfactor = 1.0 / (1.0 + pow(d1sqr / (dsqr), degree));
 
-			break;
-		}
+            else
 
-		case 5 :	// notch reject (locut * hicut)
-		{
-			for (int h = 0; h < ht ; h ++)
-			{
-				float d1sqr =  ( h - ht / 2 )*( h - ht / 2)  ;															
-			//	float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
-				float mfactor = 1.0;
+                mfactor = 1.0;
 
-				
-					
-					if ( d1sqr  > 0 )
+            for(int w = 0; w < wd; w++) {
+                filt[w] *= mfactor;
+            }
 
-						mfactor = 1.0 / (1.0 + pow( dsqr / ( d1sqr ) , degree) );
-					else
-						mfactor = 0.0;
+            filt += wd;
+        }
 
-					if ( dsqr > 0 )
+        break;
+    }
 
-						mfactor *= 1.0 / ( 1.0 + pow ( d1sqr / ( dsqr ) , degree) );
+    case 3: // band pass (locut * hicut)
+    {
+        for(int h = 0; h < ht; h++) {
+            float d1sqr = (h - ht / 2) * (h - ht / 2);
+            // float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
+            float mfactor = 1.0;
 
-					else
-						mfactor = 0.0;
+            if(d1sqr > 0)
 
-				for ( int w = 0; w < wd ; w ++)
-				{
+                mfactor = 1.0 / (1.0 + pow(dsqr / (d1sqr), degree));
+            else
 
-					filt[w] *= 1.0 - mfactor;
-				}
+                mfactor = 0.0;
 
-				filt += wd;
-			}
+            mfactor *= 1.0 / (1.0 + pow(d1sqr / (dsqrband), degree));
 
-		}
-		
-		default : {}
+            for(int w = 0; w < wd; w++) {
 
+                filt[w] *= mfactor;
+            }
 
-	}
+            filt += wd;
+        }
+
+        break;
+    }
+
+    case 4: // band reject (locut * hicut)
+    {
+        for(int h = 0; h < ht; h++) {
+            float d1sqr = (h - ht / 2) * (h - ht / 2);
+            //	float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
+            float mfactor = 1.0;
+
+            if(d1sqr > 0)
+
+                mfactor = 1.0 / (1.0 + pow(dsqr / (d1sqr), degree));
+            else
+                mfactor = 0.0;
+
+            if(dsqrband > 0)
+
+                mfactor *= 1.0 / (1.0 + pow(d1sqr / (dsqrband), degree));
+            else
+                mfactor = 0.0;
+
+            for(int w = 0; w < wd; w++) {
+
+                filt[w] *= 1.0 - mfactor;
+            }
+
+            filt += wd;
+        }
+
+        break;
+    }
+
+    case 5: // notch reject (locut * hicut)
+    {
+        for(int h = 0; h < ht; h++) {
+            float d1sqr = (h - ht / 2) * (h - ht / 2);
+            //	float d1sqrband = ( h - ht/ 2 ) * ( h - ht / 2 );
+            float mfactor = 1.0;
+
+            if(d1sqr > 0)
+
+                mfactor = 1.0 / (1.0 + pow(dsqr / (d1sqr), degree));
+            else
+                mfactor = 0.0;
+
+            if(dsqr > 0)
+
+                mfactor *= 1.0 / (1.0 + pow(d1sqr / (dsqr), degree));
+
+            else
+                mfactor = 0.0;
+
+            for(int w = 0; w < wd; w++) {
+
+                filt[w] *= 1.0 - mfactor;
+            }
+
+            filt += wd;
+        }
+    }
+
+    default: {
+    }
+    }
 }
 
 //--------------------------------------------------------------------------------
 
-void ButterworthVertical2D(float *filt, int * fspec, int ht,int wd)
-{
-	int type = fspec[1];	// 1 locut, 2 hicut, 3 band pass 4 band stop 5 Notch
-	//int vf1 = (fspec[2] * ht ) /(2 * NYQUIST);
-	int hf1 = (fspec[2] * wd ) / NYQUIST; 
-	//int vf2 = (fspec[3] * ht ) /(2 * NYQUIST);
-	int hf2 = (fspec[3] * wd ) / NYQUIST; 
-	int degree = fspec[4] == 0 ? 1 : 2 * fspec[4];
-	float dsqr = ( hf1 * hf1 );
-	float dsqrband =( hf2 * hf2 );
+void ButterworthVertical2D(float *filt, int *fspec, int ht, int wd) {
+    int type = fspec[1]; // 1 locut, 2 hicut, 3 band pass 4 band stop 5 Notch
+    // int vf1 = (fspec[2] * ht ) /(2 * NYQUIST);
+    int hf1 = (fspec[2] * wd) / NYQUIST;
+    // int vf2 = (fspec[3] * ht ) /(2 * NYQUIST);
+    int hf2 = (fspec[3] * wd) / NYQUIST;
+    int degree = fspec[4] == 0 ? 1 : 2 * fspec[4];
+    float dsqr = (hf1 * hf1);
+    float dsqrband = (hf2 * hf2);
 
-	switch (type)
-	{
-		case 1 :	// locut or high freq pass
-		{			
+    switch(type) {
+    case 1: // locut or high freq pass
+    {
 
-			for (int w = 0; w < wd ; w ++)
-			{
-				float * flt = filt + w;
+        for(int w = 0; w < wd; w++) {
+            float *flt = filt + w;
 
-				float d2sqr = ( w - wd / 2 ) * ( w - wd / 2 ) ;
+            float d2sqr = (w - wd / 2) * (w - wd / 2);
 
-				float mfactor;
+            float mfactor;
 
-				
-					if (  d2sqr > 0 )
+            if(d2sqr > 0)
 
-						mfactor =  1.0 / (1.0 + pow( dsqr / (  d2sqr) , degree) );
-					else
-						mfactor = 0;
+                mfactor = 1.0 / (1.0 + pow(dsqr / (d2sqr), degree));
+            else
+                mfactor = 0;
 
-				for ( int h = 0; h < ht ; h ++)
-				{
-					flt[0] *= mfactor;
+            for(int h = 0; h < ht; h++) {
+                flt[0] *= mfactor;
 
-					flt += wd;
-				}
-			}
+                flt += wd;
+            }
+        }
 
-			break;
-		}
+        break;
+    }
 
-		case 2 : // highcut or low freq pass 1.0 - locut filter
-		{
+    case 2: // highcut or low freq pass 1.0 - locut filter
+    {
 
-			for (int w = 0; w < wd ; w ++)
-			{
-				float * flt = filt + w;
+        for(int w = 0; w < wd; w++) {
+            float *flt = filt + w;
 
-				float d2sqr =  ( w - wd / 2 ) * ( w - wd / 2 ) ; 				
+            float d2sqr = (w - wd / 2) * (w - wd / 2);
 
-				float mfactor;
+            float mfactor;
 
-					if (  d2sqr > 0 ) 					
+            if(d2sqr > 0)
 
-						mfactor =   1.0 / (1.0 + pow( d2sqr / ( dsqr) , degree) );
-					else
-						mfactor = 1.0;
+                mfactor = 1.0 / (1.0 + pow(d2sqr / (dsqr), degree));
+            else
+                mfactor = 1.0;
 
-				for ( int h = 0; h < ht ; h ++)
-				{
-					flt[0] *= mfactor;
+            for(int h = 0; h < ht; h++) {
+                flt[0] *= mfactor;
 
-					flt += wd;
-				}
-			}
+                flt += wd;
+            }
+        }
 
-			break;
-		}
+        break;
+    }
 
-		case 3 :	// band pass (locut * hicut)
-		{
-			for (int w = 0; w < wd ; w ++)
-			{
-				float * flt = filt + w;
+    case 3: // band pass (locut * hicut)
+    {
+        for(int w = 0; w < wd; w++) {
+            float *flt = filt + w;
 
-				float d2sqr = ( w - wd / 2 ) * ( w - wd / 2 ) ; 				
-			//	float d2sqrband = abs( w - wd / 2 );
+            float d2sqr = (w - wd / 2) * (w - wd / 2);
+            //	float d2sqrband = abs( w - wd / 2 );
 
-				float mfactor = 1.0;				
-					
-					if ( d2sqr > 0 )
+            float mfactor = 1.0;
 
-						mfactor = 1.0 /  (1.0 + pow( dsqr / ( d2sqr) , degree) );
-							   
-					else
-						mfactor = 0.0;
+            if(d2sqr > 0)
 
-					if ( dsqrband > 0)
+                mfactor = 1.0 / (1.0 + pow(dsqr / (d2sqr), degree));
 
-						mfactor *= 1.0 / ( 1.0 + pow ( d2sqr / ( dsqrband ) , degree) )  ;
-				//	else
-				//		mfactor = 1.00;
-					
-				for ( int h = 0; h < ht ; h ++)
-				{
+            else
+                mfactor = 0.0;
 
-					flt[0] *= mfactor;				
+            if(dsqrband > 0)
 
-					flt += wd;
-				}
-			}
+                mfactor *= 1.0 / (1.0 + pow(d2sqr / (dsqrband), degree));
+            //	else
+            //		mfactor = 1.00;
 
-			break;
-		}
+            for(int h = 0; h < ht; h++) {
 
-		case 4 :	// band reject (locut * hicut)
-		{
-			for (int w = 0; w < wd ; w ++)
-			{
-				float * flt = filt + w;
+                flt[0] *= mfactor;
 
-				float d2sqr = ( w - wd / 2 )* ( w - wd / 2 ) ; 				
-			//	float d2sqrband = abs( w - wd / 2 );
+                flt += wd;
+            }
+        }
 
-				float mfactor = 1.0;										
-				if (d2sqr > 0)
+        break;
+    }
 
-					mfactor =  1.0 /  (1.0 + pow( dsqr / ( d2sqr) , degree) );	
-				else
-					mfactor = 0;
+    case 4: // band reject (locut * hicut)
+    {
+        for(int w = 0; w < wd; w++) {
+            float *flt = filt + w;
 
-					if(dsqrband > 0)
+            float d2sqr = (w - wd / 2) * (w - wd / 2);
+            //	float d2sqrband = abs( w - wd / 2 );
 
-						mfactor *= 1.0 / ( 1.0 + pow ( d2sqr / ( dsqrband) , degree) ) ;
+            float mfactor = 1.0;
+            if(d2sqr > 0)
 
-					else
-						mfactor = 0;
-					
-				for ( int h = 0; h < ht ; h ++)
-				{
+                mfactor = 1.0 / (1.0 + pow(dsqr / (d2sqr), degree));
+            else
+                mfactor = 0;
 
-					flt[0] *= 1 -  mfactor;				
+            if(dsqrband > 0)
 
-					flt += wd;
-				}
-			}
+                mfactor *= 1.0 / (1.0 + pow(d2sqr / (dsqrband), degree));
 
-			break;
-		}
+            else
+                mfactor = 0;
 
-		case 5 :	// notch reject (locut * hicut)
-		{
-			
-			float mfactor = 1.0;
+            for(int h = 0; h < ht; h++) {
 
-			for (int w = 0; w < wd ; w ++)
-			{
-				float * flt = filt + w;
+                flt[0] *= 1 - mfactor;
 
-				float d2sqr = ( w - wd / 2 ) * ( w - wd / 2 ) ; 			
+                flt += wd;
+            }
+        }
 
-				float mfactor = 1.0;				
-					
-					if ( d2sqr > 0 )					
+        break;
+    }
 
-						mfactor = 1.0 /  (1.0 + pow( dsqr / ( d2sqr) , degree) );
-							 
-					else
-						mfactor = 0.0;
+    case 5: // notch reject (locut * hicut)
+    {
 
-					if ( dsqr > 0)
+        float mfactor = 1.0;
 
-						mfactor *=  1.0 / ( 1.0 + pow ( d2sqr / ( dsqr ) , degree) );
-					else
-						mfactor = 0;
-					
-				for ( int h = 0; h < ht ; h ++)
-				{
+        for(int w = 0; w < wd; w++) {
+            float *flt = filt + w;
 
-					flt[0] *= 1.0 - mfactor;				
+            float d2sqr = (w - wd / 2) * (w - wd / 2);
 
-					flt += wd;
-				}
-			}
+            float mfactor = 1.0;
 
-			break;
-		}
-		
-		default : {}
+            if(d2sqr > 0)
 
+                mfactor = 1.0 / (1.0 + pow(dsqr / (d2sqr), degree));
 
-	}
-}
+            else
+                mfactor = 0.0;
 
+            if(dsqr > 0)
 
+                mfactor *= 1.0 / (1.0 + pow(d2sqr / (dsqr), degree));
+            else
+                mfactor = 0;
+
+            for(int h = 0; h < ht; h++) {
+
+                flt[0] *= 1.0 - mfactor;
+
+                flt += wd;
+            }
+        }
+
+        break;
+    }
+
+    default: {
+    }
+    }
+}
 
 #endif
\ No newline at end of file
diff --git a/F2QuiverSpectralDisplay.h b/F2QuiverSpectralDisplay.h
index 9322bd0..a17fc4c 100644
--- a/F2QuiverSpectralDisplay.h
+++ b/F2QuiverSpectralDisplay.h
@@ -3,232 +3,195 @@
 #define F2QUIVER_FREQSPECTRAL_AND_FILTER_DISPLAY_VCMOHAN
 //-------------------------------------------------------------------
 // declarations
-	template <typename finc>
-	void drawHorizontalRuler2D(finc * dp , const int pitch, const int  wd ,int frqwidth, finc max, const int nyq);
-	template <typename finc>
-	void drawVerticalRuler2D(finc * dp , const int pitch, const int  ht , int hbest, finc max, const int nyq);
-	template <typename finc>
-	void displayPowerSpectrum2D(finc * dp, int pitch, float * powerSpectrum, int wd, int ht, int frqwidth,finc max, float gamma);
-	template <typename finc>
-	void displayFilter2D(finc * dp, int dpitch, float * filter,int fpitch, int wd , int ht, finc max, int nfft );
-	void getPowerSpectrum2D( float * powerSpectrum, fftwf_complex * out, int nval);
+template <typename finc>
+void drawHorizontalRuler2D(finc *dp, const int pitch, const int wd,
+                           int frqwidth, finc max, const int nyq);
+template <typename finc>
+void drawVerticalRuler2D(finc *dp, const int pitch, const int ht, int hbest,
+                         finc max, const int nyq);
+template <typename finc>
+void displayPowerSpectrum2D(finc *dp, int pitch, float *powerSpectrum, int wd,
+                            int ht, int frqwidth, finc max, float gamma);
+template <typename finc>
+void displayFilter2D(finc *dp, int dpitch, float *filter, int fpitch, int wd,
+                     int ht, finc max, int nfft);
+void getPowerSpectrum2D(float *powerSpectrum, fftwf_complex *out, int nval);
 //----------------------------------------------------------------------------
-	// definitions
+// definitions
 
 template <typename finc>
-void displayFilter2D(finc * dp, int dpitch, float * filter,int fpitch, int wd , int ht, finc max, int nfft )
-{
-	for ( int h = 0; h < ht; h ++)
-	{
-		for (int w = 0; w < wd; w ++)
-		{
-			dp[w] = max * filter[w]; // *nfft;
-		}
-		filter += fpitch;
-		dp += dpitch;
-	}
+void displayFilter2D(finc *dp, int dpitch, float *filter, int fpitch, int wd,
+                     int ht, finc max, int nfft) {
+    for(int h = 0; h < ht; h++) {
+        for(int w = 0; w < wd; w++) {
+            dp[w] = max * filter[w]; // *nfft;
+        }
+        filter += fpitch;
+        dp += dpitch;
+    }
 }
-		
-	
+
 //-------------------------------------------------------------------------------------------
 template <typename finc>
-void displayPowerSpectrum2D(finc * dp,int pitch, float * powerSpectrum, int wd, int ht, int frqwidth, finc max, float gamma)
-{
-	for ( int h = 0; h < ht; h ++)
-	{
-		for (int w = 0; w < wd ; w ++)
-		{
-			dp[w] = pow(powerSpectrum[w] , gamma) * max;
-		}
-		dp += pitch;
-		powerSpectrum += frqwidth;
-	}
-
-
+void displayPowerSpectrum2D(finc *dp, int pitch, float *powerSpectrum, int wd,
+                            int ht, int frqwidth, finc max, float gamma) {
+    for(int h = 0; h < ht; h++) {
+        for(int w = 0; w < wd; w++) {
+            dp[w] = pow(powerSpectrum[w], gamma) * max;
+        }
+        dp += pitch;
+        powerSpectrum += frqwidth;
+    }
 }
 
 //-------------------------------------------------------------------------------------------
-void getPowerSpectrum2D( float * powerSpectrum, fftwf_complex * out, int nval)
-{
-	float pmax = 0.0f;
+void getPowerSpectrum2D(float *powerSpectrum, fftwf_complex *out, int nval) {
+    float pmax = 0.0f;
 
-	for ( int i = 0; i < nval; i ++)
-	{
-		powerSpectrum[i] = out[i][0] * out[i][0] + out[i][1] * out[i][1];
+    for(int i = 0; i < nval; i++) {
+        powerSpectrum[i] = out[i][0] * out[i][0] + out[i][1] * out[i][1];
 
-		if ( pmax < powerSpectrum[i])
+        if(pmax < powerSpectrum[i])
 
-			pmax = powerSpectrum[i];
-	}
-	
-	pmax = 1.0f / pmax;
+            pmax = powerSpectrum[i];
+    }
 
-	for ( int i = 0; i < nval; i ++)
-	{
-		powerSpectrum[i] *=  pmax;
-	}
+    pmax = 1.0f / pmax;
 
+    for(int i = 0; i < nval; i++) {
+        powerSpectrum[i] *= pmax;
+    }
 }
 //---------------------------------------------------------------------------------------------------
 
 template <typename finc>
-void drawHorizontalRuler2D(finc * dstp , const int pitch, const int  wd , int frqwidth, finc max, const int nyq)
-{
-	if ( frqwidth/2 > wd )
-		// can not display even half of ruler
-		return;
-	finc * dp = dstp + frqwidth / 2 ;	// ruler center point
-	int limitr = wd - frqwidth / 2;
-	int limitl = frqwidth / 2;
-
-	for ( int fq = 0; fq < nyq/2 ; fq += 10)
-	{
-		int w = (fq * frqwidth) / (  nyq);	// ok. only ratio
-
-	//	if( w >= wd / 2) continue;
-		
-
-		if ( (fq % 100) == 0)
-		{
-			// every 100 th freq
-			if ( wd > 25)
-			{
-				for ( int h = 0; h < 10; h ++)
-				{
-					if ( w < limitr)
-						dp[h * pitch + w] = max;
-					if( w < limitl)
-						dp[h * pitch - w] = max;
-				}
-			}
-		}
-
-		else if ( (fq % 50) == 0 && wd >= 50 &&  ( wd < 100 || wd >= 250) )
-		{
-			// every 50th freq
-			for ( int h = 0; h < 8; h ++)
-			{
-				if ( w < limitr)
-					dp[h * pitch + w] = (4 * max )/ 5;
-				if ( w < limitl)
-					dp[h * pitch - w] = ( 4 * max) / 5;
-				
-			}
-		}
-
-		else if ( (fq % 20) == 0 && wd >= 100 && wd <  250)
-		{
-			// every 20th freq if 50th not drawn
-			for ( int h = 0; h < 8; h ++)
-			{
-				if ( w < limitr)
-					dp[h * pitch + w] = (4 * max )/ 5;
-				if ( w < limitl)
-					dp[h * pitch - w] = ( 4 * max) / 5;
-				
-			}
-		}
-
-		else if( (fq % 10 ) == 0)
-		{
-			for ( int h = 0; h < 4; h ++)
-			{
-				if ( w < limitr)
-					dp[h * pitch + w] = (3 * max )/ 4;
-				if ( w < limitl)
-					dp[h * pitch - w] = ( 3 * max) / 4;
-				
-			}
-		}
-	}
-	// draw an arrow head to indicate center
-
-		for ( int xy = 0; xy < 3; xy ++)
-		{
-	//		if ( xy < limitr)
-				dp[ (10 - xy ) * pitch + xy] = max;
-	//		if (  xy < limitl)
-				dp[ (10 - xy ) * pitch - xy] = max;
-		}
-	
+void drawHorizontalRuler2D(finc *dstp, const int pitch, const int wd,
+                           int frqwidth, finc max, const int nyq) {
+    if(frqwidth / 2 > wd)
+        // can not display even half of ruler
+        return;
+    finc *dp = dstp + frqwidth / 2; // ruler center point
+    int limitr = wd - frqwidth / 2;
+    int limitl = frqwidth / 2;
+
+    for(int fq = 0; fq < nyq / 2; fq += 10) {
+        int w = (fq * frqwidth) / (nyq); // ok. only ratio
+
+        //	if( w >= wd / 2) continue;
+
+        if((fq % 100) == 0) {
+            // every 100 th freq
+            if(wd > 25) {
+                for(int h = 0; h < 10; h++) {
+                    if(w < limitr)
+                        dp[h * pitch + w] = max;
+                    if(w < limitl)
+                        dp[h * pitch - w] = max;
+                }
+            }
+        }
+
+        else if((fq % 50) == 0 && wd >= 50 && (wd < 100 || wd >= 250)) {
+            // every 50th freq
+            for(int h = 0; h < 8; h++) {
+                if(w < limitr)
+                    dp[h * pitch + w] = (4 * max) / 5;
+                if(w < limitl)
+                    dp[h * pitch - w] = (4 * max) / 5;
+            }
+        }
+
+        else if((fq % 20) == 0 && wd >= 100 && wd < 250) {
+            // every 20th freq if 50th not drawn
+            for(int h = 0; h < 8; h++) {
+                if(w < limitr)
+                    dp[h * pitch + w] = (4 * max) / 5;
+                if(w < limitl)
+                    dp[h * pitch - w] = (4 * max) / 5;
+            }
+        }
+
+        else if((fq % 10) == 0) {
+            for(int h = 0; h < 4; h++) {
+                if(w < limitr)
+                    dp[h * pitch + w] = (3 * max) / 4;
+                if(w < limitl)
+                    dp[h * pitch - w] = (3 * max) / 4;
+            }
+        }
+    }
+    // draw an arrow head to indicate center
+
+    for(int xy = 0; xy < 3; xy++) {
+        //		if ( xy < limitr)
+        dp[(10 - xy) * pitch + xy] = max;
+        //		if (  xy < limitl)
+        dp[(10 - xy) * pitch - xy] = max;
+    }
 }
 
 //-------------------------------------------------------------------------------
 template <typename finc>
-void drawVerticalRuler2D(finc * dsp , const int pitch, const int  ht, int hbest ,finc max, const int nyq)
-{
-	if ( hbest / 2 > ht)
-		return;	// even center and half of ruler will not be visible
-	finc * dp = dsp + hbest / 2 * pitch;	// center of ruler
-	int limith = ht - hbest / 2;
-	int limitl = hbest / 2;	// may not be reqd
-
-	for ( int fq = 0; fq < nyq; fq += 10)
-	{
-		int h = (fq * hbest) / (  nyq);
-	//	if ( h >= ht/2) continue;
-		if ( (fq % 100) == 0)
-		{
-			// every 100 th freq
-			if ( ht > 25)
-			{
-				for ( int w = 0; w < 10; w ++)
-				{
-					if ( h < limith)
-						dp[h * pitch + w] = max;
-					if( h < limitl)
-						dp[ - h * pitch + w] = max;
-				}
-			}
-		}
-
-		else if ( (fq % 50) == 0 && ht >= 50 &&  ( ht < 100 || ht >= 250) )
-		{
-			// every 50th freq
-			for ( int w = 0; w < 8; w ++)
-			{
-				if ( h < limith)
-					dp[h * pitch + w] = (4 * max )/ 5;
-				if ( h < limitl)
-					dp[ - h * pitch + w] = ( 4 * max) / 5;
-				
-			}
-		}
-
-		else if ( (fq % 20) == 0 && ht >= 100 && ht <  250)
-		{
-			// every 20th freq if 50th not drawn
-			for ( int w = 0; w < 8; w ++)
-			{
-				if ( h < limith)
-					dp[h * pitch + w] = (4 * max )/ 5;
-				if ( h < limitl)
-					dp[ -h * pitch + w] = ( 4 * max) / 5;	
-			}
-		}
-
-		else if( (fq % 10 ) == 0)
-		{
-			for ( int w = 0; w < 4; w ++)
-			{
-				if ( h < limith)
-					dp[h * pitch + w] = (3 * max )/ 4;
-				if ( h < limitl)
-					dp[ -h * pitch + w] = ( 3 * max) / 4;
-				
-			}
-		}
-	}
-	// draw an arrow head to indicate center
-
-		for ( int xy = 0; xy < 3; xy ++)
-		{
-			if( xy < limith)
-				dp[ (10 - xy ) + pitch * xy] = max;
-			if ( xy < limitl)
-			dp[ (10 - xy ) - pitch * xy] = max;
-		}
-	
+void drawVerticalRuler2D(finc *dsp, const int pitch, const int ht, int hbest,
+                         finc max, const int nyq) {
+    if(hbest / 2 > ht)
+        return; // even center and half of ruler will not be visible
+    finc *dp = dsp + hbest / 2 * pitch; // center of ruler
+    int limith = ht - hbest / 2;
+    int limitl = hbest / 2; // may not be reqd
+
+    for(int fq = 0; fq < nyq; fq += 10) {
+        int h = (fq * hbest) / (nyq);
+        //	if ( h >= ht/2) continue;
+        if((fq % 100) == 0) {
+            // every 100 th freq
+            if(ht > 25) {
+                for(int w = 0; w < 10; w++) {
+                    if(h < limith)
+                        dp[h * pitch + w] = max;
+                    if(h < limitl)
+                        dp[-h * pitch + w] = max;
+                }
+            }
+        }
+
+        else if((fq % 50) == 0 && ht >= 50 && (ht < 100 || ht >= 250)) {
+            // every 50th freq
+            for(int w = 0; w < 8; w++) {
+                if(h < limith)
+                    dp[h * pitch + w] = (4 * max) / 5;
+                if(h < limitl)
+                    dp[-h * pitch + w] = (4 * max) / 5;
+            }
+        }
+
+        else if((fq % 20) == 0 && ht >= 100 && ht < 250) {
+            // every 20th freq if 50th not drawn
+            for(int w = 0; w < 8; w++) {
+                if(h < limith)
+                    dp[h * pitch + w] = (4 * max) / 5;
+                if(h < limitl)
+                    dp[-h * pitch + w] = (4 * max) / 5;
+            }
+        }
+
+        else if((fq % 10) == 0) {
+            for(int w = 0; w < 4; w++) {
+                if(h < limith)
+                    dp[h * pitch + w] = (3 * max) / 4;
+                if(h < limitl)
+                    dp[-h * pitch + w] = (3 * max) / 4;
+            }
+        }
+    }
+    // draw an arrow head to indicate center
+
+    for(int xy = 0; xy < 3; xy++) {
+        if(xy < limith)
+            dp[(10 - xy) + pitch * xy] = max;
+        if(xy < limitl)
+            dp[(10 - xy) - pitch * xy] = max;
+    }
 }
 //------------------------------------------------------------------------------------------------------
 
diff --git a/FQBlur.cpp b/FQBlur.cpp
index cade663..f95f5c1 100644
--- a/FQBlur.cpp
+++ b/FQBlur.cpp
@@ -1,9 +1,9 @@
 /******************************************************************************
 FQBlur filter plugin for vapoursynth by V.C.Mohan
-This filter operates in freq domain (2d) and blurs 
+This filter operates in freq domain (2d) and blurs
 linear (motion) or circular (focus) styles within a window
 
-Author V.C.Mohan. 
+Author V.C.Mohan.
 12 june 2015, 26 May 2021
 Copyright (C) < 2008- 2021>  <V.C.Mohan>
 
@@ -18,14 +18,14 @@ Copyright (C) < 2008- 2021>  <V.C.Mohan>
 
     A copy of the GNU General Public License is at
     see <http://www.gnu.org/licenses/>.
-	For details of how to contact author see <http://www.avisynth.org/vcmohan> 
+    For details of how to contact author see <http://www.avisynth.org/vcmohan>
 ********************************************************************************/
 /*
-#include <Windows.h>
-#include <stdlib.h>
-#include "VapourSynth.h"
 #include "VSHelper.h"
+#include "VapourSynth.h"
+#include <Windows.h>
 #include <math.h>
+#include <stdlib.h>
 //#include <complex>
 #include "fftwlite.h"
 
@@ -34,389 +34,401 @@ Copyright (C) < 2008- 2021>  <V.C.Mohan>
 //------------------------------------------------------------------------------
 //------------------------------------------------------------------------------------------------------------
 
-
-
-
-
 //----------------------------------------------------------------------------------------
 
-typedef struct 
-{
+typedef struct {
     VSNodeRef *node;
-    const VSVideoInfo *vi;				
-		bool line;			// true for line or false for circular
-		int xcoord;			// right end x coordinate or blur radius in pixels
-		int ycoord;			// right end y coordinate for line being true		
-	
-		int wbest;				// nearest higher width for best speed of fft
-		int hbest;				// nearest higher height for best speed of fft
-		int wbestUV;			// for YUV with subsamplingW
-		int hbestUV;			// for YUV with subsamplingH
-		float * FreqFilter;	// This is the place designed filter resides
-		float* FreqFilterUV;
-		fftwf_plan  pf, pinv;	// forward and inverse fft plans
-		fftwf_plan  pfUV, pinvUV;	// for subsampled planes
-		int bestR, bestRUV;				// width for real data will be half of bwd + 1.and used for filter design 
+    const VSVideoInfo *vi;
+    bool line;  // true for line or false for circular
+    int xcoord; // right end x coordinate or blur radius in pixels
+    int ycoord; // right end y coordinate for line being true
+
+    int wbest;         // nearest higher width for best speed of fft
+    int hbest;         // nearest higher height for best speed of fft
+    int wbestUV;       // for YUV with subsamplingW
+    int hbestUV;       // for YUV with subsamplingH
+    float *FreqFilter; // This is the place designed filter resides
+    float *FreqFilterUV;
+    fftwf_plan pf, pinv;     // forward and inverse fft plans
+    fftwf_plan pfUV, pinvUV; // for subsampled planes
+    int bestR, bestRUV; // width for real data will be half of bwd + 1.and used
+                        // for filter design
 
 #include "fftLateBindingClassParams.cpp"
-		float* inBuf;
-		fftwf_complex* outBuf;
-		
-}F2QBlurData;	
+    float *inBuf;
+    fftwf_complex *outBuf;
+
+} F2QBlurData;
 /*************************************************/
 template <typename finc>
-void blurPlane2D(F2QBlurData* d, float* inBuf, fftwf_complex* outBuf, float* filter,
-	fftwf_plan pf, fftwf_plan pinv, const finc* sp, finc* dp,
-	int pitch, int height, int width, int bestY, int bestX, finc min, finc max);
-void positionBlurFilter(fftwf_complex* fout, float* Filter, int bestx, int besty);
+void blurPlane2D(F2QBlurData *d, float *inBuf, fftwf_complex *outBuf,
+                 float *filter, fftwf_plan pf, fftwf_plan pinv, const finc *sp,
+                 finc *dp, int pitch, int height, int width, int bestY,
+                 int bestX, finc min, finc max);
+void positionBlurFilter(fftwf_complex *fout, float *Filter, int bestx,
+                        int besty);
 //---------------------------------------------------------------------------------
-static void VS_CC f2qblurInit(VSMap *in, VSMap *out, void **instanceData, VSNode *node, VSCore *core, const VSAPI *vsapi)
-{
-    F2QBlurData *d = (F2QBlurData *) * instanceData;
+static void VS_CC f2qblurInit(VSMap *in, VSMap *out, void **instanceData,
+                              VSNode *node, VSCore *core, const VSAPI *vsapi) {
+    F2QBlurData *d = (F2QBlurData *) *instanceData;
     vsapi->setVideoInfo(d->vi, 1, node);
 
     const VSFormat *fi = d->vi->format;
-       
-			// frame dimensions
-	int fwd = ( (d->vi->width + 3) >> 2) << 2;
-    int fht = ( (d->vi->height + 3) >> 2) << 2;
-	int fwdUV = fwd, fhtUV = fht;
-				// filter dimensions	
 
-	int *factorsbuf = vs_aligned_malloc <int>(sizeof( int) *64, 32);	//maximum 64 factors, first is factor, second is dividend to be factored. At 
+    // frame dimensions
+    int fwd = ((d->vi->width + 3) >> 2) << 2;
+    int fht = ((d->vi->height + 3) >> 2) << 2;
+    int fwdUV = fwd, fhtUV = fht;
+    // filter dimensions
 
-	d->wbest = getBestDim(fwd + ADDSAFE, factorsbuf);
+    int *factorsbuf = vs_aligned_malloc<int>(
+        sizeof(int) * 64, 32); // maximum 64 factors, first is factor, second is
+                               // dividend to be factored. At
 
-	d->hbest = getBestDim(fht + ADDSAFE, factorsbuf);
-	int subH = 0;
-	int subW = 0;
+    d->wbest = getBestDim(fwd + ADDSAFE, factorsbuf);
 
-	if (fi->colorFamily == cmYUV)
-	{
-		subW = fi->subSamplingW;
-		subH = fi->subSamplingH;
+    d->hbest = getBestDim(fht + ADDSAFE, factorsbuf);
+    int subH = 0;
+    int subW = 0;
 
-		fwdUV = fwd >> subW;
-		fhtUV = fht >> subH;
+    if(fi->colorFamily == cmYUV) {
+        subW = fi->subSamplingW;
+        subH = fi->subSamplingH;
 
-		d->wbestUV = getBestDim(fwdUV + ADDSAFE, factorsbuf);
-		d->hbestUV = getBestDim(fhtUV + ADDSAFE, factorsbuf);
-	}
-	else
-	{
-		d->wbestUV = d->wbest;
-		d->hbestUV = d->hbest;
-	}
+        fwdUV = fwd >> subW;
+        fhtUV = fht >> subH;
 
-	vs_aligned_free(factorsbuf);
+        d->wbestUV = getBestDim(fwdUV + ADDSAFE, factorsbuf);
+        d->hbestUV = getBestDim(fhtUV + ADDSAFE, factorsbuf);
+    } else {
+        d->wbestUV = d->wbest;
+        d->hbestUV = d->hbest;
+    }
 
-	d->bestR = d->wbest/2 + 1;
-	d->bestRUV = d->wbestUV / 2 + 1;
+    vs_aligned_free(factorsbuf);
+
+    d->bestR = d->wbest / 2 + 1;
+    d->bestRUV = d->wbestUV / 2 + 1;
 
 #include "ConstructorCodeForLateBindingfft.cpp"
 
-	if (!ok)
-	{
-		vsapi->setError(out, "vcm.fqblur: could not load any of the dll or get required fnctions");
-		if (d->hinstLib != NULL)
-			FreeLibrary(d->hinstLib);
-		vsapi->freeNode(d->node);		
-		return;
-	}
-
-	int nbits=fi->bitsPerSample;	
-	
-	int isize = d->hbest * d->wbest;
-	int fqsize = d->hbest * d->bestR;
-	int isizeUV = d->hbestUV * d->wbestUV;
-	int fqsizeUV = d->hbestUV * d->bestRUV;
-	// buffers 
-	d->inBuf = (float*)d->fftwf_malloc(sizeof(float) * isize);
-
-	d->outBuf = (fftwf_complex*)d->fftwf_malloc (sizeof(fftwf_complex) * fqsize);// +1 is only a safeguard not really reqd
-
-		
-			// creates forward and inverse fft plans
-
-	d->FreqFilter = (float*)d->fftwf_malloc(sizeof(float) * fqsize);
-
-			//  forward for padded size complex to complex  
-	d->pf = d->fftwf_plan_dft_r2c_2d(d->hbest, d->wbest, d->inBuf, d->outBuf,  FFTW_MEASURE);
-			// inverse 
-
-	d->pinv = d->fftwf_plan_dft_c2r_2d(d->hbest, d->wbest, d->outBuf, d->inBuf,  FFTW_MEASURE);
-
-
-	if (subH != 0 || subW != 0)
-	{
-		d->FreqFilterUV = (float*)d->fftwf_malloc(sizeof(float) * fqsizeUV);
-		d->pfUV = d->fftwf_plan_dft_r2c_2d(d->hbestUV, d->wbestUV, d->inBuf, d->outBuf, FFTW_MEASURE);
-		d->pinvUV = d->fftwf_plan_dft_c2r_2d(d->hbestUV, d->wbestUV, d->outBuf, d->inBuf, FFTW_MEASURE);
-	}
-	else
-	{
-		d->FreqFilterUV = d->FreqFilter;
-		d-> pfUV = d->pf;
-		d->pinvUV = d->pinv;
-	}
-
-	int count = DrawPSF(d->inBuf, d->line, d-> xcoord, d-> ycoord, d->wbest, d->hbest, 0.0);	// we can add spike to mellow inversion
-					// forward transform
-	d->fftwf_execute(d->pf);
-			// make it zero phase
-	for( int i = 0; i < fqsize; i ++)
-			
-		d->outBuf[i][0] = sqrt (getAmpSquareOfComplex(d->outBuf + i));
-
-	positionBlurFilter(d->outBuf, d->FreqFilter, d->wbest, d->hbest);
-
-	if (fi->subSamplingH != 0 || fi->subSamplingW != 0)
-	{
-		if (d->line)
-			DrawPSF(d->inBuf, d->line, d->xcoord >> subW, d->ycoord >> subH, d->wbestUV, d->hbestUV, 0.0);
-		else
-			DrawCircularPSFUV(d->inBuf, d->xcoord, d->wbestUV, d->hbestUV, subW, subH);
-					// forward transform
-		d->fftwf_execute(d->pfUV);
-		// make it zero phase
-		for (int i = 0; i < fqsizeUV; i++)
-
-			d->outBuf[i][0] = sqrt(getAmpSquareOfComplex(d->outBuf + i));
-
-		positionBlurFilter(d->outBuf, d->FreqFilterUV, d->wbestUV, d->hbestUV);
-
-	}
- 	
-	//d->fftwf_free(inBuf);
-	//d->fftwf_free(outBuf);
+    if(!ok) {
+        vsapi->setError(out, "vcm.fqblur: could not load any of the dll or get "
+                             "required fnctions");
+        // Error
+        // if (d->hinstLib != NULL)
+        //     FreeLibrary(d->hinstLib);
+        // Fix
+        if(d->hinstLib != nullptr) {
+#ifdef _WIN32
+            FreeLibrary((HINSTANCE) d->hinstLib);
+#else
+            dlclose(d->hinstLib);
+#endif
+        }
+
+        vsapi->freeNode(d->node);
+        return;
+    }
+
+    int nbits = fi->bitsPerSample;
+
+    int isize = d->hbest * d->wbest;
+    int fqsize = d->hbest * d->bestR;
+    int isizeUV = d->hbestUV * d->wbestUV;
+    int fqsizeUV = d->hbestUV * d->bestRUV;
+    // buffers
+    d->inBuf = (float *) d->fftwf_malloc(sizeof(float) * isize);
+
+    d->outBuf = (fftwf_complex *) d->fftwf_malloc(
+        sizeof(fftwf_complex) *
+        fqsize); // +1 is only a safeguard not really reqd
+
+    // creates forward and inverse fft plans
+
+    d->FreqFilter = (float *) d->fftwf_malloc(sizeof(float) * fqsize);
+
+    //  forward for padded size complex to complex
+    d->pf = d->fftwf_plan_dft_r2c_2d(d->hbest, d->wbest, d->inBuf, d->outBuf,
+                                     FFTW_MEASURE);
+    // inverse
+
+    d->pinv = d->fftwf_plan_dft_c2r_2d(d->hbest, d->wbest, d->outBuf, d->inBuf,
+                                       FFTW_MEASURE);
+
+    if(subH != 0 || subW != 0) {
+        d->FreqFilterUV = (float *) d->fftwf_malloc(sizeof(float) * fqsizeUV);
+        d->pfUV = d->fftwf_plan_dft_r2c_2d(d->hbestUV, d->wbestUV, d->inBuf,
+                                           d->outBuf, FFTW_MEASURE);
+        d->pinvUV = d->fftwf_plan_dft_c2r_2d(d->hbestUV, d->wbestUV, d->outBuf,
+                                             d->inBuf, FFTW_MEASURE);
+    } else {
+        d->FreqFilterUV = d->FreqFilter;
+        d->pfUV = d->pf;
+        d->pinvUV = d->pinv;
+    }
+
+    int count = DrawPSF(d->inBuf, d->line, d->xcoord, d->ycoord, d->wbest,
+                        d->hbest, 0.0); // we can add spike to mellow inversion
+                                        // forward transform
+    d->fftwf_execute(d->pf);
+    // make it zero phase
+    for(int i = 0; i < fqsize; i++)
 
+        d->outBuf[i][0] = sqrt(getAmpSquareOfComplex(d->outBuf + i));
+
+    positionBlurFilter(d->outBuf, d->FreqFilter, d->wbest, d->hbest);
+
+    if(fi->subSamplingH != 0 || fi->subSamplingW != 0) {
+        if(d->line)
+            DrawPSF(d->inBuf, d->line, d->xcoord >> subW, d->ycoord >> subH,
+                    d->wbestUV, d->hbestUV, 0.0);
+        else
+            DrawCircularPSFUV(d->inBuf, d->xcoord, d->wbestUV, d->hbestUV, subW,
+                              subH);
+        // forward transform
+        d->fftwf_execute(d->pfUV);
+        // make it zero phase
+        for(int i = 0; i < fqsizeUV; i++)
+
+            d->outBuf[i][0] = sqrt(getAmpSquareOfComplex(d->outBuf + i));
+
+        positionBlurFilter(d->outBuf, d->FreqFilterUV, d->wbestUV, d->hbestUV);
+    }
+
+    // d->fftwf_free(inBuf);
+    // d->fftwf_free(outBuf);
 }
 //--------------------------------------------------------------------------------------------
-void positionBlurFilter(fftwf_complex* fout, float* Filter, int bestx, int besty)
-{
-	float scale = 1.0f / (bestx * besty);
-
-	// transfer to filter buffer including scaling and removing filtering
-
-	for (int h = 0; h < besty; h++)
-	{
-		for (int w = 0; w < bestx / 2 + 1; w++)
-		{
-			Filter[w] = fout[w][0] * scale;
-		}
-		Filter += bestx / 2 + 1;
-		fout += bestx / 2 + 1;
-	}
-
+void positionBlurFilter(fftwf_complex *fout, float *Filter, int bestx,
+                        int besty) {
+    float scale = 1.0f / (bestx * besty);
+
+    // transfer to filter buffer including scaling and removing filtering
+
+    for(int h = 0; h < besty; h++) {
+        for(int w = 0; w < bestx / 2 + 1; w++) {
+            Filter[w] = fout[w][0] * scale;
+        }
+        Filter += bestx / 2 + 1;
+        fout += bestx / 2 + 1;
+    }
 }
 //--------------------------------------------------------------------------------------
 template <typename finc>
-void blurPlane2D(F2QBlurData * d, float * inBuf, fftwf_complex * outBuf, float * filter,
-	fftwf_plan pf, fftwf_plan pinv, const finc* sp, finc* dp,
-		 int pitch, int height, int width, int bestY, int bestX,  finc min, finc max )
-{
-	getRealInput2D(inBuf, sp, pitch, height, width, bestY, bestX, false);
+void blurPlane2D(F2QBlurData *d, float *inBuf, fftwf_complex *outBuf,
+                 float *filter, fftwf_plan pf, fftwf_plan pinv, const finc *sp,
+                 finc *dp, int pitch, int height, int width, int bestY,
+                 int bestX, finc min, finc max) {
+    getRealInput2D(inBuf, sp, pitch, height, width, bestY, bestX, false);
 
-	d->fftwf_execute_dft_r2c(pf, inBuf, outBuf);
+    d->fftwf_execute_dft_r2c(pf, inBuf, outBuf);
 
-	ApplyFilter2D(outBuf, filter, bestY, (bestX / 2 ) + 1);
+    ApplyFilter2D(outBuf, filter, bestY, (bestX / 2) + 1);
 
-	d->fftwf_execute_dft_c2r(pinv, outBuf, inBuf);
+    d->fftwf_execute_dft_c2r(pinv, outBuf, inBuf);
 
-	getRealOutput2D(inBuf, dp, pitch,
-		height, width, bestY, bestX, min, max);
+    getRealOutput2D(inBuf, dp, pitch, height, width, bestY, bestX, min, max);
 }
 
 //-----------------------------------------------------------------------------------------------
 
-// This is the main function that gets called when a frame should be produced. It will, in most cases, get
-// called several times to produce one frame. This state is being kept track of by the value of
-// activationReason. The first call to produce a certain frame n is always arInitial. In this state
-// you should request all the input frames you need. Always do it in ascending order to play nice with the
-// upstream filters.
-// Once all frames are ready, the filter will be called with arAllFramesReady. It is now time to
-// do the actual processing.
-static const VSFrameRef *VS_CC f2qblurGetFrame(int n, int activationReason, void **instanceData, 
-		void **frameData, VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) 
-{
-    F2QBlurData *d = (F2QBlurData *) * instanceData;
-
-    if (activationReason == arInitial) 
-	{
+// This is the main function that gets called when a frame should be produced.
+// It will, in most cases, get called several times to produce one frame. This
+// state is being kept track of by the value of activationReason. The first call
+// to produce a certain frame n is always arInitial. In this state you should
+// request all the input frames you need. Always do it in ascending order to
+// play nice with the upstream filters. Once all frames are ready, the filter
+// will be called with arAllFramesReady. It is now time to do the actual
+// processing.
+static const VSFrameRef *VS_CC f2qblurGetFrame(
+    int n, int activationReason, void **instanceData, void **frameData,
+    VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) {
+    F2QBlurData *d = (F2QBlurData *) *instanceData;
+
+    if(activationReason == arInitial) {
         // Request the source frame on the first call
         vsapi->requestFrameFilter(n, d->node, frameCtx);
-    } 
-	else if (activationReason == arAllFramesReady)	
-	{
+    } else if(activationReason == arAllFramesReady) {
 
         const VSFrameRef *src = vsapi->getFrameFilter(n, d->node, frameCtx);
-        // The reason we query this on a per frame basis is because we want our filter
-        // to accept clips with varying dimensions. If we reject such content using d->vi
-        // would be better.
+        // The reason we query this on a per frame basis is because we want our
+        // filter to accept clips with varying dimensions. If we reject such
+        // content using d->vi would be better.
         const VSFormat *fi = d->vi->format;
         int height = vsapi->getFrameHeight(src, 0);
         int width = vsapi->getFrameWidth(src, 0);
-        // When creating a new frame for output it is VERY EXTREMELY SUPER IMPORTANT to
-        // supply the "dominant" source frame to copy properties from. Frame props
-        // are an essential part of the filter chain and you should NEVER break it.
+        // When creating a new frame for output it is VERY EXTREMELY SUPER
+        // IMPORTANT to supply the "dominant" source frame to copy properties
+        // from. Frame props are an essential part of the filter chain and you
+        // should NEVER break it.
         VSFrameRef *dst = vsapi->copyFrame(src, core);
-		
-		//float* inBuf = d->inBuf; // vs_aligned_malloc <float>(sizeof(float) * d->wbest * d->hbest, 32);
 
-		//fftwf_complex* outBuf = d->outBuf;// vs_aligned_malloc<fftwf_complex>(sizeof(fftwf_complex) * (d->wbest / 2 + 1) * d->hbest, 64);
+        // float* inBuf = d->inBuf; // vs_aligned_malloc <float>(sizeof(float) *
+        // d->wbest * d->hbest, 32);
 
-		// It's processing loop time!
+        // fftwf_complex* outBuf = d->outBuf;//
+        // vs_aligned_malloc<fftwf_complex>(sizeof(fftwf_complex) * (d->wbest /
+        // 2 + 1) * d->hbest, 64);
+
+        // It's processing loop time!
         // Loop over all the planes
         int nplanes = fi->numPlanes > 3 ? 3 : fi->numPlanes;
 
-        for (int plane = 0; plane < nplanes; plane ++) 
-		{
-			
+        for(int plane = 0; plane < nplanes; plane++) {
+
             const uint8_t *sp = vsapi->getReadPtr(src, plane);
             int src_stride = vsapi->getStride(src, plane);
             uint8_t *dp = vsapi->getWritePtr(dst, plane);
-            int dst_stride = vsapi->getStride(dst, plane); // note that if a frame has the same dimensions and format, the stride is guaranteed to be the same. int dst_stride = src_stride would be fine too in this filter.
-            // Since planes may be subsampled you have to query the height of them individually
-            int height = vsapi->getFrameHeight(src, plane);            
+            int dst_stride = vsapi->getStride(
+                dst, plane); // note that if a frame has the same dimensions and
+                             // format, the stride is guaranteed to be the same.
+                             // int dst_stride = src_stride would be fine too in
+                             // this filter.
+            // Since planes may be subsampled you have to query the height of
+            // them individually
+            int height = vsapi->getFrameHeight(src, plane);
             int width = vsapi->getFrameWidth(src, plane);
-			int nbytes = fi->bytesPerSample;
-			int spitch = src_stride / nbytes;
-			int dpitch = dst_stride / nbytes;
-			
-		// process image	
-			if(fi->sampleType == stInteger)
-			{
-				if(fi->bitsPerSample == 8)
-				{
-					uint8_t min = 0;
-					uint8_t max = 255;
-
-					if (plane == 0)
-
-						blurPlane2D(d, d->inBuf, d->outBuf, d->FreqFilter,
-							d->pf, d->pinv, sp, dp,
-							spitch, height, width, d->hbest, d->wbest, min, max);
-					else
-						blurPlane2D(d, d->inBuf, d->outBuf, d->FreqFilterUV,
-							d->pfUV, d->pinvUV, sp, dp,
-							spitch, height, width, d->hbestUV, d->wbestUV, min, max);
-				}
-				else
-				{	// 16 bit data
-					int nbits = fi->bitsPerSample;
-					uint16_t min = 0;
-					uint16_t max = (1 << nbits) - 1;
-
-					const uint16_t *srcp = (uint16_t *) sp;
-					uint16_t * dstp = (uint16_t *) dp;
-
-					if (plane == 0)
-
-						blurPlane2D(d, d->inBuf, d->outBuf, d->FreqFilter,
-							d->pf, d->pinv, srcp, dstp,
-							spitch, height, width, d->hbest, d->wbest, min, max);
-					else
-
-						blurPlane2D(d, d->inBuf, d->outBuf, d->FreqFilterUV,
-							d->pfUV, d->pinvUV, srcp, dstp,
-							spitch, height, width, d->hbestUV, d->wbestUV, min, max);
-				}
-			}
-			else
-			{
-					// float data
-					float min = 0.0f;
-					float max = 1.0f;
-					if (fi->colorFamily == cmYUV && plane != 0)
-					{
-						min = -0.5f;
-						max = 0.5f;
-					}
-					const float *srcp = (float *) sp;
-					float * dstp = (float *) dp;
-
-					if (plane == 0)
-
-						blurPlane2D(d, d->inBuf, d->outBuf, d->FreqFilter,
-							d->pf, d->pinv, srcp, dstp,
-							spitch, height, width, d->hbest, d->wbest, min, max);
-					else
-
-						blurPlane2D(d, d->inBuf, d->outBuf, d->FreqFilterUV,
-							d->pfUV, d->pinvUV, srcp, dstp,
-							spitch, height, width, d->hbestUV, d->wbestUV, min, max);
-			}		
-
-		}
-	
-		 // Release the source frame
-        vsapi->freeFrame(src);		
-        // A reference is consumed when it is returned, so saving the dst reference somewhere
-        // and reusing it is not allowed.
+            int nbytes = fi->bytesPerSample;
+            int spitch = src_stride / nbytes;
+            int dpitch = dst_stride / nbytes;
+
+            // process image
+            if(fi->sampleType == stInteger) {
+                if(fi->bitsPerSample == 8) {
+                    uint8_t min = 0;
+                    uint8_t max = 255;
+
+                    if(plane == 0)
+
+                        blurPlane2D(d, d->inBuf, d->outBuf, d->FreqFilter,
+                                    d->pf, d->pinv, sp, dp, spitch, height,
+                                    width, d->hbest, d->wbest, min, max);
+                    else
+                        blurPlane2D(d, d->inBuf, d->outBuf, d->FreqFilterUV,
+                                    d->pfUV, d->pinvUV, sp, dp, spitch, height,
+                                    width, d->hbestUV, d->wbestUV, min, max);
+                } else { // 16 bit data
+                    int nbits = fi->bitsPerSample;
+                    uint16_t min = 0;
+                    uint16_t max = (1 << nbits) - 1;
+
+                    const uint16_t *srcp = (uint16_t *) sp;
+                    uint16_t *dstp = (uint16_t *) dp;
+
+                    if(plane == 0)
+
+                        blurPlane2D(d, d->inBuf, d->outBuf, d->FreqFilter,
+                                    d->pf, d->pinv, srcp, dstp, spitch, height,
+                                    width, d->hbest, d->wbest, min, max);
+                    else
+
+                        blurPlane2D(d, d->inBuf, d->outBuf, d->FreqFilterUV,
+                                    d->pfUV, d->pinvUV, srcp, dstp, spitch,
+                                    height, width, d->hbestUV, d->wbestUV, min,
+                                    max);
+                }
+            } else {
+                // float data
+                float min = 0.0f;
+                float max = 1.0f;
+                if(fi->colorFamily == cmYUV && plane != 0) {
+                    min = -0.5f;
+                    max = 0.5f;
+                }
+                const float *srcp = (float *) sp;
+                float *dstp = (float *) dp;
+
+                if(plane == 0)
+
+                    blurPlane2D(d, d->inBuf, d->outBuf, d->FreqFilter, d->pf,
+                                d->pinv, srcp, dstp, spitch, height, width,
+                                d->hbest, d->wbest, min, max);
+                else
+
+                    blurPlane2D(d, d->inBuf, d->outBuf, d->FreqFilterUV,
+                                d->pfUV, d->pinvUV, srcp, dstp, spitch, height,
+                                width, d->hbestUV, d->wbestUV, min, max);
+            }
+        }
+
+        // Release the source frame
+        vsapi->freeFrame(src);
+        // A reference is consumed when it is returned, so saving the dst
+        // reference somewhere and reusing it is not allowed.
         return dst;
-	}
+    }
 
-	return 0;					
-							
+    return 0;
 }
 //----------------------------------------------------------------
 // Free all allocated data on filter destruction
-static void VS_CC f2qblurFree(void *instanceData, VSCore *core, const VSAPI *vsapi) 
-{
-    F2QBlurData *d = (F2QBlurData *)instanceData;
-	if (d->FreqFilterUV != d->FreqFilter)
-		d->fftwf_free(d->FreqFilterUV);
-	d->fftwf_free(d->FreqFilter);
-	d->fftwf_free(d->inBuf);
-	d->fftwf_free(d->outBuf);
-	if (d->pf != d->pfUV)
-		d->fftwf_destroy_plan(d->pfUV);
-	d->fftwf_destroy_plan(d->pf);
-	if (d->pinv != d->pinvUV)
-		d->fftwf_destroy_plan(d->pinvUV);
-	d->fftwf_destroy_plan(d->pinv);
-
-	FreeLibrary(d->hinstLib);
-    vsapi->freeNode(d->node);
+static void VS_CC f2qblurFree(void *instanceData, VSCore *core,
+                              const VSAPI *vsapi) {
+    F2QBlurData *d = (F2QBlurData *) instanceData;
+    if(d->FreqFilterUV != d->FreqFilter)
+        d->fftwf_free(d->FreqFilterUV);
+    d->fftwf_free(d->FreqFilter);
+    d->fftwf_free(d->inBuf);
+    d->fftwf_free(d->outBuf);
+    if(d->pf != d->pfUV)
+        d->fftwf_destroy_plan(d->pfUV);
+    d->fftwf_destroy_plan(d->pf);
+    if(d->pinv != d->pinvUV)
+        d->fftwf_destroy_plan(d->pinvUV);
+    d->fftwf_destroy_plan(d->pinv);
+    // Error
+    // FreeLibrary(d->hinstLib);
+    // Fix
+    if(d->hinstLib != nullptr) {
+#ifdef _WIN32
+        FreeLibrary((HINSTANCE) d->hinstLib);
+#else
+        dlclose(d->hinstLib);
+#endif
+    }
 
+    vsapi->freeNode(d->node);
     free(d);
 }
 
-
 /***************************************************************/
 
-
-// This function is responsible for validating arguments and creating a new filter
-static void VS_CC f2qblurCreate(const VSMap *in, VSMap *out, void *userData, VSCore *core, const VSAPI *vsapi) 
-{
+// This function is responsible for validating arguments and creating a new
+// filter
+static void VS_CC f2qblurCreate(const VSMap *in, VSMap *out, void *userData,
+                                VSCore *core, const VSAPI *vsapi) {
     F2QBlurData d;
     F2QBlurData *data;
     int err;
-	int temp;
+    int temp;
     // Get a clip reference from the input arguments. This must be freed later.
     d.node = vsapi->propGetNode(in, "clip", 0, 0);
     d.vi = vsapi->getVideoInfo(d.node);
 
-    // In this first version we only want to handle 8bit integer formats. Note that
-    // vi->format can be 0 if the input clip can change format midstream.
-    if (!isConstantFormat(d.vi)  )
-	{
-        vsapi->setError(out, "F2QBlur: clip must have constant dimensions and in YUV or RGB or Grey format  ");
+    // In this first version we only want to handle 8bit integer formats. Note
+    // that vi->format can be 0 if the input clip can change format midstream.
+    if(!isConstantFormat(d.vi)) {
+        vsapi->setError(out, "F2QBlur: clip must have constant dimensions and "
+                             "in YUV or RGB or Grey format  ");
+        vsapi->freeNode(d.node);
+        return;
+    }
+    if(d.vi->format->colorFamily != cmRGB &&
+       d.vi->format->colorFamily != cmYUV &&
+       d.vi->format->colorFamily != cmGray) {
+        vsapi->setError(
+            out,
+            "F2QBlur: RGB, YUV and Gray color formats only for input allowed ");
+        vsapi->freeNode(d.node);
+        return;
+    }
+    if(d.vi->format->sampleType == stFloat &&
+       d.vi->format->bitsPerSample == 16) {
+        vsapi->setError(out, "F2QBlur: Half float formats not allowed ");
         vsapi->freeNode(d.node);
         return;
     }
-	if (d.vi->format->colorFamily != cmRGB && d.vi->format->colorFamily != cmYUV && d.vi->format->colorFamily != cmGray)
-	{
-		vsapi->setError(out, "F2QBlur: RGB, YUV and Gray color formats only for input allowed ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-	if (d.vi->format->sampleType == stFloat && d.vi->format->bitsPerSample == 16)
-	{
-		vsapi->setError(out, "F2QBlur: Half float formats not allowed ");
-		vsapi->freeNode(d.node);
-		return;
-	}
 
     // If a property read fails for some reason (index out of bounds/wrong type)
     // then err will have flags set to indicate why and 0 will be returned. This
@@ -425,88 +437,86 @@ static void VS_CC f2qblurCreate(const VSMap *in, VSMap *out, void *userData, VSC
     // reason this could fail is when the value wasn't set by the user.
     // And when it's not set we want it to default to enabled.
     temp = !!int64ToIntS(vsapi->propGetInt(in, "line", 0, &err));
-    if (err)
-	{
+    if(err) {
         d.line = true;
-	}
-	else
-    // Let's pretend the only allowed values are 1 or 0...
-		if (temp < 0 || temp > 1)
-	{
-		vsapi->setError(out, "F2QBlur: line must be 0 (for circular blur) 1(for linear blur) ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-	else
-	{
-		if( temp == 1)
-			d.line = true;
-		else
-			d.line = false;
-	}
-	
-
-	d.xcoord = int64ToIntS(vsapi->propGetInt(in, "x", 0, &err));
-    if (err)
-	{
+    } else
+        // Let's pretend the only allowed values are 1 or 0...
+        if(temp < 0 || temp > 1) {
+            vsapi->setError(out, "F2QBlur: line must be 0 (for circular blur) "
+                                 "1(for linear blur) ");
+            vsapi->freeNode(d.node);
+            return;
+        } else {
+            if(temp == 1)
+                d.line = true;
+            else
+                d.line = false;
+        }
+
+    d.xcoord = int64ToIntS(vsapi->propGetInt(in, "x", 0, &err));
+    if(err) {
         d.xcoord = 2;
-	}
-	else
-    //  the only allowed values are 
-		if ( (d.line && d.xcoord < 0) || d.xcoord > d.vi->width / 8 || ( !d.line && d.xcoord < 1))
-	{
-		vsapi->setError(out, "F2QBlur: x coordinate can have a value from 0 for line and 1 for circular blur to 1/8th frame width only ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-
-	d.ycoord = int64ToIntS(vsapi->propGetInt(in, "y", 0, &err));
-    if (err)
-	{
+    } else
+        //  the only allowed values are
+        if((d.line && d.xcoord < 0) || d.xcoord > d.vi->width / 8 ||
+           (!d.line && d.xcoord < 1)) {
+            vsapi->setError(
+                out, "F2QBlur: x coordinate can have a value from 0 for line "
+                     "and 1 for circular blur to 1/8th frame width only ");
+            vsapi->freeNode(d.node);
+            return;
+        }
+
+    d.ycoord = int64ToIntS(vsapi->propGetInt(in, "y", 0, &err));
+    if(err) {
         d.ycoord = 2;
-	}
-	else
-    //  the only allowed values are 
-		if ( d.ycoord <  - d.vi->height / 8 ||  d.ycoord  > d.vi->height / 8)
-	{
-		vsapi->setError(out, "F2QBlur: y coordinate can have a value between plus and minus 1/8th frame height only ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-	if ( d.xcoord == 0 && d.ycoord == 0)
-	{
-		vsapi->setError(out, "F2QBlur: both x and y coordinate must not be zeroes ");
-		vsapi->freeNode(d.node);
-		return;
-	}
+    } else
+        //  the only allowed values are
+        if(d.ycoord < -d.vi->height / 8 || d.ycoord > d.vi->height / 8) {
+            vsapi->setError(out,
+                            "F2QBlur: y coordinate can have a value between "
+                            "plus and minus 1/8th frame height only ");
+            vsapi->freeNode(d.node);
+            return;
+        }
+    if(d.xcoord == 0 && d.ycoord == 0) {
+        vsapi->setError(out,
+                        "F2QBlur: both x and y coordinate must not be zeroes ");
+        vsapi->freeNode(d.node);
+        return;
+    }
 
     // I usually keep the filter data struct on the stack and don't allocate it
     // until all the input validation is done.
-    data = (F2QBlurData*)malloc(sizeof(d));
+    data = (F2QBlurData *) malloc(sizeof(d));
     *data = d;
 
-    // Creates a new filter and returns a reference to it. Always pass on the in and out
-    // arguments or unexpected things may happen. The name should be something that's
-    // easy to connect to the filter, like its function name.
-    // The three function pointers handle initialization, frame processing and filter destruction.
-    // The filtermode is very important to get right as it controls how threading of the filter
-    // is handled. In general you should only use fmParallel whenever possible. This is if you
-    // need to modify no shared data at all when the filter is running.
-    // For more complicated filters, fmParallelRequests is usually easier to achieve as it can
-    // be prefetched in parallel but the actual processing is serialized.
-    // The others can be considered special cases where fmSerial is useful to source filters and
-    // fmUnordered is useful when a filter's state may change even when deciding which frames to
-    // prefetch (such as a cache filter).
-    // If your filter is really fast (such as a filter that only resorts frames) you should set the
-    // nfNoCache flag to make the caching work smoother.
-
-    vsapi->createFilter(in, out, "F2QBlur", f2qblurInit, f2qblurGetFrame, f2qblurFree, fmParallelRequests, 0, data, core);
-
+    // Creates a new filter and returns a reference to it. Always pass on the in
+    // and out arguments or unexpected things may happen. The name should be
+    // something that's easy to connect to the filter, like its function name.
+    // The three function pointers handle initialization, frame processing and
+    // filter destruction. The filtermode is very important to get right as it
+    // controls how threading of the filter is handled. In general you should
+    // only use fmParallel whenever possible. This is if you need to modify no
+    // shared data at all when the filter is running. For more complicated
+    // filters, fmParallelRequests is usually easier to achieve as it can be
+    // prefetched in parallel but the actual processing is serialized. The
+    // others can be considered special cases where fmSerial is useful to source
+    // filters and fmUnordered is useful when a filter's state may change even
+    // when deciding which frames to prefetch (such as a cache filter). If your
+    // filter is really fast (such as a filter that only resorts frames) you
+    // should set the nfNoCache flag to make the caching work smoother.
+
+    vsapi->createFilter(in, out, "F2QBlur", f2qblurInit, f2qblurGetFrame,
+                        f2qblurFree, fmParallelRequests, 0, data, core);
 }
 /*
-// The following function is the function that actually registers the filter in AviSynth
-// It is called automatically, when the plugin is loaded to see which functions this filter contains.
+// The following function is the function that actually registers the filter in
+AviSynth
+// It is called automatically, when the plugin is loaded to see which functions
+this filter contains.
 
 
-    registerFunc("fqBlur", "clip:clip;line:int:opt;x:int:opt;y:int:opt;", Create_FQRestore, 0);
-*/			
+    registerFunc("fqBlur", "clip:clip;line:int:opt;x:int:opt;y:int:opt;",
+Create_FQRestore, 0);
+*/
diff --git a/FQCorrelation.cpp b/FQCorrelation.cpp
index a54cdc5..e4f19af 100644
--- a/FQCorrelation.cpp
+++ b/FQCorrelation.cpp
@@ -3,8 +3,8 @@ Correlation filter plugin for vapoursynth( 32 & 64 bit) by V.C.Mohan
 This filter operates in freq domain (2d), takes 2 clips A and B as input
 and  displays  cross correlation of A and B clips.
 
-This plugin needs any one of libfftw3f-3.dll 32bit and 64bit of FFTW.org to reside in path
-(may be windows\system32 folder, or wow)
+This plugin needs any one of libfftw3f-3.dll 32bit and 64bit of FFTW.org to
+reside in path (may be windows\system32 folder, or wow)
 
 Author V.C.Mohan.
 28 July 2020, 22 May 2021
@@ -22,588 +22,592 @@ GNU General Public License for more details.
 
 A copy of the GNU General Public License is at
 see <http://www.gnu.org/licenses/>.
-For details of how to contact author see <http://www.avisynth.nl/users/vcmohan/vcmohan.html>
+For details of how to contact author see
+<http://www.avisynth.nl/users/vcmohan/vcmohan.html>
 ********************************************************************************/
 
 /*
-#include "windows.h"
-#include <stdlib.h>
 #include "vapoursynth.h"
 #include "vshelper.h"
+#include "windows.h"
 #include <complex>
 #include  <math.h>
+#include <stdlib.h>
 //#include "fftw3.h"	// fftwlite used instead as I can understand it
-#include "fftwlite.h"
 #include "Factorize.cpp"
+#include "fftwlite.h"
 #define NYQUIST 512		// arbitrary definition of Nyquist spatial frequency
 */
 
 #include <stdio.h>
-typedef struct
-{
-	VSNodeRef *node[2];
-	VSVideoInfo vi;
-	const VSVideoInfo *avi;
-	// float gamma;			// correlation scaling. Not used		
-	bool center;			// display centered on frame? else left top corner reference
-	bool txt;				// is a correlation file with x and y to be created?
-	const char * filename;	// file having x and y  in text format. name of text output file with full path
-	FILE *ofile;	// 
-	int cx, cy;				// max search window for correlation width max +- x, height max +- y
-	int sf, ef, every;
-	int wbest;				// nearest higher width for best speed of fft
-	int hbest;				// nearest higher height for best speed of fft
-	int freqWidth;			// freq width for real data will be  wbest / 2 + 1.and used for filter design 
-	int f2size;
-	//int * fbuf;			//  x and y coord of max corr for each frame are stored here.
-	
-	fftwf_plan  pf, pinv;	// forward and inverse fft plansnal float[2] format.
+typedef struct {
+    VSNodeRef *node[2];
+    VSVideoInfo vi;
+    const VSVideoInfo *avi;
+    // float gamma;			// correlation scaling. Not used
+    bool center; // display centered on frame? else left top corner reference
+    bool txt;    // is a correlation file with x and y to be created?
+    const char *filename; // file having x and y  in text format. name of text
+                          // output file with full path
+    FILE *ofile;          //
+    int cx,
+        cy; // max search window for correlation width max +- x, height max +- y
+    int sf, ef, every;
+    int wbest;     // nearest higher width for best speed of fft
+    int hbest;     // nearest higher height for best speed of fft
+    int freqWidth; // freq width for real data will be  wbest / 2 + 1.and used
+                   // for filter design
+    int f2size;
+    // int * fbuf;			//  x and y coord of max corr for each frame are
+    // stored here.
+
+    fftwf_plan pf, pinv; // forward and inverse fft plansnal float[2] format.
 #include "fftLateBindingClassParams.cpp"
-	float* inBuf;
-	fftwf_complex* outBuf;
-	fftwf_complex* Bfreq;
-}F2QCorrData;
+    float *inBuf;
+    fftwf_complex *outBuf;
+    fftwf_complex *Bfreq;
+} F2QCorrData;
 //------------------------------------------------------------------
-	
-	void xCorrelate(fftwf_complex* Afreq, fftwf_complex* Bfreq, int frqwidth, int hbest, bool center);
-	int xNormGamma(float * buf, int size);
 
-	template <typename finc>
-	void xTransferToDst(finc * dp, int dpitch, 
-		int dwd, int dht, float * buf, int bestwd, int bestht, finc max);
-	template <typename finc>
-	int xFullProcess(F2QCorrData *d, 
-		finc * dp, const finc * ap, const finc * bp, int abpitch, 
-		int pwd, int pht, int dpitch, finc max);
-	template <typename finc>
-	void drawOrigin(float* inBuf, int wbest, int hbest, finc val);
+void xCorrelate(fftwf_complex *Afreq, fftwf_complex *Bfreq, int frqwidth,
+                int hbest, bool center);
+int xNormGamma(float *buf, int size);
 
+template <typename finc>
+void xTransferToDst(finc *dp, int dpitch, int dwd, int dht, float *buf,
+                    int bestwd, int bestht, finc max);
+template <typename finc>
+int xFullProcess(F2QCorrData *d, finc *dp, const finc *ap, const finc *bp,
+                 int abpitch, int pwd, int pht, int dpitch, finc max);
+template <typename finc>
+void drawOrigin(float *inBuf, int wbest, int hbest, finc val);
 
 /*************************************************
-* The following is the implementation
-* of the defined functions.
-*************************************************/
-//Here is the acutal constructor code used
-
-static void VS_CC f2qcorrInit(VSMap *in, VSMap *out, void **instanceData, VSNode *node, VSCore *core, const VSAPI *vsapi)
-{
-	F2QCorrData *d = (F2QCorrData *)* instanceData;
-	//vsapi->setVideoInfo(d->vi, 1, node);	
-	const int fht = ((d->avi->height + 3) >> 2) << 2;
-	const int fwd = ((d->avi->width + 3) >> 2) << 2;
-	int* facbuf = (int*)vs_aligned_malloc(sizeof(int) * 64, 32);
-	
-	d->wbest = getBestDim(fwd, facbuf);
-	d->hbest = getBestDim(fht, facbuf);
-	vs_aligned_free(facbuf);
-	d->vi.height = d->hbest;
-	d->vi.width = d->wbest;
-	d->vi.format = d->avi->format;
-	d->vi.numFrames = d->avi->numFrames;
-	d->vi.fpsDen = d->avi->fpsDen;
-	d->vi.fpsNum = d->avi->fpsNum;
-	d->vi.flags = d->avi->flags;
-	vsapi->setVideoInfo(&d->vi, 1, node);
-	d->freqWidth = d->wbest / 2 + 1;	// for real data this is the output width in the first transform
-
-	d->f2size = d->hbest * d->freqWidth;
- 	if (d->txt)
-	{		
-		errno_t err = fopen_s(&d->ofile, d->filename, "w");
-		if (err != 0)
-		{
-			vsapi->setError(out, "FQCorr:init: could not open output text file");
-			vsapi->freeNode(d->node[0]);
-			vsapi->freeNode(d->node[1]);
-			free(d);
-			return;
-		}
-		// heading and explanation of file
-		fprintf(d->ofile, "Correlation Shifts determined between sf = %d and ef = %d at intervals of %d \n",
-			d->sf, d->ef, d->every);
-		fprintf(d->ofile, " Frame number fn, x shift, y shift in search area and fx and fy shifts in frame\n");
-		fprintf(d->ofile, " fn\tx\ty\tfx\tfy\n");
-	
-	}
+ * The following is the implementation
+ * of the defined functions.
+ *************************************************/
+// Here is the acutal constructor code used
+
+static void VS_CC f2qcorrInit(VSMap *in, VSMap *out, void **instanceData,
+                              VSNode *node, VSCore *core, const VSAPI *vsapi) {
+    F2QCorrData *d = (F2QCorrData *) *instanceData;
+    // vsapi->setVideoInfo(d->vi, 1, node);
+    const int fht = ((d->avi->height + 3) >> 2) << 2;
+    const int fwd = ((d->avi->width + 3) >> 2) << 2;
+    int *facbuf = (int *) vs_aligned_malloc(sizeof(int) * 64, 32);
+
+    d->wbest = getBestDim(fwd, facbuf);
+    d->hbest = getBestDim(fht, facbuf);
+    vs_aligned_free(facbuf);
+    d->vi.height = d->hbest;
+    d->vi.width = d->wbest;
+    d->vi.format = d->avi->format;
+    d->vi.numFrames = d->avi->numFrames;
+    d->vi.fpsDen = d->avi->fpsDen;
+    d->vi.fpsNum = d->avi->fpsNum;
+    d->vi.flags = d->avi->flags;
+    vsapi->setVideoInfo(&d->vi, 1, node);
+    d->freqWidth =
+        d->wbest / 2 +
+        1; // for real data this is the output width in the first transform
+
+    d->f2size = d->hbest * d->freqWidth;
+    if(d->txt) {
+// Error
+// errno_t err = fopen_s(&d->ofile, d->filename, "w");
+// if (err != 0)
+// {
+//     vsapi->setError(out, "FQCorr:init: could not open output text file");
+//     vsapi->freeNode(d->node[0]);
+//     vsapi->freeNode(d->node[1]);
+//     free(d);
+//     return;
+// }
+// Fix
+#ifdef _WIN32
+        errno_t err = fopen_s(&d->ofile, d->filename, "w");
+        if(err != 0) {
+            vsapi->setError(out,
+                            "FQCorr:init: could not open output text file");
+            vsapi->freeNode(d->node[0]);
+            vsapi->freeNode(d->node[1]);
+            free(d);
+            return;
+        }
+#else
+        d->ofile = fopen(d->filename, "w");
+        if(!d->ofile) {
+            vsapi->setError(out,
+                            "FQCorr:init: could not open output text file");
+            vsapi->freeNode(d->node[0]);
+            vsapi->freeNode(d->node[1]);
+            free(d);
+            return;
+        }
+#endif
+        // heading and explanation of file
+        fprintf(d->ofile,
+                "Correlation Shifts determined between sf = %d and ef = %d at "
+                "intervals of %d \n",
+                d->sf, d->ef, d->every);
+        fprintf(d->ofile, " Frame number fn, x shift, y shift in search area "
+                          "and fx and fy shifts in frame\n");
+        fprintf(d->ofile, " fn\tx\ty\tfx\tfy\n");
+    }
 #include "ConstructorCodeForLateBindingfft.cpp"
 
-	if (!ok)
-	{
-		vsapi->setError(out, "FQCorr: could not load fft dll");
-		vsapi->freeNode(d->node[0]);
-		vsapi->freeNode(d->node[1]);
-		if (d->txt && d->ofile != NULL)
-			fclose(d->ofile);
-		free (d);
-		return;
-	}
-	// buffers 
-	d->inBuf = (float*)d->fftwf_malloc(sizeof(float) * d->wbest * d->hbest);
-	d->outBuf = (fftwf_complex*)d->fftwf_malloc(sizeof(fftwf_complex) * d->f2size);
-	d->Bfreq = (fftwf_complex*)d->fftwf_malloc(sizeof(fftwf_complex) * d->f2size);
-
-	
-	// We require forward  and inverse transform plans.
-	d->pf = d->fftwf_plan_dft_r2c_2d(d->hbest, d->wbest, d->inBuf, d->outBuf, FFTW_ESTIMATE);
-	// inverse so complex to real used
-	d->pinv = d->fftwf_plan_dft_c2r_2d(d->hbest, d->wbest, d->outBuf, d->inBuf, FFTW_ESTIMATE);	
-	
+    if(!ok) {
+        vsapi->setError(out, "FQCorr: could not load fft dll");
+        vsapi->freeNode(d->node[0]);
+        vsapi->freeNode(d->node[1]);
+        if(d->txt && d->ofile != NULL)
+            fclose(d->ofile);
+        free(d);
+        return;
+    }
+    // buffers
+    d->inBuf = (float *) d->fftwf_malloc(sizeof(float) * d->wbest * d->hbest);
+    d->outBuf =
+        (fftwf_complex *) d->fftwf_malloc(sizeof(fftwf_complex) * d->f2size);
+    d->Bfreq =
+        (fftwf_complex *) d->fftwf_malloc(sizeof(fftwf_complex) * d->f2size);
+
+    // We require forward  and inverse transform plans.
+    d->pf = d->fftwf_plan_dft_r2c_2d(d->hbest, d->wbest, d->inBuf, d->outBuf,
+                                     FFTW_ESTIMATE);
+    // inverse so complex to real used
+    d->pinv = d->fftwf_plan_dft_c2r_2d(d->hbest, d->wbest, d->outBuf, d->inBuf,
+                                       FFTW_ESTIMATE);
 }
 
 //-----------------------------------------------------------------------------------------------------------
 
-void xCorrelate(fftwf_complex* Afreq, fftwf_complex* Bfreq, float scale, int frqwidth, int hbest, bool center)
-{
-	// float scale = 1.0 / (wbest * hbest);
-	// complex multiply with conjugate and scale down to compensate fft upscaling
-	int fsize = hbest * frqwidth;
-	float real, imag;	
-	int wi = 1;
-	if (center)
-	{
-		for (int n = 0; n < fsize; n++)
-		{
-			real = (Afreq[n][0] * Bfreq[n][0] + Afreq[n][1] * Bfreq[n][1]) * scale;
-			imag = (Afreq[n][0] * Bfreq[n][1] - Afreq[n][1] * Bfreq[n][0]) * scale;
-			Afreq[n][0] = real * wi;
-			Afreq[n][1] = imag * wi;
-			wi = -wi;
-		}		
-	}
-	else // no centering
-	{		
-
-		for (int n = 0; n < fsize; n++)
-		{
-			real = (Afreq[n][0] * Bfreq[n][0] + Afreq[n][1] * Bfreq[n][1]) * scale;
-			imag = (Afreq[n][0] * Bfreq[n][1] - Afreq[n][1] * Bfreq[n][0]) * scale;
-			Afreq[n][0] = real ;
-			Afreq[n][1] = imag ;
-			
-		}
-	}
+void xCorrelate(fftwf_complex *Afreq, fftwf_complex *Bfreq, float scale,
+                int frqwidth, int hbest, bool center) {
+    // float scale = 1.0 / (wbest * hbest);
+    // complex multiply with conjugate and scale down to compensate fft
+    // upscaling
+    int fsize = hbest * frqwidth;
+    float real, imag;
+    int wi = 1;
+    if(center) {
+        for(int n = 0; n < fsize; n++) {
+            real =
+                (Afreq[n][0] * Bfreq[n][0] + Afreq[n][1] * Bfreq[n][1]) * scale;
+            imag =
+                (Afreq[n][0] * Bfreq[n][1] - Afreq[n][1] * Bfreq[n][0]) * scale;
+            Afreq[n][0] = real * wi;
+            Afreq[n][1] = imag * wi;
+            wi = -wi;
+        }
+    } else // no centering
+    {
+
+        for(int n = 0; n < fsize; n++) {
+            real =
+                (Afreq[n][0] * Bfreq[n][0] + Afreq[n][1] * Bfreq[n][1]) * scale;
+            imag =
+                (Afreq[n][0] * Bfreq[n][1] - Afreq[n][1] * Bfreq[n][0]) * scale;
+            Afreq[n][0] = real;
+            Afreq[n][1] = imag;
+        }
+    }
 }
 //---------------------------------------------------------------------------
-int xNormGamma(float * buf,  int size)
-{
-	float maximum = buf[0];
-	float minimum = buf[0];
-	int xyPlus = 0;
-	// get min and max values
-	for (int n = 0; n < size; n++)
-	{
-		if (maximum < buf[n])
-		{
-			maximum = buf[n];
-			xyPlus = n;
-		}
-		else if (minimum > buf[n])
-			minimum = buf[n];
-	}
-	// normalize. Avoid divide by zero.
-	if (maximum > minimum)
-	{
-		float mult = 1.0f / (maximum - minimum);	// mult is faster than div
-
-		for (int n = 0; n < size; n++)
-		{
-			// for some reason this gamma if more than 1 does not work 
-			// I expect normalized values less than 1 should become much less in value for gamma more than 1, but remain 1.0. Why? 
-		//	buf[n] = pow((buf[n] - minimum) * mult, gamma);
-			buf[n] = (buf[n] - minimum) * mult;
-		}
-	}
-
-	else
-	{
-		for (int n = 0; n < size; n++)
-			buf[n] = 0;
-
-	}
-
-	return xyPlus;
+int xNormGamma(float *buf, int size) {
+    float maximum = buf[0];
+    float minimum = buf[0];
+    int xyPlus = 0;
+    // get min and max values
+    for(int n = 0; n < size; n++) {
+        if(maximum < buf[n]) {
+            maximum = buf[n];
+            xyPlus = n;
+        } else if(minimum > buf[n])
+            minimum = buf[n];
+    }
+    // normalize. Avoid divide by zero.
+    if(maximum > minimum) {
+        float mult = 1.0f / (maximum - minimum); // mult is faster than div
+
+        for(int n = 0; n < size; n++) {
+            // for some reason this gamma if more than 1 does not work
+            // I expect normalized values less than 1 should become much less in
+            // value for gamma more than 1, but remain 1.0. Why?
+            //	buf[n] = pow((buf[n] - minimum) * mult, gamma);
+            buf[n] = (buf[n] - minimum) * mult;
+        }
+    }
+
+    else {
+        for(int n = 0; n < size; n++)
+            buf[n] = 0;
+    }
+
+    return xyPlus;
 }
 //---------------------------------------------------------------------------------------------
-template<typename finc>
-void xTransferToDst(finc * dp, int dpitch, 
-	int dwd, int dht, float * buf, int bestwd, int bestht, finc max)
-{
-	for (int h = 0; h < dht; h++)
-	{		
-		for (int w = 0; w < dwd; w++)
-		{
-			dp[w] = (finc)(buf[w] * max);	// converts normalized data to actual values
-		}
-		dp += dpitch;
-		buf += bestwd;
-	}
+template <typename finc>
+void xTransferToDst(finc *dp, int dpitch, int dwd, int dht, float *buf,
+                    int bestwd, int bestht, finc max) {
+    for(int h = 0; h < dht; h++) {
+        for(int w = 0; w < dwd; w++) {
+            dp[w] = (finc) (buf[w] *
+                            max); // converts normalized data to actual values
+        }
+        dp += dpitch;
+        buf += bestwd;
+    }
 }
 template <typename finc>
-void drawOrigin(float* inBuf, int wbest, int hbest, finc val)
-{
-	int origin = hbest / 2 * wbest + wbest / 2;
-
-	int length = 20;
-	for (int i = -length; i < length; i++)
-		inBuf[origin + i * wbest] = val;
-	for (int i = -length; i < length; i++)
-		inBuf[origin + i ] = val;
-
+void drawOrigin(float *inBuf, int wbest, int hbest, finc val) {
+    int origin = hbest / 2 * wbest + wbest / 2;
+
+    int length = 20;
+    for(int i = -length; i < length; i++)
+        inBuf[origin + i * wbest] = val;
+    for(int i = -length; i < length; i++)
+        inBuf[origin + i] = val;
 }
 //--------------------------------------------------------------------------------------------
 template <typename finc>
-int xFullProcess(F2QCorrData* d,  // forward fft of the two input frames
-	finc * dp, 	// output frame
-	const finc * ap,  const finc * bp, int abpitch, // input A and B frames, pitch of frames
-	int pwd, int pht, int dpitch, finc max) //  frame dimensions and max pixel value
-		// dimensions computed as best used for fft
+int xFullProcess(F2QCorrData *d, // forward fft of the two input frames
+                 finc *dp,       // output frame
+                 const finc *ap, const finc *bp,
+                 int abpitch, // input A and B frames, pitch of frames
+                 int pwd, int pht, int dpitch,
+                 finc max) //  frame dimensions and max pixel value
+                           // dimensions computed as best used for fft
 
 {
-	// transfer A frame data to fft input float buffer
-	getRealInput2D(d->inBuf, ap, abpitch, pht, pwd, d->hbest, d->wbest, false);
-	
-	// 2d forward transform into Afreq complex buffer
-	d->fftwf_execute_dft_r2c(d->pf, d->inBuf, d->outBuf);
-	// transfer B Frame data to fft input float buffer
-	getRealInput2D(d->inBuf, bp, abpitch, pht, pwd, d->hbest, d->wbest, false);
-	
-	// 2d forward transform into Bfreq complex buffer
- 	d->fftwf_execute_dft_r2c(d->pf, d->inBuf, d->Bfreq);
-	// as during fft scaleup occurs, need to scale down
-	float scale = 1.0f / (d->wbest * d->hbest);	
-	// cross correlation in freq domain is multiplication. Result in Afreq 
-	xCorrelate(d->outBuf, d->Bfreq, scale, d->hbest, d->freqWidth, true);
-	// inverse fft
-	d->fftwf_execute(d->pinv);
-	// normalize and apply gamma scaling. gamma part deleted as not working per expectation.
-	int xyPlus = xNormGamma(d->inBuf, d->wbest * d->hbest);
-	// transfer data to output frame
-	//xTransferToDst(dp, abpitch, pwd, pht, d->inBuf, d->wbest, d->hbest, max);
-	xTransferToDst(dp, dpitch, d->wbest, d->hbest, d->inBuf, d->wbest, d->hbest, max);
-	
-	return xyPlus;
+    // transfer A frame data to fft input float buffer
+    getRealInput2D(d->inBuf, ap, abpitch, pht, pwd, d->hbest, d->wbest, false);
+
+    // 2d forward transform into Afreq complex buffer
+    d->fftwf_execute_dft_r2c(d->pf, d->inBuf, d->outBuf);
+    // transfer B Frame data to fft input float buffer
+    getRealInput2D(d->inBuf, bp, abpitch, pht, pwd, d->hbest, d->wbest, false);
+
+    // 2d forward transform into Bfreq complex buffer
+    d->fftwf_execute_dft_r2c(d->pf, d->inBuf, d->Bfreq);
+    // as during fft scaleup occurs, need to scale down
+    float scale = 1.0f / (d->wbest * d->hbest);
+    // cross correlation in freq domain is multiplication. Result in Afreq
+    xCorrelate(d->outBuf, d->Bfreq, scale, d->hbest, d->freqWidth, true);
+    // inverse fft
+    d->fftwf_execute(d->pinv);
+    // normalize and apply gamma scaling. gamma part deleted as not working per
+    // expectation.
+    int xyPlus = xNormGamma(d->inBuf, d->wbest * d->hbest);
+    // transfer data to output frame
+    // xTransferToDst(dp, abpitch, pwd, pht, d->inBuf, d->wbest, d->hbest, max);
+    xTransferToDst(dp, dpitch, d->wbest, d->hbest, d->inBuf, d->wbest, d->hbest,
+                   max);
+
+    return xyPlus;
 }
 
 //---------------------------------------------------------------------------------------------
-static const VSFrameRef *VS_CC f2qcorrGetFrame(int n, int activationReason, void **instanceData,
-	void **frameData, VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi)
-{
-	F2QCorrData *d = (F2QCorrData *)* instanceData;
-
-	if (activationReason == arInitial) {
-		// Request the source frames on the first call
-		vsapi->requestFrameFilter(n, d->node[0], frameCtx);
-		vsapi->requestFrameFilter(n, d->node[1], frameCtx);
-	}
-	else if (activationReason == arAllFramesReady)
-	{
-		const VSFrameRef *srcA = vsapi->getFrameFilter(n, d->node[0], frameCtx);
-		const VSFrameRef *srcB = vsapi->getFrameFilter(n, d->node[1], frameCtx);
-		// The reason we query this on a per frame basis is because we want our filter
-		// to accept clips with varying dimensions. If we reject such content using d->vi
-		// would be better.
-		
-		int ht = vsapi->getFrameHeight(srcA, 0);
-		int wd = vsapi->getFrameWidth(srcA, 0);
-		int owd = d->vi.width;
-		int oht = d->vi.height;
-		//VSFrameRef *dst;
-		const VSFormat *fi = d->vi.format;
-		VSFrameRef *dst = vsapi->newVideoFrame(fi, owd, oht, srcA, core);
-				// use green for RGB and Y for YUV
-		int plane = fi->colorFamily == cmRGB ? 1 : 0;	
-
-		const uint8_t *srcpA = vsapi->getReadPtr(srcA, plane);
-		const uint8_t *srcpB = vsapi->getReadPtr(srcB, plane);
-		int src_stride = vsapi->getStride(srcA, plane);
-		int dst_stride = vsapi->getStride(dst, plane);
-		uint8_t *dstp = vsapi->getWritePtr(dst, plane);
-		int pitch = src_stride / fi->bytesPerSample;
-		int dpitch = dst_stride / fi->bytesPerSample;
-		int nbits = fi->sampleType == stInteger ? fi->bitsPerSample : 0;
-		int nbytes = fi->bytesPerSample;
-		int pht = vsapi->getFrameHeight(srcA, plane);
-		int pwd = vsapi->getFrameWidth(srcA, plane);
-
-		int xyPlusW;
-
-		if (nbytes == 1)
-		{
-			// 8 bit data
-			uint8_t min = 0, max = 255;
-
-			xyPlusW = xFullProcess(d, dstp,
-								srcpA, srcpB,  pitch, 
-								pwd, pht, dpitch, max);
-		}
-
-		else if (nbytes == 2)
-		{
-			// 16 bit data
-			uint16_t min = 0, max = (1 << nbits) - 1;
-
-			xyPlusW = xFullProcess(d,  (uint16_t*)dstp,
-								(uint16_t *)srcpA, (uint16_t *)srcpB, pitch,
-								pwd, pht, dpitch, max);
-		}
-		else
-		{
-			// float data
-			float min = 0, max = 1.0f;
-
-			xyPlusW = xFullProcess(d, (float*)dstp,
-				(float*)srcpA, (float*)srcpB, pitch,
-				pwd, pht, dpitch, max);
-		}
-
-		// Release the source frame
-		vsapi->freeFrame(srcA);
-		vsapi->freeFrame(srcB);
-		
-		if (fi->numPlanes > 1)
-		{
-			for (plane = 0; plane < fi->numPlanes; plane++)
-			{
-				if ((fi->colorFamily == cmRGB && plane == 1) || (fi->colorFamily == cmYUV && plane == 0))
-					continue;
-				uint8_t *dstp = vsapi->getWritePtr(dst, plane);
-				int dpitch = vsapi->getStride(dst, plane) / fi->bytesPerSample;
-				//	int spitch = src_stride / fi->bytesPerSample;
-				int nbits = fi->sampleType == stInteger ? fi->bitsPerSample : 0;
-				int nbytes = fi->bytesPerSample;
-				
-				int dht = vsapi->getFrameHeight(dst, plane);
-				int dwd = vsapi->getFrameWidth(dst, plane);
-
-				// zero out chroma enable correlation display
-				if (nbytes == 1)
-				{
-
-					uint8_t grey = fi->colorFamily == cmRGB ? 0 : 128;
-					fillPlaneWithVal(dstp, dpitch, dwd, dht, grey);
-					//xFillPlaneWithVal(dstp, dpitch, dwd, dht, grey);
-				}
-				else if (nbytes == 2)
-				{
-					uint16_t grey = fi->colorFamily == cmRGB ? 0 : 1 << (nbits - 1);
-
-					fillPlaneWithVal((uint16_t*)dstp, dpitch, dwd, dht, grey);
-				}
-				else
-				{ // float data
-					float grey = 0.0;
-
-					fillPlaneWithVal((float*)dstp, dpitch, dwd, dht, grey);
-				}
-			}	/// for plane = 1;....
-		}	// if num planes > 1
-		if (fi->colorFamily == cmRGB)
-		{
-			// copy Green on to Blu and Red planes
-			vs_bitblt(vsapi->getWritePtr(dst, 0), vsapi->getStride(dst, 0),
-				vsapi->getWritePtr(dst, 1), vsapi->getStride(dst, 1),
-				wd * nbytes, ht);
-			vs_bitblt(vsapi->getWritePtr(dst, 2), vsapi->getStride(dst, 2),
-				vsapi->getWritePtr(dst, 1), vsapi->getStride(dst, 1),
-				wd * nbytes, ht);
-		}
-
-		if (d->txt && ((n - d->sf) % d->every) == 0 && n <= d->ef )
-		{
-			// find x and y coordinates of max correlation
-			float * topLeft = d->inBuf + (d->hbest / 2 - d->cy) * d->wbest + d->wbest / 2 - d->cx;// left top of rectangle
-			float max = 0;
-			int xcoord = 0, ycoord = 0;
-			// search in a rectangle of -cx, -cy to cx, cy
-			for (int h = 0; h <= 2 * d->cy; h++)
-			{
-				for (int w = 0; w <= 2 * d->cx; w++)
-				{
-					if (topLeft[w] > max)
-					{
-						max = topLeft[w];
-						xcoord = w;
-						ycoord = h;
-					}
-				}
-				topLeft += d->wbest;
-			}
-			int x = xcoord - d->cx, y = ycoord - d->cy;
-			int fw = (xyPlusW % d->wbest) - d->wbest /2;
-			int fh = (xyPlusW / d->wbest) - d->hbest / 2;
-			//ofile << "Correlation  Frame number, xcoord, ycoord, frame xcoord, frame ycoord" << nl;
-			int row = (n - d->sf) / d->every;
-			// after every 10 th row a double line interval
-			if (row % 10 == 0)
-				fprintf(d->ofile, "\n");
-
-			fprintf(d->ofile, " n %d\t x %d\t y %d\t fx %d\tfh %d\n",
-				n, x, y, fw, fh);
-			
-		}
-
-		if (n >= d->ef && d->ofile != NULL)
-			fclose(d->ofile);
-
-
-		return dst;
-	}
-
-	return 0;
+static const VSFrameRef *VS_CC f2qcorrGetFrame(
+    int n, int activationReason, void **instanceData, void **frameData,
+    VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) {
+    F2QCorrData *d = (F2QCorrData *) *instanceData;
+
+    if(activationReason == arInitial) {
+        // Request the source frames on the first call
+        vsapi->requestFrameFilter(n, d->node[0], frameCtx);
+        vsapi->requestFrameFilter(n, d->node[1], frameCtx);
+    } else if(activationReason == arAllFramesReady) {
+        const VSFrameRef *srcA = vsapi->getFrameFilter(n, d->node[0], frameCtx);
+        const VSFrameRef *srcB = vsapi->getFrameFilter(n, d->node[1], frameCtx);
+        // The reason we query this on a per frame basis is because we want our
+        // filter to accept clips with varying dimensions. If we reject such
+        // content using d->vi would be better.
+
+        int ht = vsapi->getFrameHeight(srcA, 0);
+        int wd = vsapi->getFrameWidth(srcA, 0);
+        int owd = d->vi.width;
+        int oht = d->vi.height;
+        // VSFrameRef *dst;
+        const VSFormat *fi = d->vi.format;
+        VSFrameRef *dst = vsapi->newVideoFrame(fi, owd, oht, srcA, core);
+        // use green for RGB and Y for YUV
+        int plane = fi->colorFamily == cmRGB ? 1 : 0;
+
+        const uint8_t *srcpA = vsapi->getReadPtr(srcA, plane);
+        const uint8_t *srcpB = vsapi->getReadPtr(srcB, plane);
+        int src_stride = vsapi->getStride(srcA, plane);
+        int dst_stride = vsapi->getStride(dst, plane);
+        uint8_t *dstp = vsapi->getWritePtr(dst, plane);
+        int pitch = src_stride / fi->bytesPerSample;
+        int dpitch = dst_stride / fi->bytesPerSample;
+        int nbits = fi->sampleType == stInteger ? fi->bitsPerSample : 0;
+        int nbytes = fi->bytesPerSample;
+        int pht = vsapi->getFrameHeight(srcA, plane);
+        int pwd = vsapi->getFrameWidth(srcA, plane);
+
+        int xyPlusW;
+
+        if(nbytes == 1) {
+            // 8 bit data
+            uint8_t min = 0, max = 255;
+
+            xyPlusW = xFullProcess(d, dstp, srcpA, srcpB, pitch, pwd, pht,
+                                   dpitch, max);
+        }
+
+        else if(nbytes == 2) {
+            // 16 bit data
+            uint16_t min = 0, max = (1 << nbits) - 1;
+
+            xyPlusW =
+                xFullProcess(d, (uint16_t *) dstp, (uint16_t *) srcpA,
+                             (uint16_t *) srcpB, pitch, pwd, pht, dpitch, max);
+        } else {
+            // float data
+            float min = 0, max = 1.0f;
+
+            xyPlusW =
+                xFullProcess(d, (float *) dstp, (float *) srcpA,
+                             (float *) srcpB, pitch, pwd, pht, dpitch, max);
+        }
+
+        // Release the source frame
+        vsapi->freeFrame(srcA);
+        vsapi->freeFrame(srcB);
+
+        if(fi->numPlanes > 1) {
+            for(plane = 0; plane < fi->numPlanes; plane++) {
+                if((fi->colorFamily == cmRGB && plane == 1) ||
+                   (fi->colorFamily == cmYUV && plane == 0))
+                    continue;
+                uint8_t *dstp = vsapi->getWritePtr(dst, plane);
+                int dpitch = vsapi->getStride(dst, plane) / fi->bytesPerSample;
+                //	int spitch = src_stride / fi->bytesPerSample;
+                int nbits = fi->sampleType == stInteger ? fi->bitsPerSample : 0;
+                int nbytes = fi->bytesPerSample;
+
+                int dht = vsapi->getFrameHeight(dst, plane);
+                int dwd = vsapi->getFrameWidth(dst, plane);
+
+                // zero out chroma enable correlation display
+                if(nbytes == 1) {
+
+                    uint8_t grey = fi->colorFamily == cmRGB ? 0 : 128;
+                    fillPlaneWithVal(dstp, dpitch, dwd, dht, grey);
+                    // xFillPlaneWithVal(dstp, dpitch, dwd, dht, grey);
+                } else if(nbytes == 2) {
+                    uint16_t grey =
+                        fi->colorFamily == cmRGB ? 0 : 1 << (nbits - 1);
+
+                    fillPlaneWithVal((uint16_t *) dstp, dpitch, dwd, dht, grey);
+                } else { // float data
+                    float grey = 0.0;
+
+                    fillPlaneWithVal((float *) dstp, dpitch, dwd, dht, grey);
+                }
+            } /// for plane = 1;....
+        } // if num planes > 1
+        if(fi->colorFamily == cmRGB) {
+            // copy Green on to Blu and Red planes
+            vs_bitblt(vsapi->getWritePtr(dst, 0), vsapi->getStride(dst, 0),
+                      vsapi->getWritePtr(dst, 1), vsapi->getStride(dst, 1),
+                      wd * nbytes, ht);
+            vs_bitblt(vsapi->getWritePtr(dst, 2), vsapi->getStride(dst, 2),
+                      vsapi->getWritePtr(dst, 1), vsapi->getStride(dst, 1),
+                      wd * nbytes, ht);
+        }
+
+        if(d->txt && ((n - d->sf) % d->every) == 0 && n <= d->ef) {
+            // find x and y coordinates of max correlation
+            float *topLeft = d->inBuf + (d->hbest / 2 - d->cy) * d->wbest +
+                             d->wbest / 2 - d->cx; // left top of rectangle
+            float max = 0;
+            int xcoord = 0, ycoord = 0;
+            // search in a rectangle of -cx, -cy to cx, cy
+            for(int h = 0; h <= 2 * d->cy; h++) {
+                for(int w = 0; w <= 2 * d->cx; w++) {
+                    if(topLeft[w] > max) {
+                        max = topLeft[w];
+                        xcoord = w;
+                        ycoord = h;
+                    }
+                }
+                topLeft += d->wbest;
+            }
+            int x = xcoord - d->cx, y = ycoord - d->cy;
+            int fw = (xyPlusW % d->wbest) - d->wbest / 2;
+            int fh = (xyPlusW / d->wbest) - d->hbest / 2;
+            // ofile << "Correlation  Frame number, xcoord, ycoord, frame
+            // xcoord, frame ycoord" << nl;
+            int row = (n - d->sf) / d->every;
+            // after every 10 th row a double line interval
+            if(row % 10 == 0)
+                fprintf(d->ofile, "\n");
+
+            fprintf(d->ofile, " n %d\t x %d\t y %d\t fx %d\tfh %d\n", n, x, y,
+                    fw, fh);
+        }
+
+        if(n >= d->ef && d->ofile != NULL)
+            fclose(d->ofile);
+
+        return dst;
+    }
+
+    return 0;
 }
 
 // Free all allocated data on filter destruction
-static void VS_CC f2qcorrFree(void *instanceData, VSCore *core, const VSAPI *vsapi)
-{
-	F2QCorrData *d = (F2QCorrData *)instanceData;
-	vsapi->freeNode(d->node[0]);
-	vsapi->freeNode(d->node[1]);
-	d-> fftwf_free(d->inBuf);
-	d->fftwf_free(d->outBuf);
-	d->fftwf_free(d->Bfreq);
-	d->fftwf_destroy_plan(d->pf);
-	d->fftwf_destroy_plan(d->pinv);
-	if (d->txt && d->ofile != NULL)
-		fclose(d->ofile);
-	free(d);
+static void VS_CC f2qcorrFree(void *instanceData, VSCore *core,
+                              const VSAPI *vsapi) {
+    F2QCorrData *d = (F2QCorrData *) instanceData;
+    vsapi->freeNode(d->node[0]);
+    vsapi->freeNode(d->node[1]);
+    d->fftwf_free(d->inBuf);
+    d->fftwf_free(d->outBuf);
+    d->fftwf_free(d->Bfreq);
+    d->fftwf_destroy_plan(d->pf);
+    d->fftwf_destroy_plan(d->pinv);
+    if(d->txt && d->ofile != NULL)
+        fclose(d->ofile);
+    free(d);
 }
 
-// This function is responsible for validating arguments and creating a new filter
-static void VS_CC f2qcorrCreate(const VSMap *in, VSMap *out, void *userData, VSCore *core, const VSAPI *vsapi)
-{
-	F2QCorrData d;
-	F2QCorrData *data;
-	int err;
-	int temp;
-	// Get a clip reference from the input arguments. This must be freed later.
-	d.node[0] = vsapi->propGetNode(in, "clip", 0, 0);
-	d.avi = vsapi->getVideoInfo(d.node[0]);
-	
-	// get second clip
-	d.node[1] = vsapi->propGetNode(in, "bclip", 0, 0);
-	const VSVideoInfo *bvi = vsapi->getVideoInfo(d.node[1]);
-
-	if (!isSameFormat(d.avi, bvi) || d.avi->numFrames != bvi->numFrames  )
-	{
-		vsapi->setError(out, "F2QCorr: both clips must be of same format, length and frame dimensions ");
-		vsapi->freeNode(d.node[0]);
-		vsapi->freeNode(d.node[1]);
-		return;
-	}
-	if (d.avi->format->colorFamily == cmCompat)
-	{
-		vsapi->setError(out, "F2QCorr: compat format is not accepted. Only Planar format clips can be input ");
-		vsapi->freeNode(d.node[0]);
-		vsapi->freeNode(d.node[1]);
-		return;
-	}
-	// In this first version we only want to handle 8bit integer formats. Note that
-	// vi->format can be 0 if the input clip can change format midstream.
-	if (!isConstantFormat(d.avi) || d.avi->width == 0 || d.avi->height == 0
-		|| d.avi->width != bvi->width || d.avi->height != bvi->height)
-	{
-		vsapi->setError(out, "F2QCorr: only constant format and const frame dimensions input supported");
-		vsapi->freeNode(d.node[0]);
-		vsapi->freeNode(d.node[1]);
-		return;
-	}
-	// set width and height of output frame
-	//d.vi.height = d.hbest;
-	//d.vi.width = d.wbest;
-
-	// If a property read fails for some reason (index out of bounds/wrong type)
-	// then err will have flags set to indicate why and 0 will be returned. This
-	// can be very useful to know when having optional arguments. Since we have
-	// strict checking because of what we wrote in the argument string, the only
-	// reason this could fail is when the value wasn't set by the user.
-	// And when it's not set we want it to default to enabled.
-	temp = !!int64ToIntS(vsapi->propGetInt(in, "txt", 0, &err));
-	if (err || temp == 0)
-		d.txt = false;
-	else
-		d.txt = true;
-	if (d.txt)
-	{		
-		temp = int64ToIntS(vsapi->propGetInt(in, "cx", 0, &err));
-		if (err)
-			d.cx = 20;
-		else if (abs(temp) < 2 && abs(temp) > d.avi->width / 8)
-		{
-			vsapi->setError(out, "F2QCorr: absolute values of cx must be between 2 and 1/8 frame wwidth");
-			vsapi->freeNode(d.node[0]);
-			vsapi->freeNode(d.node[1]);
-			return;
-		}
-		else
-			d.cx = abs(temp);
-		temp = int64ToIntS(vsapi->propGetInt(in, "cy", 0, &err));
-		if (err)
-			d.cy = d.cx <= d.avi->height / 8 ? d.cx : d.avi->height / 8;
-		else if (abs(temp) < 2 && abs(temp) > d.avi->height / 8)
-		{
-			vsapi->setError(out, "F2QCorr: absolute values of cy must be between 2 and 1/8 frame height");
-			vsapi->freeNode(d.node[0]);
-			vsapi->freeNode(d.node[1]);
-			return;
-		}
-		else
-			d.cy = abs(temp);
-
-		d.sf = int64ToIntS(vsapi->propGetInt(in, "sf", 0, &err));
-		if (err)
-			d.sf = 0;
-		else if (d.sf < 0 || d.sf >= d.avi->numFrames - 1)
-		{
-			vsapi->setError(out, "F2QCorr: sf must be within clip");
-			vsapi->freeNode(d.node[0]);
-			vsapi->freeNode(d.node[1]);
-			return;
-		}
-		d.ef = int64ToIntS(vsapi->propGetInt(in, "ef", 0, &err));
-		if (err)
-			d.ef = d.avi->numFrames - 1;
-		else if (d.ef < d.sf || d.ef >= d.avi->numFrames)
-		{
-			vsapi->setError(out, "F2QCorr: ef must not be less than sf and must be within clip");
-			vsapi->freeNode(d.node[0]);
-			vsapi->freeNode(d.node[1]);
-			return;
-		}
-
-		temp = d.ef - d.sf <= 1000 ? 1 : (d.ef - d.sf) / 1000 + 1;
-		d.every = int64ToIntS(vsapi->propGetInt(in, "every", 0, &err));
-		if (err)
-			d.every = temp;
-		else if (d.every < temp || d.every >= d.ef - d.sf)
-		{
-			vsapi->setError(out, "F2QCorr: every should not result in either zero or over 1000 records");
-			vsapi->freeNode(d.node[0]);
-			vsapi->freeNode(d.node[1]);
-			return;
-		}
-	
-		const char * fn = vsapi->propGetData(in, "filename", 0, &err);
-		if (err)
-		{
-			vsapi->setError(out, "F2QCorr: valid File name with full path must be specified");
-			vsapi->freeNode(d.node[0]);
-			vsapi->freeNode(d.node[1]);
-			return;
-		}
-		
-		d.filename = fn;
-		
-	}
-		
-	// I usually keep the filter data struct on the stack and don't allocate it
-	// until all the input validation is done.
-	data = (F2QCorrData *)malloc(sizeof(d));
-	*data = d;
-
-	vsapi->createFilter(in, out, "F2QCorr", f2qcorrInit, f2qcorrGetFrame, f2qcorrFree, fmParallelRequests, 0, data, core);
+// This function is responsible for validating arguments and creating a new
+// filter
+static void VS_CC f2qcorrCreate(const VSMap *in, VSMap *out, void *userData,
+                                VSCore *core, const VSAPI *vsapi) {
+    F2QCorrData d;
+    F2QCorrData *data;
+    int err;
+    int temp;
+    // Get a clip reference from the input arguments. This must be freed later.
+    d.node[0] = vsapi->propGetNode(in, "clip", 0, 0);
+    d.avi = vsapi->getVideoInfo(d.node[0]);
+
+    // get second clip
+    d.node[1] = vsapi->propGetNode(in, "bclip", 0, 0);
+    const VSVideoInfo *bvi = vsapi->getVideoInfo(d.node[1]);
+
+    if(!isSameFormat(d.avi, bvi) || d.avi->numFrames != bvi->numFrames) {
+        vsapi->setError(out, "F2QCorr: both clips must be of same format, "
+                             "length and frame dimensions ");
+        vsapi->freeNode(d.node[0]);
+        vsapi->freeNode(d.node[1]);
+        return;
+    }
+    if(d.avi->format->colorFamily == cmCompat) {
+        vsapi->setError(out, "F2QCorr: compat format is not accepted. Only "
+                             "Planar format clips can be input ");
+        vsapi->freeNode(d.node[0]);
+        vsapi->freeNode(d.node[1]);
+        return;
+    }
+    // In this first version we only want to handle 8bit integer formats. Note
+    // that vi->format can be 0 if the input clip can change format midstream.
+    if(!isConstantFormat(d.avi) || d.avi->width == 0 || d.avi->height == 0 ||
+       d.avi->width != bvi->width || d.avi->height != bvi->height) {
+        vsapi->setError(out, "F2QCorr: only constant format and const frame "
+                             "dimensions input supported");
+        vsapi->freeNode(d.node[0]);
+        vsapi->freeNode(d.node[1]);
+        return;
+    }
+    // set width and height of output frame
+    // d.vi.height = d.hbest;
+    // d.vi.width = d.wbest;
+
+    // If a property read fails for some reason (index out of bounds/wrong type)
+    // then err will have flags set to indicate why and 0 will be returned. This
+    // can be very useful to know when having optional arguments. Since we have
+    // strict checking because of what we wrote in the argument string, the only
+    // reason this could fail is when the value wasn't set by the user.
+    // And when it's not set we want it to default to enabled.
+    temp = !!int64ToIntS(vsapi->propGetInt(in, "txt", 0, &err));
+    if(err || temp == 0)
+        d.txt = false;
+    else
+        d.txt = true;
+    if(d.txt) {
+        temp = int64ToIntS(vsapi->propGetInt(in, "cx", 0, &err));
+        if(err)
+            d.cx = 20;
+        else if(abs(temp) < 2 && abs(temp) > d.avi->width / 8) {
+            vsapi->setError(out, "F2QCorr: absolute values of cx must be "
+                                 "between 2 and 1/8 frame wwidth");
+            vsapi->freeNode(d.node[0]);
+            vsapi->freeNode(d.node[1]);
+            return;
+        } else
+            d.cx = abs(temp);
+        temp = int64ToIntS(vsapi->propGetInt(in, "cy", 0, &err));
+        if(err)
+            d.cy = d.cx <= d.avi->height / 8 ? d.cx : d.avi->height / 8;
+        else if(abs(temp) < 2 && abs(temp) > d.avi->height / 8) {
+            vsapi->setError(out, "F2QCorr: absolute values of cy must be "
+                                 "between 2 and 1/8 frame height");
+            vsapi->freeNode(d.node[0]);
+            vsapi->freeNode(d.node[1]);
+            return;
+        } else
+            d.cy = abs(temp);
+
+        d.sf = int64ToIntS(vsapi->propGetInt(in, "sf", 0, &err));
+        if(err)
+            d.sf = 0;
+        else if(d.sf < 0 || d.sf >= d.avi->numFrames - 1) {
+            vsapi->setError(out, "F2QCorr: sf must be within clip");
+            vsapi->freeNode(d.node[0]);
+            vsapi->freeNode(d.node[1]);
+            return;
+        }
+        d.ef = int64ToIntS(vsapi->propGetInt(in, "ef", 0, &err));
+        if(err)
+            d.ef = d.avi->numFrames - 1;
+        else if(d.ef < d.sf || d.ef >= d.avi->numFrames) {
+            vsapi->setError(
+                out,
+                "F2QCorr: ef must not be less than sf and must be within clip");
+            vsapi->freeNode(d.node[0]);
+            vsapi->freeNode(d.node[1]);
+            return;
+        }
+
+        temp = d.ef - d.sf <= 1000 ? 1 : (d.ef - d.sf) / 1000 + 1;
+        d.every = int64ToIntS(vsapi->propGetInt(in, "every", 0, &err));
+        if(err)
+            d.every = temp;
+        else if(d.every < temp || d.every >= d.ef - d.sf) {
+            vsapi->setError(out, "F2QCorr: every should not result in either "
+                                 "zero or over 1000 records");
+            vsapi->freeNode(d.node[0]);
+            vsapi->freeNode(d.node[1]);
+            return;
+        }
+
+        const char *fn = vsapi->propGetData(in, "filename", 0, &err);
+        if(err) {
+            vsapi->setError(
+                out,
+                "F2QCorr: valid File name with full path must be specified");
+            vsapi->freeNode(d.node[0]);
+            vsapi->freeNode(d.node[1]);
+            return;
+        }
+
+        d.filename = fn;
+    }
+
+    // I usually keep the filter data struct on the stack and don't allocate it
+    // until all the input validation is done.
+    data = (F2QCorrData *) malloc(sizeof(d));
+    *data = d;
+
+    vsapi->createFilter(in, out, "F2QCorr", f2qcorrInit, f2qcorrGetFrame,
+                        f2qcorrFree, fmParallelRequests, 0, data, core);
 }
 
-//registerFunc("fqCorr", "clip:clip;bclip:clip;cx:int:opt;cy:int:opt;
-//		txt:int:opt;filename:data:opt;sf:int:opt;ef:int:opt;every:int:opt;", corrCreate, 0, plugin);
-
-
+// registerFunc("fqCorr", "clip:clip;bclip:clip;cx:int:opt;cy:int:opt;
+//		txt:int:opt;filename:data:opt;sf:int:opt;ef:int:opt;every:int:opt;",
+//corrCreate, 0, plugin);
diff --git a/FQDomainHelper.h b/FQDomainHelper.h
index 168156e..9003700 100644
--- a/FQDomainHelper.h
+++ b/FQDomainHelper.h
@@ -2,927 +2,800 @@
 #ifndef FREQDOMAIN_HELPER_FUNCTIONS
 #define FREQDOMAIN_HELPER_FUNCTIONS
 
-void ApplyFilter(fftwf_complex* fout, float* Filter, int wd, int ht);
+void ApplyFilter(fftwf_complex *fout, float *Filter, int wd, int ht);
 
 /*template <typename finc>
 void getRealInput(float* data, const finc* fptr, int pitch,
-	int wd, int ht, int wpad, int hpad, bool centered);
+    int wd, int ht, int wpad, int hpad, bool centered);
 
 
 template <typename finc>
 void getRealOutput(float* data, finc* fptr, int pitch,
-	int wd, int ht, int wpad, bool cent, finc min, finc max);*/
+    int wd, int ht, int wpad, bool cent, finc min, finc max);*/
 
-	//	int getSign ( int h, int w);
+//	int getSign ( int h, int w);
 
-	int getSign(int i);
+int getSign(int i);
 
-	int DrawPSF(float* psf, bool linear, int xval, int yval, int bestx, int besty,float spike = 0.0);
+int DrawPSF(float *psf, bool linear, int xval, int yval, int bestx, int besty,
+            float spike = 0.0);
 
-	int DrawCircularPSFUV(float* psf, int radius, int bestxUV, int bestyUV, int subX = 0, int subY = 0);
+int DrawCircularPSFUV(float *psf, int radius, int bestxUV, int bestyUV,
+                      int subX = 0, int subY = 0);
 
-	void DesignInverse(fftwf_complex* fout, float* Filter, float wn,
-		int bestx, int besty, float scale);
+void DesignInverse(fftwf_complex *fout, float *Filter, float wn, int bestx,
+                   int besty, float scale);
 
-	void GetFactors(int n, int* facbuf);
-	int getBestDim(int dimension, int* facbuf, int nfact = 64);
-	// F1Quiver
+void GetFactors(int n, int *facbuf);
+int getBestDim(int dimension, int *facbuf, int nfact = 64);
+// F1Quiver
 
-	void f1BuildFilterCascade(float * FreqFilter, int * filterSpec, int nfft, int npoints);
+void f1BuildFilterCascade(float *FreqFilter, int *filterSpec, int nfft,
+                          int npoints);
 
-	void f1BbuildCustomFilter(float * FrqFilt, int * specs, int nfft, int nval);
-	template <typename finc>
-	void getRowInput(float *data,const finc * rowptr, int nft, int wd);
-	template <typename finc>
-	void getRowOutput(float *data, finc * rowptr, int wd,finc min, finc max);
-	void F1ApplyFilter(fftwf_complex *freqbuf, float * filtbuf, int nfreq);
-	template <typename finc>
-	void getRowMorphInput(float *data,const finc * rowptr, int nft, int wd,
-		bool center = false, int start = 1, float* logLUT = NULL);
-	template <typename finc>
-	void getRowMorphOutput(float *data, finc * rowptr, int wd,finc min, finc max);
-	template <typename finc>
-	void f1DisplayHorizontalScale(int nyq, int best, int panelh, int wd, int pitch, finc* dp, finc max);
-	template <typename finc>
-	finc fclamp(float val, finc min, finc max);
+void f1BbuildCustomFilter(float *FrqFilt, int *specs, int nfft, int nval);
+template <typename finc>
+void getRowInput(float *data, const finc *rowptr, int nft, int wd);
+template <typename finc>
+void getRowOutput(float *data, finc *rowptr, int wd, finc min, finc max);
+void F1ApplyFilter(fftwf_complex *freqbuf, float *filtbuf, int nfreq);
+template <typename finc>
+void getRowMorphInput(float *data, const finc *rowptr, int nft, int wd,
+                      bool center = false, int start = 1, float *logLUT = NULL);
+template <typename finc>
+void getRowMorphOutput(float *data, finc *rowptr, int wd, finc min, finc max);
+template <typename finc>
+void f1DisplayHorizontalScale(int nyq, int best, int panelh, int wd, int pitch,
+                              finc *dp, finc max);
+template <typename finc> finc fclamp(float val, finc min, finc max);
 
 /// F2Quiver
-	template <typename finc>
-	void getRealInput2D(float* dp, const finc* fptr, int pitch, int ht,
-		int wd, int hbest, int wbest, bool centered);
-	template <typename finc>
-	void getHMRealInput2D(float* data, const finc* fptr, int pitch, int ht, int wd,
-							int hbest, int wbest, bool centered, float * logLUT);
-	//void getHMRealInput2D8bit(float* dp, const uint8_t* fptr, int pitch, int ht,
-	//	int wd, int hbest, int wbest, bool centered, float* logLUT);
-	template <typename finc>
-	void getRealOutput2D(float* data, finc* fptr, int pitch,
-		int ht, int wd, int hbest, int wbest,finc min, finc max);
-	template <typename finc>
-	void getHMRealOutput2D(float* data, finc* fptr, int pitch, int ht, int wd, int hbest, int wbest,finc min, finc max);	
-	
-	void ApplyFilter2D(fftwf_complex* out, float* frqFilter, int hbest, int frqwidth);
-	
-	int getSign(int h, int w);
-
-	float getAmpSquareOfComplex(fftwf_complex* point);
+template <typename finc>
+void getRealInput2D(float *dp, const finc *fptr, int pitch, int ht, int wd,
+                    int hbest, int wbest, bool centered);
+template <typename finc>
+void getHMRealInput2D(float *data, const finc *fptr, int pitch, int ht, int wd,
+                      int hbest, int wbest, bool centered, float *logLUT);
+// void getHMRealInput2D8bit(float* dp, const uint8_t* fptr, int pitch, int ht,
+//	int wd, int hbest, int wbest, bool centered, float* logLUT);
+template <typename finc>
+void getRealOutput2D(float *data, finc *fptr, int pitch, int ht, int wd,
+                     int hbest, int wbest, finc min, finc max);
+template <typename finc>
+void getHMRealOutput2D(float *data, finc *fptr, int pitch, int ht, int wd,
+                       int hbest, int wbest, finc min, finc max);
+
+void ApplyFilter2D(fftwf_complex *out, float *frqFilter, int hbest,
+                   int frqwidth);
+
+int getSign(int h, int w);
+
+float getAmpSquareOfComplex(fftwf_complex *point);
 /*
-	// FQCorr
-	template <typename finc>
-	void xFillPlaneWithVal(finc* wp, const int wpitch, const int wd, const int ht, finc val);
-	template <typename finc>
-	// convert input unsigned char data to  float type
-	void xGetRealInput(float* data, const finc* fptr,
-		int pitch, int wd, int ht,
-		int wpad, int hpad, bool centered);
-
-	void xCorrelate(fftwf_complex* Afreq, fftwf_complex* Bfreq, int fsize);
-	int xNormGamma(float* buf, int size);
+    // FQCorr
+    template <typename finc>
+    void xFillPlaneWithVal(finc* wp, const int wpitch, const int wd, const int
+   ht, finc val); template <typename finc>
+    // convert input unsigned char data to  float type
+    void xGetRealInput(float* data, const finc* fptr,
+        int pitch, int wd, int ht,
+        int wpad, int hpad, bool centered);
+
+    void xCorrelate(fftwf_complex* Afreq, fftwf_complex* Bfreq, int fsize);
+    int xNormGamma(float* buf, int size);
 */
-	template <typename finc>
-	void xTransferToDst(finc* dp, int dpitch,
-		int dwd, int dht, float* buf, int bestwd, int bestht, finc max);
-		// FQSharp and F2Quiver
-	void F2QhammingWindowing(float* cosBell, int pitch, int width, int height, int rfilt);
-		//F2QLimit
-	void removeInputCentering(float* inBuf, int wbest, int hbest);
+template <typename finc>
+void xTransferToDst(finc *dp, int dpitch, int dwd, int dht, float *buf,
+                    int bestwd, int bestht, finc max);
+// FQSharp and F2Quiver
+void F2QhammingWindowing(float *cosBell, int pitch, int width, int height,
+                         int rfilt);
+// F2QLimit
+void removeInputCentering(float *inBuf, int wbest, int hbest);
 //--------------------------------------------------------------------------------------------
-void GetFactors(int n, int* facbuf)
-{
-	// finds factors and fills facbuf with factor, remainder. maximum allowed or 32 pairs
-	// factors are 4,2,3,5,....  remaining primes. 
-	int p = 4;
-	double floor_sqrt;
-	floor_sqrt = floor(sqrt((double)n));
-
-	/*factor out powers of 4, powers of 2, then any remaining primes */
-	do
-	{
-		while (n % p)
-		{
-			switch (p)
-			{
-			case 4: p = 2; break;
-			case 2: p = 3; break;
-			default: p += 2; break;
-			}
-			if (p > floor_sqrt)
-				p = n;          /* no more factors, skip to end */
-		}
-		n /= p;
-		*facbuf++ = p;
-		*facbuf++ = n;
-	} while (n > 1);
+void GetFactors(int n, int *facbuf) {
+    // finds factors and fills facbuf with factor, remainder. maximum allowed or
+    // 32 pairs factors are 4,2,3,5,....  remaining primes.
+    int p = 4;
+    double floor_sqrt;
+    floor_sqrt = floor(sqrt((double) n));
+
+    /*factor out powers of 4, powers of 2, then any remaining primes */
+    do {
+        while(n % p) {
+            switch(p) {
+            case 4: p = 2; break;
+            case 2: p = 3; break;
+            default: p += 2; break;
+            }
+            if(p > floor_sqrt)
+                p = n; /* no more factors, skip to end */
+        }
+        n /= p;
+        *facbuf++ = p;
+        *facbuf++ = n;
+    } while(n > 1);
 }
 
-int getBestDim(int dimension, int* facbuf, int nfact)
-{
-	// returns nearest larger value having factors limited  2, 3, and 5
-	int n = dimension;
-	int largest = 7;
-	size_t i;
-
-	while (largest > 5)
-	{
-		GetFactors(n, facbuf);
-		// check value of largest factor
-		for (i = 0; i < nfact; i += 2)
-			if (facbuf[i + 1] == 1)	// 
-			{
-				largest = facbuf[i];
-				break;
-			}
-
-		if (largest > 5)
-			n += 4;
-	}
-	return (n);
+int getBestDim(int dimension, int *facbuf, int nfact) {
+    // returns nearest larger value having factors limited  2, 3, and 5
+    int n = dimension;
+    int largest = 7;
+    size_t i;
+
+    while(largest > 5) {
+        GetFactors(n, facbuf);
+        // check value of largest factor
+        for(i = 0; i < nfact; i += 2)
+            if(facbuf[i + 1] == 1) //
+            {
+                largest = facbuf[i];
+                break;
+            }
+
+        if(largest > 5)
+            n += 4;
+    }
+    return (n);
 }
 
-template <typename finc>
-finc fclamp(float val, finc min, finc max)
-{
-	return (finc)(val < min ? min : val > max ? max : val);
+template <typename finc> finc fclamp(float val, finc min, finc max) {
+    return (finc) (val < min ? min : val > max ? max : val);
 }
 
-float getAmpSquareOfComplex(fftwf_complex* point)
-{
-	return  (point[0][0] * point[0][0] + point[0][1] * point[0][1]);
-
+float getAmpSquareOfComplex(fftwf_complex *point) {
+    return (point[0][0] * point[0][0] + point[0][1] * point[0][1]);
 }
 //-----------------------------------------------------------------------------
 // one dimension functions
-void f1BuildCustomFilter(float* FrqFilt, int* specs, int nfft, int nval)
-{
-	// extend towards zero
-	if (specs[0] > 0)
-	{
-		int f = (specs[0] * nfft / 2) / NYQUIST;
-		for (int j = 0; j < f; j++)	// extend first value towards zero
-		{
-
-			FrqFilt[j] = 0.01f * specs[1];	// it is a %age value. hence 0.01
-		}
-	}
-	// extend till end
-	if (specs[nval - 2] < NYQUIST)
-	{
-		int f = (specs[nval - 2] * nfft / 2) / NYQUIST;
-		for (int j = f; j < nfft / 2; j++)	// extend last value to end
-
-			FrqFilt[j] = 0.01f * specs[nval - 1];
-	}
-
-	for (int i = 0; i < nval - 2; i += 2)
-	{
-		int f1 = (specs[i] * nfft / 2) / NYQUIST;
-		int f2 = (specs[i + 2] * nfft / 2) / NYQUIST;
-		//  linear interpolation
-		for (int j = f1; j < f2; j++)
-		{
-			FrqFilt[j] = 0.01f * (specs[i + 1] + ((j - f1) * (specs[i + 3] - specs[i + 1])
-				/ (f2 - f1)));
-		}
-
-	}
-
-	FrqFilt[nfft / 2] = FrqFilt[nfft / 2 - 1];	// nyquist freq bin
-
-		//  apply 5 point averaging 	
-	for (int i = 2; i < nfft / 2 - 2; i++)
-	{
-		float frq = 0.0;
-		for (int k = -2; k < 3; k++)
-		{
-			frq += FrqFilt[i + k];
-		}
-
-		FrqFilt[i] = frq / 5;
-	}
+void f1BuildCustomFilter(float *FrqFilt, int *specs, int nfft, int nval) {
+    // extend towards zero
+    if(specs[0] > 0) {
+        int f = (specs[0] * nfft / 2) / NYQUIST;
+        for(int j = 0; j < f; j++) // extend first value towards zero
+        {
+
+            FrqFilt[j] = 0.01f * specs[1]; // it is a %age value. hence 0.01
+        }
+    }
+    // extend till end
+    if(specs[nval - 2] < NYQUIST) {
+        int f = (specs[nval - 2] * nfft / 2) / NYQUIST;
+        for(int j = f; j < nfft / 2; j++) // extend last value to end
+
+            FrqFilt[j] = 0.01f * specs[nval - 1];
+    }
+
+    for(int i = 0; i < nval - 2; i += 2) {
+        int f1 = (specs[i] * nfft / 2) / NYQUIST;
+        int f2 = (specs[i + 2] * nfft / 2) / NYQUIST;
+        //  linear interpolation
+        for(int j = f1; j < f2; j++) {
+            FrqFilt[j] =
+                0.01f *
+                (specs[i + 1] +
+                 ((j - f1) * (specs[i + 3] - specs[i + 1]) / (f2 - f1)));
+        }
+    }
+
+    FrqFilt[nfft / 2] = FrqFilt[nfft / 2 - 1]; // nyquist freq bin
+
+    //  apply 5 point averaging
+    for(int i = 2; i < nfft / 2 - 2; i++) {
+        float frq = 0.0;
+        for(int k = -2; k < 3; k++) {
+            frq += FrqFilt[i + k];
+        }
+
+        FrqFilt[i] = frq / 5;
+    }
 }
 //---------------------------------------------------------------------------------
 
-void f1BuildFilterCascade(float* FreqFilter, int* filterSpec, int nfft, int npoints)
-{
-	// build cascaded butterworth filter.
-	// array first val:- 0: reduction 1 highcut, 2 lowcut, 3 band pass, 4  band stop
-	// array second val :- frequency
-	// array 3rd val :- band width (applicable for band pass only)
-	// array 4th val :- degree of sharpness. max 12. Note degree = 1 is Gaussian
-	for (int i = 0; i < npoints; i += 4)
-	{
-		int type = filterSpec[i];
-
-		float freq = filterSpec[i + 1] * nfft / (2 * NYQUIST);
-
-		float bandwidth = (freq * filterSpec[i + 2]) / 100.0f;		
-
-		int degree = 2 * filterSpec[i + 3];
-
-		if (type == 0)
-		{			
-			float freq2 = filterSpec[i + 2] * nfft / (2 * NYQUIST);
-
-			for (int i = freq; i <= freq2; i++)
-			{
-				FreqFilter[i] *= 1.0 / (1 + degree);
-			}
-		}
-
-		else if (type == 1)
-		{
-			// high frequencies are filtered out
-
-			for (int j = 1; j < nfft / 2; j++)
-			{
-				FreqFilter[j] *= 1.0f / (1.0f + pow(j / freq, degree));
-			}
-		}
-
-		else if (type == 2)
-		{
-			// low frequencies filtered off
-			for (int j = 1; j < nfft / 2; j++)
-			{
-				FreqFilter[j] *= 1.0f / (1.0f + pow(freq / j, degree));
-			}
-
-			FreqFilter[0] = 0.0;
-		}
-
-		else if (type == 3)
-		{
-			// band pass filter
-			for (int j = 1; j < nfft / 2; j++)
-			{
-				FreqFilter[j] *= 1.0f / ((1.0f + pow(j / (freq + bandwidth), degree)) * (1.0f + pow((freq - bandwidth) / j, degree)));
-
-
-			}
-		}
-
-		else if (type == 4)
-		{
-			// notch/ band reject filter
-			for (int j = 1; j < nfft / 2; j++)
-			{
-				FreqFilter[j] *= float(1.0 - 1.0 / ((1.0 + pow(j / (freq + bandwidth), degree)) * (1.0 + pow((freq - bandwidth) / j, degree))));
-
-			}
-		}
-
-		FreqFilter[nfft / 2] = FreqFilter[nfft / 2 - 1];	// nyquist freq
-	}
+void f1BuildFilterCascade(float *FreqFilter, int *filterSpec, int nfft,
+                          int npoints) {
+    // build cascaded butterworth filter.
+    // array first val:- 0: reduction 1 highcut, 2 lowcut, 3 band pass, 4  band
+    // stop array second val :- frequency array 3rd val :- band width
+    // (applicable for band pass only) array 4th val :- degree of sharpness.
+    // max 12. Note degree = 1 is Gaussian
+    for(int i = 0; i < npoints; i += 4) {
+        int type = filterSpec[i];
+
+        float freq = filterSpec[i + 1] * nfft / (2 * NYQUIST);
+
+        float bandwidth = (freq * filterSpec[i + 2]) / 100.0f;
+
+        int degree = 2 * filterSpec[i + 3];
+
+        if(type == 0) {
+            float freq2 = filterSpec[i + 2] * nfft / (2 * NYQUIST);
+
+            for(int i = freq; i <= freq2; i++) {
+                FreqFilter[i] *= 1.0 / (1 + degree);
+            }
+        }
+
+        else if(type == 1) {
+            // high frequencies are filtered out
+
+            for(int j = 1; j < nfft / 2; j++) {
+                FreqFilter[j] *= 1.0f / (1.0f + pow(j / freq, degree));
+            }
+        }
+
+        else if(type == 2) {
+            // low frequencies filtered off
+            for(int j = 1; j < nfft / 2; j++) {
+                FreqFilter[j] *= 1.0f / (1.0f + pow(freq / j, degree));
+            }
+
+            FreqFilter[0] = 0.0;
+        }
+
+        else if(type == 3) {
+            // band pass filter
+            for(int j = 1; j < nfft / 2; j++) {
+                FreqFilter[j] *=
+                    1.0f / ((1.0f + pow(j / (freq + bandwidth), degree)) *
+                            (1.0f + pow((freq - bandwidth) / j, degree)));
+            }
+        }
+
+        else if(type == 4) {
+            // notch/ band reject filter
+            for(int j = 1; j < nfft / 2; j++) {
+                FreqFilter[j] *= float(
+                    1.0 - 1.0 / ((1.0 + pow(j / (freq + bandwidth), degree)) *
+                                 (1.0 + pow((freq - bandwidth) / j, degree))));
+            }
+        }
+
+        FreqFilter[nfft / 2] = FreqFilter[nfft / 2 - 1]; // nyquist freq
+    }
 }
 //------------------------------------------------------------------------
-void F1ApplyFilter(fftwf_complex* freqbuf, float* filter, int nfreq)
-{
-	for (int i = 0; i < nfreq; i++)
-	{
-		freqbuf[i][0] *= filter[i];
-
-		freqbuf[i][1] *= filter[i];
-	}
+void F1ApplyFilter(fftwf_complex *freqbuf, float *filter, int nfreq) {
+    for(int i = 0; i < nfreq; i++) {
+        freqbuf[i][0] *= filter[i];
+
+        freqbuf[i][1] *= filter[i];
+    }
 }
 //-----------------------------------------------------------------------------
 template <typename finc>
 
-void getRowInput(float* data, const finc* rowptr, int nft, int wd)
-{
-	// for apparent vertical noise, row data is needed 
+void getRowInput(float *data, const finc *rowptr, int nft, int wd) {
+    // for apparent vertical noise, row data is needed
 
-	for (int i = 0; i < wd; i++)
+    for(int i = 0; i < wd; i++)
 
-		data[i] = rowptr[i];
+        data[i] = rowptr[i];
 
-	// zero padding 
-	for (int i = wd; i < nft; i++)
+    // zero padding
+    for(int i = wd; i < nft; i++)
 
-		data[i] = 0.0;
+        data[i] = 0.0;
 }
 //------------------------------------------------------------------------------
 template <typename finc>
-void getRowMorphInput(float* data, const finc* rowptr, int nft, int wd, bool center, int start, float * logLUT)
-{
-	//  float * logLUT will be default null for float and more than 12 bit value input
-	// start value default 1 or minus 1 for centering transformed spectrum
-	// centered default value false. whether centering required
-	if (center)
-	{
-		if (logLUT == NULL)
-		{
-			for (int i = 0; i < wd; i++)
-			{
-
-				data[i] = start * log((float)rowptr[i]);
-				start = -start;
-			}
-		}
-		else
-		{
-			for (int i = 0; i < wd; i++)
-			{
-				data[i] = start * logLUT[(int)rowptr[i]];
-				start = -start;
-			}
-		}
-	}
-
-	else // if (!center)
-	{
-		if (logLUT == NULL)
-		{
-			for (int i = 0; i < wd; i++)
-			{
-				data[i] =  log((float)rowptr[i]);				
-			}
-		}
-		else
-		{
-			for (int i = 0; i < wd; i++)
-			{
-				data[i] = logLUT[(int)rowptr[i]];				
-			}
-		}
-	}
-
-
-	for (int i = wd; i < nft; i++)
-
-		data[i] = 0.0;
+void getRowMorphInput(float *data, const finc *rowptr, int nft, int wd,
+                      bool center, int start, float *logLUT) {
+    //  float * logLUT will be default null for float and more than 12 bit value
+    //  input
+    // start value default 1 or minus 1 for centering transformed spectrum
+    // centered default value false. whether centering required
+    if(center) {
+        if(logLUT == NULL) {
+            for(int i = 0; i < wd; i++) {
+
+                data[i] = start * log((float) rowptr[i]);
+                start = -start;
+            }
+        } else {
+            for(int i = 0; i < wd; i++) {
+                data[i] = start * logLUT[(int) rowptr[i]];
+                start = -start;
+            }
+        }
+    }
+
+    else // if (!center)
+    {
+        if(logLUT == NULL) {
+            for(int i = 0; i < wd; i++) {
+                data[i] = log((float) rowptr[i]);
+            }
+        } else {
+            for(int i = 0; i < wd; i++) {
+                data[i] = logLUT[(int) rowptr[i]];
+            }
+        }
+    }
+
+    for(int i = wd; i < nft; i++)
+
+        data[i] = 0.0;
 }
 //------------------------------------------------------------------------------
 
 //-----------------------------------------------------------------------------
 template <typename finc>
-void getRowOutput(float* data, finc* rowptr, int wd,finc min, finc max)
-{
-	
-	for (int i = 0; i < wd; i++)
-	{
-		float val = data[i];	// scale down
-
-		rowptr[i] = fclamp(val, min, max);
-
+void getRowOutput(float *data, finc *rowptr, int wd, finc min, finc max) {
 
-	}
+    for(int i = 0; i < wd; i++) {
+        float val = data[i]; // scale down
 
+        rowptr[i] = fclamp(val, min, max);
+    }
 }
 //---------------------------------------------------------------------------
 template <typename finc>
-void getRowMorphOutput(float* data, finc* rowptr, int wd,finc min, finc max)
-{
-	
-	for (int i = 0; i < wd; i++)
-	{
-		float expo = exp(data[i]);
-
-		rowptr[i] = fclamp(expo, min, max);
-	}
+void getRowMorphOutput(float *data, finc *rowptr, int wd, finc min, finc max) {
+
+    for(int i = 0; i < wd; i++) {
+        float expo = exp(data[i]);
+
+        rowptr[i] = fclamp(expo, min, max);
+    }
 }
 //-------------------------------------------------------------------------------------------------------------------------
 template <typename finc>
-void f1DisplayHorizontalScale(int nyq, int best, int panelh, int wd, int pitch, finc* dp, finc max)
-{
-	for (int i = 0; i < nyq; i++)
-	{
-		int ws = (i * best) / (2 * nyq);
-		// display horizontal scale for freq
-		if ((i % 100) == 0)
-		{
-			for (int h = 0; h < 10; h++)
-			{
-
-				dp[(h + panelh + 5) * pitch + ws] = max;
-			}
-		}
-
-		else if ((i % 50) == 0)
-		{
-			if (wd >= nyq / 20)	// to ensure readability
-			{
-				for (int h = 0; h < 6; h++)
-				{
-
-					dp[(h + panelh + 6) * pitch + ws] = (4 * max) / 5;
-				}
-			}
-		}
-		else if ((i % 10) == 0)
-		{
-			if (wd >= nyq / 2)
-			{
-				for (int h = 0; h < 3; h++)
-				{
-
-					dp[(h + panelh + 7) * pitch + ws] = (3 * max) / 4;
-				}
-			}
-		}
-
-	}
-
+void f1DisplayHorizontalScale(int nyq, int best, int panelh, int wd, int pitch,
+                              finc *dp, finc max) {
+    for(int i = 0; i < nyq; i++) {
+        int ws = (i * best) / (2 * nyq);
+        // display horizontal scale for freq
+        if((i % 100) == 0) {
+            for(int h = 0; h < 10; h++) {
+
+                dp[(h + panelh + 5) * pitch + ws] = max;
+            }
+        }
+
+        else if((i % 50) == 0) {
+            if(wd >= nyq / 20) // to ensure readability
+            {
+                for(int h = 0; h < 6; h++) {
+
+                    dp[(h + panelh + 6) * pitch + ws] = (4 * max) / 5;
+                }
+            }
+        } else if((i % 10) == 0) {
+            if(wd >= nyq / 2) {
+                for(int h = 0; h < 3; h++) {
+
+                    dp[(h + panelh + 7) * pitch + ws] = (3 * max) / 4;
+                }
+            }
+        }
+    }
 }
 //-------------------------------------------------------------------------------------------
 // Two demensional fft functions
 //---------------------------------------------------------------------------------------------
-			//Draws the PSF linear or circular at center of the psf buffer 
-		// draws psf in float data
-int  DrawPSF(float* psf, bool linear, int xval, int yval, int bestx, int besty, float spike)
-{
-
-	int count;
-
-	// zero psf area
-	for (int h = 0; h < bestx * besty; h++)
-
-		psf[h] = 0.0;
+// Draws the PSF linear or circular at center of the psf buffer
+// draws psf in float data
+int DrawPSF(float *psf, bool linear, int xval, int yval, int bestx, int besty,
+            float spike) {
 
-	if (linear)
-	{
-		int length = abs(yval) > xval ? abs(yval) : xval;
+    int count;
 
-		count = 2 * length + 1;
+    // zero psf area
+    for(int h = 0; h < bestx * besty; h++)
 
-		// draw the blur line at the center of frames best sizes
+        psf[h] = 0.0;
 
-		if (abs(yval) > xval)
-		{
-			if (yval < 0)
-			{
-				yval = -yval;
+    if(linear) {
+        int length = abs(yval) > xval ? abs(yval) : xval;
 
-				xval = -xval;
-			}
+        count = 2 * length + 1;
 
+        // draw the blur line at the center of frames best sizes
 
-			for (int h = -abs(yval); h <= abs(yval); h++)
-			{
+        if(abs(yval) > xval) {
+            if(yval < 0) {
+                yval = -yval;
 
-				int w = (h * xval) / yval;		// get nearest integer
+                xval = -xval;
+            }
 
-				int fraction = abs(h * xval) % abs(yval);		// get fractional part
+            for(int h = -abs(yval); h <= abs(yval); h++) {
 
-					// distribute amp in ratio of fraction
+                int w = (h * xval) / yval; // get nearest integer
 
-				psf[(besty / 2 + h) * bestx + (bestx / 2 + w)]
-					= (1.0f * (abs(yval) - fraction)) / (count * abs(yval));
+                int fraction = abs(h * xval) % abs(yval); // get fractional part
 
-				if (h * xval > 0)
+                // distribute amp in ratio of fraction
 
-					psf[(besty / 2 + h) * bestx + (bestx / 2 + w + 1)]
-					= (1.0f * fraction) / (count * abs(yval));
+                psf[(besty / 2 + h) * bestx + (bestx / 2 + w)] =
+                    (1.0f * (abs(yval) - fraction)) / (count * abs(yval));
 
-				else	// if( h  < 0)
+                if(h * xval > 0)
 
-					psf[(besty / 2 + h) * bestx + (bestx / 2 + w - 1)] = (1.0f * fraction) / (count * abs(yval));
+                    psf[(besty / 2 + h) * bestx + (bestx / 2 + w + 1)] =
+                        (1.0f * fraction) / (count * abs(yval));
 
+                else // if( h  < 0)
 
+                    psf[(besty / 2 + h) * bestx + (bestx / 2 + w - 1)] =
+                        (1.0f * fraction) / (count * abs(yval));
+            }
+        }
 
-			}
-		}
+        else // xval is greater than yval
 
+        {
+            // xval is always a positive
 
-		else	// xval is greater than yval
+            for(int w = -xval; w <= xval; w++) {
 
-		{
-			//xval is always a positive
+                int h = (w * yval) / xval;
 
+                int fraction = abs((w * yval)) % xval; // get fractional part
 
-			for (int w = -xval; w <= xval; w++)
-			{
+                psf[(besty / 2 + h) * bestx + (bestx / 2 + w)] =
+                    (1.0f * (xval - fraction)) / (count * xval);
 
-				int h = (w * yval) / xval;
+                if(w * yval > 0)
 
-				int fraction = abs((w * yval)) % xval;		// get fractional part
+                    psf[(besty / 2 + h + 1) * bestx + (bestx / 2 + w)] =
+                        (1.0f * fraction) / (count * xval);
 
-				psf[(besty / 2 + h) * bestx + (bestx / 2 + w)]
-					= (1.0f * (xval - fraction)) / (count * xval);
+                else // if( w * yval < 0)
 
-				if (w * yval > 0)
+                    psf[(besty / 2 + h - 1) * bestx + (bestx / 2 + w)] =
+                        (1.0f * fraction) / (count * xval);
+            }
+        }
 
-					psf[(besty / 2 + h + 1) * bestx + (bestx / 2 + w)]
-					= (1.0f * fraction) / (count * xval);
+    }
 
-				else	// if( w * yval < 0)
+    else // circular
 
-					psf[(besty / 2 + h - 1) * bestx + (bestx / 2 + w)]
-					= (1.0f * fraction) / (count * xval);
+    {
 
-			}
+        // draw the blur circle at the center of frame
 
-		}
+        count = 0;
 
-	}
+        for(int h = -xval; h <= xval; h++)
 
-	else		// circular
+            for(int w = -xval; w <= xval; w++)
 
-	{
+                if(h * h + w * w <= xval * xval)
 
-		// draw the blur circle at the center of frame
+                    count++;
 
-		count = 0;
+        // incase of deblur there is a spike added to center value
+        // actually all values except center are reduced.
 
-		for (int h = -xval; h <= xval; h++)
+        for(int h = -xval; h <= xval; h++)
 
-			for (int w = -xval; w <= xval; w++)
+            for(int w = -xval; w <= xval; w++)
 
-				if (h * h + w * w <= xval * xval)
+                if(h * h + w * w <= xval * xval)
 
-					count++;
+                    psf[(besty / 2 + h) * bestx + (bestx / 2 + w)] =
+                        1.0f / count;
 
-		// incase of deblur there is a spike added to center value
-		// actually all values except center are reduced.
+        // center value will have spike to provide white noise and reduce
+        // instability
+        if(spike > 0.001)
 
-		for (int h = -xval; h <= xval; h++)
+            psf[(besty / 2) * bestx + (bestx / 2)] = (1.0f + spike) / count;
+    }
 
-			for (int w = -xval; w <= xval; w++)
-
-				if (h * h + w * w <= xval * xval)
-
-					psf[(besty / 2 + h) * bestx + (bestx / 2 + w)] = 1.0f / count;
-
-		// center value will have spike to provide white noise and reduce instability
-		if (spike > 0.001)
-
-			psf[(besty / 2) * bestx + (bestx / 2)] = (1.0f + spike) / count;
-	}
-
-	return count;
+    return count;
 }
 //----------------------------------------------------------------------------------------------------------
-int DrawCircularPSFUV(float* psf, int rad, int bestx, int besty, int subX, int subY)
-{
-	//zero out buffer
-	for (int h = 0; h < (bestx) * (besty); h++)
+int DrawCircularPSFUV(float *psf, int rad, int bestx, int besty, int subX,
+                      int subY) {
+    // zero out buffer
+    for(int h = 0; h < (bestx) * (besty); h++)
 
-		psf[h] = 0.0;
+        psf[h] = 0.0;
 
-	int count = 0;
-	int andX = (1 << subX) - 1;
-	int andY = (1 << subY) - 1;
-	int xval = rad >> subX;
-	int yval = rad >> subY;
-	int rsq = rad * rad;
+    int count = 0;
+    int andX = (1 << subX) - 1;
+    int andY = (1 << subY) - 1;
+    int xval = rad >> subX;
+    int yval = rad >> subY;
+    int rsq = rad * rad;
 
-	for (int h = -yval; h <= yval; h++)
-	{
-		int hsq = (h << subY) * (h << subY);
+    for(int h = -yval; h <= yval; h++) {
+        int hsq = (h << subY) * (h << subY);
 
-		for (int w = -xval; w <= xval; w++)
-		{
-			int wsq = (w << subX) * (w << subX);
+        for(int w = -xval; w <= xval; w++) {
+            int wsq = (w << subX) * (w << subX);
 
-			if (hsq + wsq <= rsq)
-			{
-				psf[(besty / 2 + h) * bestx + (bestx / 2 + w)] = 1.0f;
+            if(hsq + wsq <= rsq) {
+                psf[(besty / 2 + h) * bestx + (bestx / 2 + w)] = 1.0f;
 
-				count++;
-			}
-		}
-	}
+                count++;
+            }
+        }
+    }
 
-	for (int i = 0; i < bestx * besty; i++)
+    for(int i = 0; i < bestx * besty; i++)
 
-		psf[i] /= count;
+        psf[i] /= count;
 
-	return count;
+    return count;
 }
 
 //------------------------------------------------------------------------------------------------------------
-void DesignInverse(fftwf_complex* fout, float* Filter,
-	float wn, int bestx, int besty,
-	float scale)
-{
-	// the forward transform of PSF is in fout. Only real  positive values
-				// get max value
-	float mval = fout[0][0];
-
+void DesignInverse(fftwf_complex *fout, float *Filter, float wn, int bestx,
+                   int besty, float scale) {
+    // the forward transform of PSF is in fout. Only real  positive values
+    // get max value
+    float mval = fout[0][0];
 
-	for (int h = 0; h < bestx * besty; h++)
+    for(int h = 0; h < bestx * besty; h++)
 
+        // get max value. Possibly the zeroth val is max but lets find
+        if((fout[h][0]) > mval)
 
-		// get max value. Possibly the zeroth val is max but lets find
-		if ((fout[h][0]) > mval)
-
-			mval = fout[h][0];
-
-	mval *= wn;		// this is the min value we will accept for inversion
-
-					//  apply freq mask, and wn of inversion
-	// PSF during forward transform is scaled up by sqrt(bestx * besty)
-	// while inverting it it is 1/ this value. so no sscaling for transform is needed.
-	float scaler = scale * (1.0 + wn) / (bestx * besty) / (1.0f - wn); // This trial/error derived approximation for scaler
-									// as the higher wn is frequencies are inverted less
-									// and we lose amplitude
-					// we add white noise and  scaler . 
-	for (int h = 0; h < bestx * besty; h++)
-
-
-		Filter[h] = scaler / (fout[h][0] + mval);
+            mval = fout[h][0];
 
+    mval *= wn; // this is the min value we will accept for inversion
 
+    //  apply freq mask, and wn of inversion
+    // PSF during forward transform is scaled up by sqrt(bestx * besty)
+    // while inverting it it is 1/ this value. so no sscaling for transform is
+    // needed.
+    float scaler = scale * (1.0 + wn) / (bestx * besty) /
+                   (1.0f - wn); // This trial/error derived approximation for
+                                // scaler as the higher wn is frequencies are
+                                // inverted less and we lose amplitude
+    // we add white noise and  scaler .
+    for(int h = 0; h < bestx * besty; h++)
 
+        Filter[h] = scaler / (fout[h][0] + mval);
 }
 
 //------------------------------------------------------------------------------------------------------------
 // F2Quiver uses these
 //---------------------------------------------------------------------------------------------
-	// use this when data type is  complex 
-int getSign(int i)
-{
-	return (i & 1) == 0 ? 1 : -1;
-
-}
-
-int getSign(int h, int w)
-{
-
-	return ((h + (w >> 1)) & 1) == 0 ? 1 : -1;
-}
+// use this when data type is  complex
+int getSign(int i) { return (i & 1) == 0 ? 1 : -1; }
 
+int getSign(int h, int w) { return ((h + (w >> 1)) & 1) == 0 ? 1 : -1; }
 
 //---------------------------------------------------------------------------------------------
 template <typename finc>
-void getRealInput2D(float* in, const finc* ptr, int pitch, int ht,
-	int wd, int hbest, int wbest, bool centered)
-{
-	// convert frame y values to float and keep in data buffer
-	float* data = in;
-	if (centered)
-	{
-		// values multiplied by -1^(x+y) i.e sign to get the spectogram centered in frame
-		for (size_t h = 0; h < ht; h++)
-		{
-			for (size_t w = 0; w < wd; w++)
-			{
-
-				data[w] = getSign(h, w) * ptr[w];
-			}
-			data += wbest;
-			ptr += pitch;
-		}
-	}
-
-
-	else		// not centered. So as it is 	
-	{
-		// values multiplied by -1^(x+y) i.e sign to get the spectogram centered in frame
-		for (size_t h = 0; h < ht; h++)
-		{
-			for (size_t w = 0; w < wd; w++)
-			{
-
-				data[w] = ptr[w];
-			}
-			data += wbest;
-			ptr += pitch;
-		}
-	}
-
-	// fill with zeroes rest of buffer
-	data = in + ht * wbest;
-	for (size_t h = ht; h < hbest; h++)
-	{
-		for (size_t w = 0; w < wbest; w++)
-		{
-
-			data[w] = 0.0;
-		}
-
-		data += wbest;
-	}
-
-	//	right margin
-
-	for (size_t w = wd; w < wbest; w++)
-	{
-		data = in + w;
-
-		for (size_t h = 0; h < hbest; h++)
-		{
-
-			data[0] = 0.0;
-
-			data += wbest;
-
-		}
-	}
-
+void getRealInput2D(float *in, const finc *ptr, int pitch, int ht, int wd,
+                    int hbest, int wbest, bool centered) {
+    // convert frame y values to float and keep in data buffer
+    float *data = in;
+    if(centered) {
+        // values multiplied by -1^(x+y) i.e sign to get the spectogram centered
+        // in frame
+        for(size_t h = 0; h < ht; h++) {
+            for(size_t w = 0; w < wd; w++) {
+
+                data[w] = getSign(h, w) * ptr[w];
+            }
+            data += wbest;
+            ptr += pitch;
+        }
+    }
+
+    else // not centered. So as it is
+    {
+        // values multiplied by -1^(x+y) i.e sign to get the spectogram centered
+        // in frame
+        for(size_t h = 0; h < ht; h++) {
+            for(size_t w = 0; w < wd; w++) {
+
+                data[w] = ptr[w];
+            }
+            data += wbest;
+            ptr += pitch;
+        }
+    }
+
+    // fill with zeroes rest of buffer
+    data = in + ht * wbest;
+    for(size_t h = ht; h < hbest; h++) {
+        for(size_t w = 0; w < wbest; w++) {
+
+            data[w] = 0.0;
+        }
+
+        data += wbest;
+    }
+
+    //	right margin
+
+    for(size_t w = wd; w < wbest; w++) {
+        data = in + w;
+
+        for(size_t h = 0; h < hbest; h++) {
+
+            data[0] = 0.0;
+
+            data += wbest;
+        }
+    }
 }
 //----------------------------------------------------------------------------
 template <typename finc>
-void getHMRealInput2D(float* in, const finc* ptr, int pitch, int ht,
-	int wd, int hbest, int wbest, bool centered, float * logLUT)
-{
-	int start = 1;
-	// convert frame y values to float and keep in data buffer
-	float* data = in;
-	if (centered)
-	{
-		if (logLUT == NULL)
-		{
-			// values multiplied by -1^(x+y) i.e sign to get the spectogram centered in frame
-			for (size_t h = 0; h < ht; h++)
-			{
-				for (size_t w = 0; w < wd; w++)
-				{
-
-					data[w] = start * log(2.0 + ptr[w]);
-					start = -start;
-				}
-				data += wbest;
-				ptr += pitch;
-			}
-		}
-
-		else //  logLUT is available
-		{
-			// values multiplied by -1^(x+y) i.e sign to get the spectogram centered in frame
-			for (size_t h = 0; h < ht; h++)
-			{
-				for (size_t w = 0; w < wd; w++)
-				{
-
-					data[w] = start * logLUT[(int) ptr[w]];
-					start = -start;
-				}
-				data += wbest;
-				ptr += pitch;
-			}
-		}
-	}
-
-
-	else		// not centered. So as it is 	
-	{
-		// values multiplied by -1^(x+y) i.e sign to get the spectogram centered in frame
-		for (size_t h = 0; h < ht; h++)
-		{
-			for (size_t w = 0; w < wd; w++)
-			{
-				if ( logLUT == NULL)
-					data[w] = log(2.0 + ptr[w]);
-				else
-					data[w] = logLUT[ (int)ptr[w]];
-			}
-			data += wbest;
-			ptr += pitch;
-		}
-	}
-
-	// fill with zeroes rest of buffer
-	for (size_t h = ht; h < hbest; h++)
-	{
-		for (size_t w = 0; w < wbest; w++)
-		{
-
-			data[w] = 0.0;
-		}
-
-		data += wbest;
-	}
-
-	//	right margin
-
-	for (size_t w = wd; w < wbest; w++)
-	{
-		data = in + w;
-
-		for (size_t h = 0; h < hbest; h++)
-		{
-
-			data[0] = 0.0;
-
-			data += wbest;
-
-		}
-	}
-
+void getHMRealInput2D(float *in, const finc *ptr, int pitch, int ht, int wd,
+                      int hbest, int wbest, bool centered, float *logLUT) {
+    int start = 1;
+    // convert frame y values to float and keep in data buffer
+    float *data = in;
+    if(centered) {
+        if(logLUT == NULL) {
+            // values multiplied by -1^(x+y) i.e sign to get the spectogram
+            // centered in frame
+            for(size_t h = 0; h < ht; h++) {
+                for(size_t w = 0; w < wd; w++) {
+
+                    data[w] = start * log(2.0 + ptr[w]);
+                    start = -start;
+                }
+                data += wbest;
+                ptr += pitch;
+            }
+        }
+
+        else //  logLUT is available
+        {
+            // values multiplied by -1^(x+y) i.e sign to get the spectogram
+            // centered in frame
+            for(size_t h = 0; h < ht; h++) {
+                for(size_t w = 0; w < wd; w++) {
+
+                    data[w] = start * logLUT[(int) ptr[w]];
+                    start = -start;
+                }
+                data += wbest;
+                ptr += pitch;
+            }
+        }
+    }
+
+    else // not centered. So as it is
+    {
+        // values multiplied by -1^(x+y) i.e sign to get the spectogram centered
+        // in frame
+        for(size_t h = 0; h < ht; h++) {
+            for(size_t w = 0; w < wd; w++) {
+                if(logLUT == NULL)
+                    data[w] = log(2.0 + ptr[w]);
+                else
+                    data[w] = logLUT[(int) ptr[w]];
+            }
+            data += wbest;
+            ptr += pitch;
+        }
+    }
+
+    // fill with zeroes rest of buffer
+    for(size_t h = ht; h < hbest; h++) {
+        for(size_t w = 0; w < wbest; w++) {
+
+            data[w] = 0.0;
+        }
+
+        data += wbest;
+    }
+
+    //	right margin
+
+    for(size_t w = wd; w < wbest; w++) {
+        data = in + w;
+
+        for(size_t h = 0; h < hbest; h++) {
+
+            data[0] = 0.0;
+
+            data += wbest;
+        }
+    }
 }
 
 //===============================================================================
 template <typename finc>
-void getRealOutput2D(float* in, finc* ptr, int pitch, int ht,
-	int wd, int hbest, int wbest,finc min,  finc max)
-{
-	for (int h = 0; h < ht; h++)
-	{
-		for (int w = 0; w < wd; w++)
-		{
-			ptr[w] = fclamp(in[w], min, max);
-		}
-		ptr += pitch;
-		in += wbest;
-	}
+void getRealOutput2D(float *in, finc *ptr, int pitch, int ht, int wd, int hbest,
+                     int wbest, finc min, finc max) {
+    for(int h = 0; h < ht; h++) {
+        for(int w = 0; w < wd; w++) {
+            ptr[w] = fclamp(in[w], min, max);
+        }
+        ptr += pitch;
+        in += wbest;
+    }
 }
 
 //===============================================================================
 template <typename finc>
-void getHMRealOutput2D(float* in, finc* dp, int pitch, int ht,
-	int wd, int hbest, int wbest,finc min, finc max)
-{
-	for (int h = 0; h < ht; h++)
-	{
-		for (int w = 0; w < wd; w++)
-		{
-			float val = exp(in[w]) - 2;
-
-			dp[w] = fclamp(val, min, max);
-		}
-		in += pitch;
-		dp += wbest;
-	}
+void getHMRealOutput2D(float *in, finc *dp, int pitch, int ht, int wd,
+                       int hbest, int wbest, finc min, finc max) {
+    for(int h = 0; h < ht; h++) {
+        for(int w = 0; w < wd; w++) {
+            float val = exp(in[w]) - 2;
+
+            dp[w] = fclamp(val, min, max);
+        }
+        in += pitch;
+        dp += wbest;
+    }
 }
 //----------------------------------------------------------------------------------------
 
-void ApplyFilter2D(fftwf_complex* out, float* filter, int hbest, int frqwd)
-{
-	// applies the designed filter.in freq domain just multiplication
-	// of freq response of designed filter with freq transform of input
-	int nval = hbest * frqwd;
-
-	for (int i = 0; i < nval; i++)
-	{
-		out[i][0] *= filter[i];
-		out[i][1] *= filter[i];
-	}
+void ApplyFilter2D(fftwf_complex *out, float *filter, int hbest, int frqwd) {
+    // applies the designed filter.in freq domain just multiplication
+    // of freq response of designed filter with freq transform of input
+    int nval = hbest * frqwd;
 
+    for(int i = 0; i < nval; i++) {
+        out[i][0] *= filter[i];
+        out[i][1] *= filter[i];
+    }
 }
 
 //-------------------------------------------------------------------------------------------------------
 
+void ApplyFilter(fftwf_complex *fout, float *Filter, int wd, int ht) {
+    // applies the designed filter.in freq domain. Scalar multiply
+    // of freq response of designed filter with freq transform of input
 
-void ApplyFilter(fftwf_complex* fout, float* Filter, int wd, int ht)
-{
-	// applies the designed filter.in freq domain. Scalar multiply
-	// of freq response of designed filter with freq transform of input
-
-//float scale = 1.0 / (hbest * wbest );
-	int nval = ht * wd;
-	for (int h = 0; h < nval; h++)
-
-	{
-		fout[h][0] *= Filter[h];
-		fout[h][1] *= Filter[h];
-
-	}
+    // float scale = 1.0 / (hbest * wbest );
+    int nval = ht * wd;
+    for(int h = 0; h < nval; h++)
 
+    {
+        fout[h][0] *= Filter[h];
+        fout[h][1] *= Filter[h];
+    }
 }
 //-------------------------------------------------------------------------------------------------------------------------
-void F2QhammingWindowing(float* cosBell, int pitch, int width, int height, int rfilt)
-{
-
-	// design a cosine bell hamming windowing function
-	int rfiltsq = rfilt * rfilt;
-	//	float rfilt = sqrt(rfiltsq );	
-
-	for (int h = 0; h < height / 2; h++)
-	{
-		for (int w = 0; w < width / 2; w++)
-		{
-			if (h * h + w * w <= rfiltsq)
-			{
-				float radial = sqrt((float)h * h + w * w);
-				float bell = 0.46 + 0.54 * cos((M_PI * radial) / rfilt);
-
-				for (int hh = -1; hh <= 1; hh += 2)
-				{
-					for (int ww = -1; ww <= 1; ww += 2)
-					{
-
-						cosBell[(height / 2 + h * hh) * pitch + width / 2 + w * ww] *= bell;
-					}
-				}
-			}
-
-			else
-			{
-				for (int hh = -1; hh <= 1; hh += 2)
-				{
-					for (int ww = -1; ww <= 1; ww += 2)
-					{
-
-						cosBell[(height / 2 + h * hh) * pitch + width / 2 + w * ww] *= 0.0;
-					}
-				}
-			}
-		}
-	}
+void F2QhammingWindowing(float *cosBell, int pitch, int width, int height,
+                         int rfilt) {
+
+    // design a cosine bell hamming windowing function
+    int rfiltsq = rfilt * rfilt;
+    //	float rfilt = sqrt(rfiltsq );
+
+    for(int h = 0; h < height / 2; h++) {
+        for(int w = 0; w < width / 2; w++) {
+            if(h * h + w * w <= rfiltsq) {
+                float radial = sqrt((float) h * h + w * w);
+                float bell = 0.46 + 0.54 * cos((M_PI * radial) / rfilt);
+
+                for(int hh = -1; hh <= 1; hh += 2) {
+                    for(int ww = -1; ww <= 1; ww += 2) {
+
+                        cosBell[(height / 2 + h * hh) * pitch + width / 2 +
+                                w * ww] *= bell;
+                    }
+                }
+            }
+
+            else {
+                for(int hh = -1; hh <= 1; hh += 2) {
+                    for(int ww = -1; ww <= 1; ww += 2) {
+
+                        cosBell[(height / 2 + h * hh) * pitch + width / 2 +
+                                w * ww] *= 0.0;
+                    }
+                }
+            }
+        }
+    }
 }
 //............................................................
-void removeInputCentering(float* inBuf, int wbest, int hbest)
-{	
-	float scale = 1.001 / (hbest * wbest);
-	for (int h = 0; h < hbest; h++)
-	{
-		for (int w = 0; w < wbest; w++)
-		{
-			inBuf[w] *= scale * getSign(h, w);
-		}
-		inBuf += wbest;
-	}
+void removeInputCentering(float *inBuf, int wbest, int hbest) {
+    float scale = 1.001 / (hbest * wbest);
+    for(int h = 0; h < hbest; h++) {
+        for(int w = 0; w < wbest; w++) {
+            inBuf[w] *= scale * getSign(h, w);
+        }
+        inBuf += wbest;
+    }
 }
 //......................................................................
 #endif
-
diff --git a/FQSharp.cpp b/FQSharp.cpp
index 26e5fce..1d7e2c1 100644
--- a/FQSharp.cpp
+++ b/FQSharp.cpp
@@ -2,14 +2,14 @@
 FQSharp filter plugin for vapoursynth by V.C.Mohan
 This filter operates in freq domain (2d) and improves image having blurred image
  due to camera /motion.
- 
+
    From the given x and y coordinates and type of blur an inverse filter using
    theoritical PSF is designed and applied.
 
-  White noise, radius of inverse operator in spatial domain are to control 
-  ringing. Scale is applied to bring image to acceptable levels.  
+  White noise, radius of inverse operator in spatial domain are to control
+  ringing. Scale is applied to bring image to acceptable levels.
 
-Author V.C.Mohan. 
+Author V.C.Mohan.
 11 jun 2015, 22 May 2021
   Copyright (C) <2008-2021>  <V.C.Mohan>
 
@@ -24,305 +24,325 @@ Author V.C.Mohan.
 
     A copy of the GNU General Public License is at
     see <http://www.gnu.org/licenses/>.
-	For details of how to contact author see <http://www.avisynth.org/vcmohan> 
+    For details of how to contact author see <http://www.avisynth.org/vcmohan>
 
 ********************************************************************************/
 /*
-#include <stdlib.h>
-#include "VapourSynth.h"
 #include "VSHelper.h"
+#include "VapourSynth.h"
 #include <math.h>
+#include <stdlib.h>
 //#include <complex>
 #include "fftwlite.h"
 
 #include "factorize.cpp"
 */
 
-typedef struct 
-{
+typedef struct {
     VSNodeRef *node;
     const VSVideoInfo *vi;
-	bool line;	//True: blur is linear . false : circular
-    int xcoord, ycoord; // if linear blur line end coordinates (symmetrical about origin). If circular radius
-	float wn;	// white noise to stabilize inversion.
-	int frad;	// radius of designed filter if ham is true
-	float scale; // scaling to compensate losses due to process. trial and error
-	bool plane[3];
-	bool ham;	// flag for hamming filter used along frad
-	
-	int wbest;				// nearest higher width for best speed of fft
-	int hbest;				// nearest higher height for best speed of fft
-	int fsize;				// input data size
-	int fqsize;				// size after fft in freq domain 
-	int frqwidth;
-	float * FreqFilter;		// This is the place designed filter resides	
-						
-	fftwf_plan  pf, pinv;			// forward and inverse fft plans for full frames
+    bool line;          // True: blur is linear . false : circular
+    int xcoord, ycoord; // if linear blur line end coordinates (symmetrical
+                        // about origin). If circular radius
+    float wn;           // white noise to stabilize inversion.
+    int frad;           // radius of designed filter if ham is true
+    float scale; // scaling to compensate losses due to process. trial and error
+    bool plane[3];
+    bool ham; // flag for hamming filter used along frad
+
+    int wbest;  // nearest higher width for best speed of fft
+    int hbest;  // nearest higher height for best speed of fft
+    int fsize;  // input data size
+    int fqsize; // size after fft in freq domain
+    int frqwidth;
+    float *FreqFilter; // This is the place designed filter resides
+
+    fftwf_plan pf, pinv; // forward and inverse fft plans for full frames
 #include "fftLateBindingClassParams.cpp"
-	float* inBuf;
-	fftwf_complex* outBuf;
+    float *inBuf;
+    fftwf_complex *outBuf;
 
 } F2QSharpData;
 //--------------------------------------------------------------------------------------
 template <typename finc>
-void sharpenPlane(F2QSharpData* d, const finc* sp, finc* dp, int pitch,
-					int height, int width, finc min, finc max);
+void sharpenPlane(F2QSharpData *d, const finc *sp, finc *dp, int pitch,
+                  int height, int width, finc min, finc max);
 //----------------------------------------------------------------------------
 
-
-// This function is called immediately after vsapi->createFilter(). This is the only place where the video
-// properties may be set. In this case we simply use the same as the input clip. You may pass an array
-// of VSVideoInfo if the filter has more than one output, like rgb+alpha as two separate clips.
-static void VS_CC f2qsharpInit(VSMap *in, VSMap *out, void **instanceData, VSNode *node, VSCore *core, const VSAPI *vsapi)
-{
-    F2QSharpData *d = (F2QSharpData *) * instanceData;
+// This function is called immediately after vsapi->createFilter(). This is the
+// only place where the video properties may be set. In this case we simply use
+// the same as the input clip. You may pass an array of VSVideoInfo if the
+// filter has more than one output, like rgb+alpha as two separate clips.
+static void VS_CC f2qsharpInit(VSMap *in, VSMap *out, void **instanceData,
+                               VSNode *node, VSCore *core, const VSAPI *vsapi) {
+    F2QSharpData *d = (F2QSharpData *) *instanceData;
     vsapi->setVideoInfo(d->vi, 1, node);
 
     const VSFormat *fi = d->vi->format;
-	if (fi->colorFamily == cmYUV && (fi->subSamplingH != 0 || fi->subSamplingW != 0))
-	{
-		d->plane[1] = false;
-		d->plane[2] = false;
-	}
-       
-			// frame dimensions
-	int fwd = d->vi->width;
+    if(fi->colorFamily == cmYUV &&
+       (fi->subSamplingH != 0 || fi->subSamplingW != 0)) {
+        d->plane[1] = false;
+        d->plane[2] = false;
+    }
+
+    // frame dimensions
+    int fwd = d->vi->width;
     int fht = d->vi->height;
 
-	if( d->ham)
-			// filter radius
-		d->frad = ((fwd > fht ? fht : fwd) * d->frad)/ 200;
+    if(d->ham)
+        // filter radius
+        d->frad = ((fwd > fht ? fht : fwd) * d->frad) / 200;
 
+    int *factorsbuf = new int[64]; // maximum 64 factors, first is factor,
+                                   // second is dividend to be factored. At
+    // make even number
+    d->wbest = getBestDim((((fwd + 3) >> 2) << 2) + ADDSAFE, factorsbuf);
 
-	int *factorsbuf = new int[64];	//maximum 64 factors, first is factor, second is dividend to be factored. At 
-	// make even number
-	d->wbest = getBestDim( (((fwd + 3 ) >> 2 ) << 2) + ADDSAFE, factorsbuf);
+    d->hbest = getBestDim((((fht + 3) >> 2) << 2) + ADDSAFE, factorsbuf);
 
-	d->hbest = getBestDim((((fht + 3) >> 2) << 2) + ADDSAFE, factorsbuf);
+    delete[] factorsbuf;
 
-	delete []factorsbuf;
+    d->frqwidth = d->wbest / 2 + 1;
 
-	d->frqwidth = d->wbest/2 + 1;
+    int nbits = fi->bitsPerSample;
 
-	int nbits = fi->bitsPerSample;	
-	
-	d->fsize = d->hbest * d->wbest;
-	int fqsize = d->hbest * d->frqwidth;
+    d->fsize = d->hbest * d->wbest;
+    int fqsize = d->hbest * d->frqwidth;
 
 #include "ConstructorCodeForLateBindingfft.cpp"
 
-	if (!ok)
-	{
-		vsapi->setError(out, "FQSharp: could not load any of the fft dll or get required fnctions");
-		if (d->hinstLib != NULL)
-			FreeLibrary(d->hinstLib);
-		vsapi->freeNode(d->node);
-		free(d);
-		return;
-	}
-	 
-	d->inBuf = (float*)d->fftwf_malloc(sizeof(float) * d->fsize);
+    if(!ok) {
+        vsapi->setError(out, "FQSharp: could not load any of the fft dll or "
+                             "get required fnctions");
+        // Error
+        // if (d->hinstLib != NULL)
+        //     FreeLibrary(d->hinstLib);
+        // Fix
+        if(d->hinstLib != nullptr) {
+#ifdef _WIN32
+            FreeLibrary((HINSTANCE) d->hinstLib);
+#else
+            dlclose(d->hinstLib);
+#endif
+        }
+
+        vsapi->freeNode(d->node);
+        free(d);
+        return;
+    }
+
+    d->inBuf = (float *) d->fftwf_malloc(sizeof(float) * d->fsize);
 
-	d->outBuf = (fftwf_complex*)d->fftwf_malloc (sizeof(fftwf_complex) * d->fqsize);// +1 is only a safeguard not really reqd
-	
-				// creates forward and inverse fft plans
-	d->FreqFilter = (float*)d->fftwf_malloc(sizeof(float) * d->fqsize);
-			//  forward for padded size complex to complex  
-	d->pf = d->fftwf_plan_dft_r2c_2d(d->hbest, d->wbest, d->inBuf, d->outBuf,  FFTW_MEASURE);
-			// inverse 
+    d->outBuf = (fftwf_complex *) d->fftwf_malloc(
+        sizeof(fftwf_complex) *
+        d->fqsize); // +1 is only a safeguard not really reqd
 
-	d->pinv = d->fftwf_plan_dft_c2r_2d(d->hbest, d->wbest, d->outBuf, d->inBuf,  FFTW_MEASURE);
+    // creates forward and inverse fft plans
+    d->FreqFilter = (float *) d->fftwf_malloc(sizeof(float) * d->fqsize);
+    //  forward for padded size complex to complex
+    d->pf = d->fftwf_plan_dft_r2c_2d(d->hbest, d->wbest, d->inBuf, d->outBuf,
+                                     FFTW_MEASURE);
+    // inverse
 
-			// draw PSF for the specified   blur value. 
+    d->pinv = d->fftwf_plan_dft_c2r_2d(d->hbest, d->wbest, d->outBuf, d->inBuf,
+                                       FFTW_MEASURE);
 
-	DrawPSF(d->inBuf, d->line, d-> xcoord, d-> ycoord, d->wbest, d->hbest, d->wn);	// we can add spike wn to mellow inversion
+    // draw PSF for the specified   blur value.
 
+    DrawPSF(d->inBuf, d->line, d->xcoord, d->ycoord, d->wbest, d->hbest,
+            d->wn); // we can add spike wn to mellow inversion
 
-				// forward transform
-	d->fftwf_execute(d->pf);
+    // forward transform
+    d->fftwf_execute(d->pf);
 
-			// make it zero phase
+    // make it zero phase
 
-	for( int i = 0; i < d->fqsize; i ++)
-	{			
-		d->outBuf[i][0] = sqrt (getAmpSquareOfComplex(d->outBuf + i));
-		d->outBuf[i][1] = 0.0;
-	}		
-		//	DesignInverse
+    for(int i = 0; i < d->fqsize; i++) {
+        d->outBuf[i][0] = sqrt(getAmpSquareOfComplex(d->outBuf + i));
+        d->outBuf[i][1] = 0.0;
+    }
+    //	DesignInverse
 
-	DesignInverse(d->outBuf, d->FreqFilter, d->wn, d->frqwidth, d->hbest,  d->scale);	
+    DesignInverse(d->outBuf, d->FreqFilter, d->wn, d->frqwidth, d->hbest,
+                  d->scale);
 
-	if (d->ham)
-	{
+    if(d->ham) {
 #include "hammingCodeInsert.cpp"
-	}
-/*	
-		
-			// hamming window as per filter radius in spatial domain
-	F2QhammingWindowing(d->inBuf, d->wbest, d->wbest, d->hbest, d->frad);
-
-			// forward transform into freq domain
-	d->fftwf_execute(d->pf);
-			// zero phase and also scale as it has gone twice transform
-	float scaler = 1.0 / ( d->hbest * d->wbest);
-
-	for(int i = 0; i < d->frqwidth * d->hbest; i ++)
-		d->FreqFilter[i] = scaler * sqrt (getAmpSquareOfComplex( d->outBuf + i) ); 
-*/		
-				// completed initializing
+    }
+    /*
+
+                // hamming window as per filter radius in spatial domain
+        F2QhammingWindowing(d->inBuf, d->wbest, d->wbest, d->hbest, d->frad);
+
+                // forward transform into freq domain
+        d->fftwf_execute(d->pf);
+                // zero phase and also scale as it has gone twice transform
+        float scaler = 1.0 / ( d->hbest * d->wbest);
+
+        for(int i = 0; i < d->frqwidth * d->hbest; i ++)
+            d->FreqFilter[i] = scaler * sqrt (getAmpSquareOfComplex( d->outBuf +
+       i) );
+    */
+    // completed initializing
 }
 //------------------------------------------------------------------------------------------------
 template <typename finc>
-void sharpenPlane(F2QSharpData* d, const finc * sp, finc * dp, int pitch,
-					 int height, int width, finc min, finc max)					
-{
-	getRealInput2D(d->inBuf, sp, pitch, height, width, d->hbest, d->wbest, false);
+void sharpenPlane(F2QSharpData *d, const finc *sp, finc *dp, int pitch,
+                  int height, int width, finc min, finc max) {
+    getRealInput2D(d->inBuf, sp, pitch, height, width, d->hbest, d->wbest,
+                   false);
 
-	d->fftwf_execute(d->pf);
+    d->fftwf_execute(d->pf);
 
-	ApplyFilter2D(d->outBuf, d->FreqFilter, d->hbest, d->frqwidth);
+    ApplyFilter2D(d->outBuf, d->FreqFilter, d->hbest, d->frqwidth);
 
-	d->fftwf_execute(d->pinv);
+    d->fftwf_execute(d->pinv);
 
-	getRealOutput2D(d->inBuf, dp, pitch, height, width,
-		 d->hbest, d->wbest, min, max);
+    getRealOutput2D(d->inBuf, dp, pitch, height, width, d->hbest, d->wbest, min,
+                    max);
 }
 
 //-----------------------------------------------------------------------------------------------
 
-// This is the main function that gets called when a frame should be produced. It will, in most cases, get
-// called several times to produce one frame. This state is being kept track of by the value of
-// activationReason. The first call to produce a certain frame n is always arInitial. In this state
-// you should request all the input frames you need. Always do it in ascending order to play nice with the
-// upstream filters.
-// Once all frames are ready, the filter will be called with arAllFramesReady. It is now time to
-// do the actual processing.
-static const VSFrameRef *VS_CC f2qsharpGetFrame(int n, int activationReason, void **instanceData, 
-		void **frameData, VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) 
-{
-    F2QSharpData *d = (F2QSharpData *) * instanceData;
-
-    if (activationReason == arInitial) 
-	{
+// This is the main function that gets called when a frame should be produced.
+// It will, in most cases, get called several times to produce one frame. This
+// state is being kept track of by the value of activationReason. The first call
+// to produce a certain frame n is always arInitial. In this state you should
+// request all the input frames you need. Always do it in ascending order to
+// play nice with the upstream filters. Once all frames are ready, the filter
+// will be called with arAllFramesReady. It is now time to do the actual
+// processing.
+static const VSFrameRef *VS_CC f2qsharpGetFrame(
+    int n, int activationReason, void **instanceData, void **frameData,
+    VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) {
+    F2QSharpData *d = (F2QSharpData *) *instanceData;
+
+    if(activationReason == arInitial) {
         // Request the source frame on the first call
         vsapi->requestFrameFilter(n, d->node, frameCtx);
-    } 
-	else if (activationReason == arAllFramesReady)	
-	{
-		
+    } else if(activationReason == arAllFramesReady) {
+
         const VSFrameRef *src = vsapi->getFrameFilter(n, d->node, frameCtx);
-		
-        // The reason we query this on a per frame basis is because we want our filter
-        // to accept clips with varying dimensions. If we reject such content using d->vi
-        // would be better.
+
+        // The reason we query this on a per frame basis is because we want our
+        // filter to accept clips with varying dimensions. If we reject such
+        // content using d->vi would be better.
         const VSFormat *fi = d->vi->format;
         int height = vsapi->getFrameHeight(src, 0);
         int width = vsapi->getFrameWidth(src, 0);
 
-        VSFrameRef *dst = vsapi->copyFrame( src, core);
-		
+        VSFrameRef *dst = vsapi->copyFrame(src, core);
+
         int nplanes = fi->numPlanes > 3 ? 3 : fi->numPlanes;
 
-		for (int plane = 0; plane < nplanes; plane++)
-		{
-			if ( ! d->plane[plane]) continue;
-			
+        for(int plane = 0; plane < nplanes; plane++) {
+            if(!d->plane[plane])
+                continue;
+
             const uint8_t *sp = vsapi->getReadPtr(src, plane);
             uint8_t *dp = vsapi->getWritePtr(dst, plane);
-            int stride = vsapi->getStride(dst, plane); // note that if a frame has the same dimensions and format, the stride is guaranteed to be the same. int dst_stride = src_stride would be fine too in this filter.
-            // Since planes may be subsampled you have to query the height of them individually
-            int height = vsapi->getFrameHeight(src, plane);            
+            int stride = vsapi->getStride(
+                dst, plane); // note that if a frame has the same dimensions and
+                             // format, the stride is guaranteed to be the same.
+                             // int dst_stride = src_stride would be fine too in
+                             // this filter.
+            // Since planes may be subsampled you have to query the height of
+            // them individually
+            int height = vsapi->getFrameHeight(src, plane);
             int width = vsapi->getFrameWidth(src, plane);
-			int kb = fi->bytesPerSample;
-			int pitch = stride / kb;
-			
-		// process image	
-			if(fi->sampleType == stInteger)
-			{
-				if(fi->bitsPerSample == 8)
-				{
-					uint8_t min = 0;
-					uint8_t max = 255;
-
-					sharpenPlane(d, sp, dp, pitch, height, width, min, max);
-				}
-				else
-				{	// 16 bit data
-					int nb = fi->bitsPerSample;
-					uint16_t min = 0;
-					uint16_t max = (1 << nb) - 1;
-					const uint16_t *srcp = (uint16_t *) sp;
-					uint16_t * dstp = (uint16_t *) dp;
-					
-					sharpenPlane(d, srcp, dstp, pitch, height, width, min, max);
-				}
-			}
-			else
-			{
-				// float data
-				float min = 0.0f;
-				float max = 1.0f;
-				if (fi->colorFamily == cmYUV && plane > 0)
-				{
-					min = -0.5f;
-					max = 0.5f;
-				}
-
-				const float* srcp = (float*)sp;
-				float* dstp = (float*)dp;
-
-				sharpenPlane(d, srcp, dstp, pitch, height, width, min, max);
-			}
-
-		}
-	
-		 // Release the source frame
+            int kb = fi->bytesPerSample;
+            int pitch = stride / kb;
+
+            // process image
+            if(fi->sampleType == stInteger) {
+                if(fi->bitsPerSample == 8) {
+                    uint8_t min = 0;
+                    uint8_t max = 255;
+
+                    sharpenPlane(d, sp, dp, pitch, height, width, min, max);
+                } else { // 16 bit data
+                    int nb = fi->bitsPerSample;
+                    uint16_t min = 0;
+                    uint16_t max = (1 << nb) - 1;
+                    const uint16_t *srcp = (uint16_t *) sp;
+                    uint16_t *dstp = (uint16_t *) dp;
+
+                    sharpenPlane(d, srcp, dstp, pitch, height, width, min, max);
+                }
+            } else {
+                // float data
+                float min = 0.0f;
+                float max = 1.0f;
+                if(fi->colorFamily == cmYUV && plane > 0) {
+                    min = -0.5f;
+                    max = 0.5f;
+                }
+
+                const float *srcp = (float *) sp;
+                float *dstp = (float *) dp;
+
+                sharpenPlane(d, srcp, dstp, pitch, height, width, min, max);
+            }
+        }
+
+        // Release the source frame
         vsapi->freeFrame(src);
-	
-        // A reference is consumed when it is returned, so saving the dst reference somewhere
-        // and reusing it is not allowed.
+
+        // A reference is consumed when it is returned, so saving the dst
+        // reference somewhere and reusing it is not allowed.
         return dst;
-	}
+    }
 
-	return 0;					
-							
+    return 0;
 }
 
 //----------------------------------------------------------------
 // Free all allocated data on filter destruction
-static void VS_CC f2qsharpFree(void *instanceData, VSCore *core, const VSAPI *vsapi) 
-{
-    F2QSharpData *d = (F2QSharpData *)instanceData;
-	
-	d->fftwf_destroy_plan(d->pf);
-	d->fftwf_destroy_plan(d->pinv);
+static void VS_CC f2qsharpFree(void *instanceData, VSCore *core,
+                               const VSAPI *vsapi) {
+    F2QSharpData *d = (F2QSharpData *) instanceData;
+
+    d->fftwf_destroy_plan(d->pf);
+    d->fftwf_destroy_plan(d->pinv);
     vsapi->freeNode(d->node);
-	// release buffers
-	d->fftwf_free(d->inBuf);
-	d->fftwf_free(d->outBuf);
-	d->fftwf_free(d->FreqFilter);	
-	FreeLibrary(d->hinstLib);
+    // release buffers
+    d->fftwf_free(d->inBuf);
+    d->fftwf_free(d->outBuf);
+    d->fftwf_free(d->FreqFilter);
+    // Error
+    // FreeLibrary(d->hinstLib);
+    // Fix
+    if(d->hinstLib != nullptr) {
+#ifdef _WIN32
+        FreeLibrary((HINSTANCE) d->hinstLib);
+#else
+        dlclose(d->hinstLib);
+#endif
+    }
+
     free(d);
 }
 //......................................................................................
 
-// This function is responsible for validating arguments and creating a new filter
-static void VS_CC f2qsharpCreate(const VSMap *in, VSMap *out, void *userData, VSCore *core, const VSAPI *vsapi) {
+// This function is responsible for validating arguments and creating a new
+// filter
+static void VS_CC f2qsharpCreate(const VSMap *in, VSMap *out, void *userData,
+                                 VSCore *core, const VSAPI *vsapi) {
     F2QSharpData d;
     F2QSharpData *data;
     int err;
-	int temp;
+    int temp;
     // Get a clip reference from the input arguments. This must be freed later.
     d.node = vsapi->propGetNode(in, "clip", 0, 0);
     d.vi = vsapi->getVideoInfo(d.node);
 
-    // In this first version we only want to handle 8bit integer formats. Note that
-    // vi->format can be 0 if the input clip can change format midstream.
-	if (!isConstantFormat(d.vi) && d.vi->format->colorFamily != cmRGB
-		&& d.vi->format->colorFamily != cmYUV
-		&& d.vi->format->colorFamily != cmGray)
-	{
-        vsapi->setError(out, "F2QSharp: Input clip must have constant dimensions and in YUV or RGB or Grey format");
+    // In this first version we only want to handle 8bit integer formats. Note
+    // that vi->format can be 0 if the input clip can change format midstream.
+    if(!isConstantFormat(d.vi) && d.vi->format->colorFamily != cmRGB &&
+       d.vi->format->colorFamily != cmYUV &&
+       d.vi->format->colorFamily != cmGray) {
+        vsapi->setError(out, "F2QSharp: Input clip must have constant "
+                             "dimensions and in YUV or RGB or Grey format");
         vsapi->freeNode(d.node);
         return;
     }
@@ -334,199 +354,179 @@ static void VS_CC f2qsharpCreate(const VSMap *in, VSMap *out, void *userData, VS
     // reason this could fail is when the value wasn't set by the user.
     // And when it's not set we want it to default to enabled.
     temp = !!vsapi->propGetInt(in, "line", 0, &err);
-    if (err)
-	{
+    if(err) {
         d.line = false;
-	}
-	else
-    // Let's pretend the only allowed values are 1 or 0...
-		if (temp < 0 || temp > 1)
-	{
-		vsapi->setError(out, "F2QSharp: line must be 0 (for circular blur) 1(for linear blur) ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-	else
-	{
-		if( temp == 1)
-			d.line = true;
-		else
-			d.line = false;
-	}
-	d.wn = (float)vsapi->propGetFloat(in, "wn", 0, &err);
-    if (err)
-	{
+    } else
+        // Let's pretend the only allowed values are 1 or 0...
+        if(temp < 0 || temp > 1) {
+            vsapi->setError(out, "F2QSharp: line must be 0 (for circular blur) "
+                                 "1(for linear blur) ");
+            vsapi->freeNode(d.node);
+            return;
+        } else {
+            if(temp == 1)
+                d.line = true;
+            else
+                d.line = false;
+        }
+    d.wn = (float) vsapi->propGetFloat(in, "wn", 0, &err);
+    if(err) {
         d.wn = 0.05f;
-	}
-	else if (d.wn < 0.0001f || d.wn > 0.99f)
-	{
-		vsapi->setError(out, "F2QSharp: white noise wn value can only be between 0.0001 and 0.99  ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-
-	d.xcoord = int64ToIntS(vsapi->propGetInt(in, "x", 0, &err));
-    if (err)
-	{
+    } else if(d.wn < 0.0001f || d.wn > 0.99f) {
+        vsapi->setError(out, "F2QSharp: white noise wn value can only be "
+                             "between 0.0001 and 0.99  ");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    d.xcoord = int64ToIntS(vsapi->propGetInt(in, "x", 0, &err));
+    if(err) {
         d.xcoord = 2;
-	}
-	else
-    //  the only allowed values are 
-		if ( (d.line && d.xcoord < 0) || d.xcoord > d.vi->width / 8 || ( !d.line && d.xcoord < 1))
-	{
-		vsapi->setError(out, "F2QSharp: x coordinate can have a value from 0 for line and 1 for circular blur to 1/8th frame width only ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-
-	d.ycoord = int64ToIntS(vsapi->propGetInt(in, "y", 0, &err));
-    if (err)
-	{
+    } else
+        //  the only allowed values are
+        if((d.line && d.xcoord < 0) || d.xcoord > d.vi->width / 8 ||
+           (!d.line && d.xcoord < 1)) {
+            vsapi->setError(
+                out, "F2QSharp: x coordinate can have a value from 0 for line "
+                     "and 1 for circular blur to 1/8th frame width only ");
+            vsapi->freeNode(d.node);
+            return;
+        }
+
+    d.ycoord = int64ToIntS(vsapi->propGetInt(in, "y", 0, &err));
+    if(err) {
         d.ycoord = 2;
-	}
-	else
-    //  the only allowed values are 
-		if ( d.ycoord <  - d.vi->height / 8 ||  d.ycoord  > d.vi->height / 8)
-	{
-		vsapi->setError(out, "F2QSharp: y coordinate can have a value between plus and minus 1/8th frame height only ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-	if ( d.xcoord == 0 && d.ycoord == 0)
-	{
-		vsapi->setError(out, "F2QSharp: both x and y coordinate must not be zeroes ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-	
-	temp = !!int64ToIntS(vsapi->propGetInt(in, "ham", 0, &err));
-	d.ham = err ||temp == 0 ? false : true;
-
-	if (d.ham)
-	{
-		d.frad = int64ToIntS(vsapi->propGetInt(in, "frad", 0, &err));
-		if (err)
-		{
-			d.frad = 30;
-		}
-		else if (d.frad < 10 || d.frad > 50)
-		{
-			vsapi->setError(out, "F2QSharp: filter radius %age of smaller dimension of frame, can have a value of 10 to 50 only ");
-			vsapi->freeNode(d.node);
-			return;
-		}
-	}
-
-	d.scale = (float)vsapi->propGetFloat(in, "scale", 0, &err);
-    if (err)
-	{
+    } else
+        //  the only allowed values are
+        if(d.ycoord < -d.vi->height / 8 || d.ycoord > d.vi->height / 8) {
+            vsapi->setError(out,
+                            "F2QSharp: y coordinate can have a value between "
+                            "plus and minus 1/8th frame height only ");
+            vsapi->freeNode(d.node);
+            return;
+        }
+    if(d.xcoord == 0 && d.ycoord == 0) {
+        vsapi->setError(
+            out, "F2QSharp: both x and y coordinate must not be zeroes ");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    temp = !!int64ToIntS(vsapi->propGetInt(in, "ham", 0, &err));
+    d.ham = err || temp == 0 ? false : true;
+
+    if(d.ham) {
+        d.frad = int64ToIntS(vsapi->propGetInt(in, "frad", 0, &err));
+        if(err) {
+            d.frad = 30;
+        } else if(d.frad < 10 || d.frad > 50) {
+            vsapi->setError(out,
+                            "F2QSharp: filter radius %age of smaller dimension "
+                            "of frame, can have a value of 10 to 50 only ");
+            vsapi->freeNode(d.node);
+            return;
+        }
+    }
+
+    d.scale = (float) vsapi->propGetFloat(in, "scale", 0, &err);
+    if(err) {
         d.scale = 0.45f;
-	}
-	else if (d.scale < 0.000001f || d.scale > 1000000.0f)
-	{
-		vsapi->setError(out, "F2QSharp: scale value must be between 0.000001 and 1000000");
-		vsapi->freeNode(d.node);
-		return;
-	}
-	if (d.vi->format->colorFamily == cmRGB)
-	{
-		int ntemp = vsapi->propNumElements(in, "rgb");
-		if (ntemp == 0)
-		{
-			d.plane[0] = true;
-			d.plane[1] = true;
-			d.plane[2] = true;
-		}
-		else if ( ntemp > 3)
-		{ 
-			vsapi->setError(out, "F2QSharp: rgb array can not have more than 3 values");
-			vsapi->freeNode(d.node);
-			return;
-		}
-		else
-		{
-			temp = !!int64ToIntS(vsapi->propGetInt(in, "rgb", 0, &err));
-			d.plane[0] = temp == 0 ? false : true;
-		}
-
-		for (int i = 1; i < 3; i++)
-		{
-			temp = !!int64ToIntS(vsapi->propGetInt(in, "rgb", i, &err));
-			if (err)
-				d.plane[i] = d.plane[i - 1];
-			else
-				d.plane[i] = temp == 0 ? false : true;
-
-		}
-		// as rgb planes are in the order of bgr internally correct here
-		bool rgb = d.plane[0];
-		d.plane[0] = d.plane[2];
-		d.plane[2] = rgb;
-	}
-
-	else if (d.vi->format->colorFamily == cmYUV)
-	{
-		int ntemp = vsapi->propNumElements(in, "yuv");
-		if (ntemp == 0)
-		{
-			d.plane[0] = true;
-			d.plane[1] = false;
-			d.plane[2] = false;
-		}
-		else if (ntemp > 3)
-		{
-			vsapi->setError(out, "F2QSharp: yuv array can not have more than 3 values");
-			vsapi->freeNode(d.node);
-			return;
-		}
-		else
-		{
-			temp = !!int64ToIntS(vsapi->propGetInt(in, "yuv", 0, &err));
-			d.plane[0] = temp == 0 ? false : true;
-		}
-
-		for (int i = 1; i < 3; i++)
-		{
-			temp = !!int64ToIntS(vsapi->propGetInt(in, "yuv", i, &err));
-			if (err)
-				d.plane[i] = d.plane[i - 1];
-			else
-				d.plane[i] = temp == 0 ? false : true;
-
-		}
-	}
+    } else if(d.scale < 0.000001f || d.scale > 1000000.0f) {
+        vsapi->setError(
+            out, "F2QSharp: scale value must be between 0.000001 and 1000000");
+        vsapi->freeNode(d.node);
+        return;
+    }
+    if(d.vi->format->colorFamily == cmRGB) {
+        int ntemp = vsapi->propNumElements(in, "rgb");
+        if(ntemp == 0) {
+            d.plane[0] = true;
+            d.plane[1] = true;
+            d.plane[2] = true;
+        } else if(ntemp > 3) {
+            vsapi->setError(
+                out, "F2QSharp: rgb array can not have more than 3 values");
+            vsapi->freeNode(d.node);
+            return;
+        } else {
+            temp = !!int64ToIntS(vsapi->propGetInt(in, "rgb", 0, &err));
+            d.plane[0] = temp == 0 ? false : true;
+        }
+
+        for(int i = 1; i < 3; i++) {
+            temp = !!int64ToIntS(vsapi->propGetInt(in, "rgb", i, &err));
+            if(err)
+                d.plane[i] = d.plane[i - 1];
+            else
+                d.plane[i] = temp == 0 ? false : true;
+        }
+        // as rgb planes are in the order of bgr internally correct here
+        bool rgb = d.plane[0];
+        d.plane[0] = d.plane[2];
+        d.plane[2] = rgb;
+    }
+
+    else if(d.vi->format->colorFamily == cmYUV) {
+        int ntemp = vsapi->propNumElements(in, "yuv");
+        if(ntemp == 0) {
+            d.plane[0] = true;
+            d.plane[1] = false;
+            d.plane[2] = false;
+        } else if(ntemp > 3) {
+            vsapi->setError(
+                out, "F2QSharp: yuv array can not have more than 3 values");
+            vsapi->freeNode(d.node);
+            return;
+        } else {
+            temp = !!int64ToIntS(vsapi->propGetInt(in, "yuv", 0, &err));
+            d.plane[0] = temp == 0 ? false : true;
+        }
+
+        for(int i = 1; i < 3; i++) {
+            temp = !!int64ToIntS(vsapi->propGetInt(in, "yuv", i, &err));
+            if(err)
+                d.plane[i] = d.plane[i - 1];
+            else
+                d.plane[i] = temp == 0 ? false : true;
+        }
+    }
 
     // I usually keep the filter data struct on the stack and don't allocate it
     // until all the input validation is done.
-    data = (F2QSharpData*)malloc(sizeof(d));
+    data = (F2QSharpData *) malloc(sizeof(d));
     *data = d;
 
-    // Creates a new filter and returns a reference to it. Always pass on the in and out
-    // arguments or unexpected things may happen. The name should be something that's
-    // easy to connect to the filter, like its function name.
-    // The three function pointers handle initialization, frame processing and filter destruction.
-    // The filtermode is very important to get right as it controls how threading of the filter
-    // is handled. In general you should only use fmParallel whenever possible. This is if you
-    // need to modify no shared data at all when the filter is running.
-    // For more complicated filters, fmParallelRequests is usually easier to achieve as it can
-    // be prefetched in parallel but the actual processing is serialized.
-    // The others can be considered special cases where fmSerial is useful to source filters and
-    // fmUnordered is useful when a filter's state may change even when deciding which frames to
-    // prefetch (such as a cache filter).
-    // If your filter is really fast (such as a filter that only resorts frames) you should set the
-    // nfNoCache flag to make the caching work smoother.
-
-	vsapi->createFilter(in, out, "F2QSharp", f2qsharpInit, f2qsharpGetFrame, f2qsharpFree, fmParallelRequests, 0, data, core);
-
+    // Creates a new filter and returns a reference to it. Always pass on the in
+    // and out arguments or unexpected things may happen. The name should be
+    // something that's easy to connect to the filter, like its function name.
+    // The three function pointers handle initialization, frame processing and
+    // filter destruction. The filtermode is very important to get right as it
+    // controls how threading of the filter is handled. In general you should
+    // only use fmParallel whenever possible. This is if you need to modify no
+    // shared data at all when the filter is running. For more complicated
+    // filters, fmParallelRequests is usually easier to achieve as it can be
+    // prefetched in parallel but the actual processing is serialized. The
+    // others can be considered special cases where fmSerial is useful to source
+    // filters and fmUnordered is useful when a filter's state may change even
+    // when deciding which frames to prefetch (such as a cache filter). If your
+    // filter is really fast (such as a filter that only resorts frames) you
+    // should set the nfNoCache flag to make the caching work smoother.
+
+    vsapi->createFilter(in, out, "F2QSharp", f2qsharpInit, f2qsharpGetFrame,
+                        f2qsharpFree, fmParallelRequests, 0, data, core);
 }
 /*
-// The following function is the function that actually registers the filter in AviSynth
-// It is called automatically, when the plugin is loaded to see which functions this filter contains.
+// The following function is the function that actually registers the filter in
+AviSynth
+// It is called automatically, when the plugin is loaded to see which functions
+this filter contains.
+
 
+    registerFunc("Sharp",
+"clip:clip;line:int:opt;wn:float:opt;x:int:opt;y:int:opt;ham:int:opt;frad:int:opt;scale:float:opt;rgb:int[]:opt;yuv:int[]:opt;",
+Create_FQSharp, 0);
 
-    registerFunc("Sharp", "clip:clip;line:int:opt;wn:float:opt;x:int:opt;y:int:opt;ham:int:opt;frad:int:opt;scale:float:opt;rgb:int[]:opt;yuv:int[]:opt;", Create_FQSharp, 0);
-					
-    
 
 
-*/
\ No newline at end of file
+
+*/
diff --git a/Fisheye.cpp b/Fisheye.cpp
index ea82e0b..f4d25c8 100644
--- a/Fisheye.cpp
+++ b/Fisheye.cpp
@@ -11,625 +11,614 @@ Material from Wikipedia used for barrel and pincushion corrections
  15 oct 2021
 Copyright (C) <2021>  <V.C.Mohan>
 
-	This program is free software: you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation, version 3 of the License.
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, version 3 of the License.
 
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
 
-	A copy of the GNU General Public License is at
-	see <http://www.gnu.org/licenses/>.
+    A copy of the GNU General Public License is at
+    see <http://www.gnu.org/licenses/>.
 
-	For details of how to contact author see <http://www.avisynth.nl/users/vcmohan/vcmohan.html>
+    For details of how to contact author see
+<http://www.avisynth.nl/users/vcmohan/vcmohan.html>
 
 
 ********************************************************************************/
 
-//#include "windows.h"
-//#include <stdint.h>const finc* sp,
-// #define _USE_MATH_DEFINES
-//#include "math.h"
-//#include "InterpolationPack.h"
+// #include "windows.h"
+// #include <stdint.h>const finc* sp,
+//  #define _USE_MATH_DEFINES
+// #include "math.h"
+// #include "InterpolationPack.h"
 //
-//#include "VapourSynth.h"
+// #include "VapourSynth.h"
 //
 
 //-------------------------------------------------------------------------
 typedef struct {
-	VSNodeRef* node;	
-	const VSVideoInfo* ivi;
-	VSVideoInfo vi;
-	
-	// starting or constant for x and y or for x alone coefficients
-	int origin_y;
-	int origin_x;
-	bool test;	// whether a test run
-	
-	int dots;	// dot density 1 for 16, 2 for 12, 3 for 8, 4 for 4.
-	int method;
-	float dim;
-	double fov;
-	double rix;
-	int frad, fdia;
-	int oRadius;
-	int q;		// type of interpolation. 0 near pt, 1 ninept 2x2, 2 bilenear 2x2, 3 cubic 3x3, 4 lanczos 6x6
-	bool sqr;	// is squaring circle required?
-	float* iCoeff;
-	int ddensity;	// pixel interval of dots of 
-	int quantile;	// Accuracy of fraction to which values are interpolated
-	int span;		// interpolation function 1d span or taps
-	unsigned char col[16];		// color components for fill
-	int* xyAndQ;
-	double rNorm;
-	int nEntries;
+    VSNodeRef *node;
+    const VSVideoInfo *ivi;
+    VSVideoInfo vi;
+
+    // starting or constant for x and y or for x alone coefficients
+    int origin_y;
+    int origin_x;
+    bool test; // whether a test run
+
+    int dots; // dot density 1 for 16, 2 for 12, 3 for 8, 4 for 4.
+    int method;
+    float dim;
+    double fov;
+    double rix;
+    int frad, fdia;
+    int oRadius;
+    int q; // type of interpolation. 0 near pt, 1 ninept 2x2, 2 bilenear 2x2, 3
+           // cubic 3x3, 4 lanczos 6x6
+    bool sqr; // is squaring circle required?
+    float *iCoeff;
+    int ddensity; // pixel interval of dots of
+    int quantile; // Accuracy of fraction to which values are interpolated
+    int span;     // interpolation function 1d span or taps
+    unsigned char col[16]; // color components for fill
+    int *xyAndQ;
+    double rNorm;
+    int nEntries;
 } FisheyeData;
 
-
-//void getSquircleUV(float* cUV, int sqW, int sqH, int rad);
-//#include "CorrectLD.cpp"
+// void getSquircleUV(float* cUV, int sqW, int sqH, int rad);
+// #include "CorrectLD.cpp"
 #include "FisheyePart.cpp"
 
 /*--------------------------------------------------
  * The following is the implementation
  * of the defined functions.
  --------------------------------------------------*/
- //Here is the acutal constructor code used
-
-static void VS_CC fisheyeInit(VSMap* in, VSMap* out, void** instanceData, VSNode* node, VSCore* core, const VSAPI* vsapi)
-{
-	FisheyeData* d = (FisheyeData*)*instanceData;	
-	d->frad = d->fdia / 2;
-	d->oRadius = d->frad;
-
-	double focal = getFocalLength(d->frad, d->method, d->fov);
-
-	d->oRadius = getOutputRadius(d->frad, focal, d->rix);
-	
-	if (!d->test)
-	{
-		d->vi.format = d->ivi->format;
-		d->vi.numFrames = d->ivi->numFrames;
-		d->vi.fpsDen = d->ivi->fpsDen;
-		d->vi.fpsNum = d->ivi->fpsNum;
-		d->vi.flags = d->ivi->flags;
-		d->vi.height = d->oRadius * 2;
-		d->vi.width = d->oRadius * 2;
-
-		vsapi->setVideoInfo(&d->vi, 1, node);
-	}
-	else
-	{
-		// in test  frame dimensions remain unaltered
-		vsapi->setVideoInfo(d->ivi, 1, node);
-	}
-	
-	
-	// input frame dimensions
-	int swidth = d->ivi->width;
-	int sheight = d->ivi->height;
-	int frsq = d->frad * d->frad;
-	// output
-	int ht = d->oRadius * 2;
-	int wd = d->oRadius * 2;
-	const VSFormat* fi = d->vi.format;
-	int nbytes = fi->bytesPerSample;
-	int nbits = fi->bitsPerSample;
-	d->quantile = 64;
-	int nEntries = d->test ? 2 :d->q == 1? 3: 4;	
-		
-	d->xyAndQ = (int*)vs_aligned_malloc<int>(sizeof(int) * d->oRadius * d->oRadius * nEntries, 32);
-
-	int* xyQ = d->xyAndQ;
-	float xy[2];
-	int x, y, qx, qy;	
-
-	d->iCoeff = NULL;
-
-	if ( ! d->test)
-		d->iCoeff = setInterpolationScheme(d->q, d->quantile, &d->span);
-
-	d->rNorm = (double)d->frad;
-	
-	//terms Barrel and Pincushion distortions are usually associated to longer focal lengths 
-	// and fish eye to wide angle(shorter focal length) lenses
-	
-	float cUV[2]; // corresponding circle coordinates
-	for (int h = 0; h < d->oRadius; h++)
-	{
-
-		for (int w = 0; w < d->oRadius; w++)
-		{
-			if (d->sqr )
-			{
-				getSquircleUV(cUV, w, h, d->oRadius);
-			}
-			else
-			{
-				cUV[0] = (float)w;
-				cUV[1] = (float)h;
-			}
-
-
-			getSourceXY(xy, cUV[0], cUV[1], d->method, focal, d->rNorm, d->rix);
-
-			x = (int)floor(xy[0]);
-			y = (int)floor(xy[1]);
-
-			int off = nEntries * (h * d->oRadius + w);
-
-			if (x >= swidth / 2 || y >= sheight / 2 || x < 0 || y < 0
-				|| x * x + y * y > frsq)
-			{
-				xyQ[off] = - 1;
-			}
-			else
-			{
-				// calculate nearest quantile of the fraction
-				qx = (int)((xy[0] - x) * d->quantile);
-				qy = (int)((xy[1] - y) * d->quantile);
-				xyQ[off] = x;
-				xyQ[off + 1] = y;
-
-				if (!d->test)
-				{
-					if (d->q > 1)
-					{
-						xyQ[off + 2] = qx;
-						xyQ[off + 3] = qy;
-					}
-					else
-						// index value
-						xyQ[off + 2] = bestOfNineIndex(qx, qy, d->quantile);
-				}
-			}
-		}
-	}
-	// color to blacken out of area points
-	uint8_t bgr[] = { 0,0,0 }, yuv[] = { 16,128,128 };
-
-	if (d->test)
-	{
-		// will have white dots
-		d->ddensity = (5 - d->dots) * 16;
-		bgr[0] = 255;
-		bgr[1] = 255;
-		bgr[2] = 255;		
-	}
-	
-	convertBGRforInputFormat(d->col, bgr, fi);
+// Here is the acutal constructor code used
+
+static void VS_CC fisheyeInit(VSMap *in, VSMap *out, void **instanceData,
+                              VSNode *node, VSCore *core, const VSAPI *vsapi) {
+    FisheyeData *d = (FisheyeData *) *instanceData;
+    d->frad = d->fdia / 2;
+    d->oRadius = d->frad;
+
+    double focal = getFocalLength(d->frad, d->method, d->fov);
+
+    d->oRadius = getOutputRadius(d->frad, focal, d->rix);
+
+    if(!d->test) {
+        d->vi.format = d->ivi->format;
+        d->vi.numFrames = d->ivi->numFrames;
+        d->vi.fpsDen = d->ivi->fpsDen;
+        d->vi.fpsNum = d->ivi->fpsNum;
+        d->vi.flags = d->ivi->flags;
+        d->vi.height = d->oRadius * 2;
+        d->vi.width = d->oRadius * 2;
+
+        vsapi->setVideoInfo(&d->vi, 1, node);
+    } else {
+        // in test  frame dimensions remain unaltered
+        vsapi->setVideoInfo(d->ivi, 1, node);
+    }
+
+    // input frame dimensions
+    int swidth = d->ivi->width;
+    int sheight = d->ivi->height;
+    int frsq = d->frad * d->frad;
+    // output
+    int ht = d->oRadius * 2;
+    int wd = d->oRadius * 2;
+    const VSFormat *fi = d->vi.format;
+    int nbytes = fi->bytesPerSample;
+    int nbits = fi->bitsPerSample;
+    d->quantile = 64;
+    int nEntries = d->test ? 2 : d->q == 1 ? 3 : 4;
+
+    d->xyAndQ = (int *) vs_aligned_malloc<int>(
+        sizeof(int) * d->oRadius * d->oRadius * nEntries, 32);
+
+    int *xyQ = d->xyAndQ;
+    float xy[2];
+    int x, y, qx, qy;
+
+    d->iCoeff = NULL;
+
+    if(!d->test)
+        d->iCoeff = setInterpolationScheme(d->q, d->quantile, &d->span);
+
+    d->rNorm = (double) d->frad;
+
+    // terms Barrel and Pincushion distortions are usually associated to longer
+    // focal lengths
+    //  and fish eye to wide angle(shorter focal length) lenses
+
+    float cUV[2]; // corresponding circle coordinates
+    for(int h = 0; h < d->oRadius; h++) {
+
+        for(int w = 0; w < d->oRadius; w++) {
+            if(d->sqr) {
+                getSquircleUV(cUV, w, h, d->oRadius);
+            } else {
+                cUV[0] = (float) w;
+                cUV[1] = (float) h;
+            }
+
+            getSourceXY(xy, cUV[0], cUV[1], d->method, focal, d->rNorm, d->rix);
+
+            x = (int) floor(xy[0]);
+            y = (int) floor(xy[1]);
+
+            int off = nEntries * (h * d->oRadius + w);
+
+            if(x >= swidth / 2 || y >= sheight / 2 || x < 0 || y < 0 ||
+               x * x + y * y > frsq) {
+                xyQ[off] = -1;
+            } else {
+                // calculate nearest quantile of the fraction
+                qx = (int) ((xy[0] - x) * d->quantile);
+                qy = (int) ((xy[1] - y) * d->quantile);
+                xyQ[off] = x;
+                xyQ[off + 1] = y;
+
+                if(!d->test) {
+                    if(d->q > 1) {
+                        xyQ[off + 2] = qx;
+                        xyQ[off + 3] = qy;
+                    } else
+                        // index value
+                        xyQ[off + 2] = bestOfNineIndex(qx, qy, d->quantile);
+                }
+            }
+        }
+    }
+    // color to blacken out of area points
+    uint8_t bgr[] = {0, 0, 0}, yuv[] = {16, 128, 128};
+
+    if(d->test) {
+        // will have white dots
+        d->ddensity = (5 - d->dots) * 16;
+        bgr[0] = 255;
+        bgr[1] = 255;
+        bgr[2] = 255;
+    }
+
+    convertBGRforInputFormat(d->col, bgr, fi);
 }
 //------------------------------------------------------------------------------------------------
 
-static const VSFrameRef* VS_CC fisheyeGetFrame(int n, int activationReason, void** instanceData,
-	void** frameData, VSFrameContext* frameCtx, VSCore* core, const VSAPI* vsapi)
-{
-	FisheyeData* d = (FisheyeData*)*instanceData;
-
-	if (activationReason == arInitial)
-	{
-		vsapi->requestFrameFilter(n, d->node, frameCtx);
-	}
-	else if (activationReason == arAllFramesReady)
-	{
-		const VSFrameRef* src = vsapi->getFrameFilter(n, d->node, frameCtx);
-		VSFrameRef* dst;
-		const VSFormat* fi = d->ivi->format;
-		int sheight = vsapi->getFrameHeight(src, 0);
-		int swidth = vsapi->getFrameWidth(src, 0);
-		int nbits = fi->bitsPerSample;
-		int nbytes = fi->bytesPerSample;
-		//will not process A plane
-		int np = fi->numPlanes > 3 ? 3 : fi->numPlanes;
-		int dwidth = d->vi.width;
-		int dheight = d->vi.height;
-		
-		int kb = 1;
-
-		if (d->test)
-			// get src on which dots will be overlain			
-			dst = vsapi->copyFrame(src, core);
-		else
-			dst = vsapi->newVideoFrame(fi, dwidth, dheight, src, core);
-
-		dwidth = vsapi->getFrameWidth(dst, 0);
-		dheight = vsapi->getFrameHeight(dst, 0);
-
-		int frsq = d->frad * d->frad;
-
-		for (int p = 0; p < np; p++)
-		{
-
-			const uint8_t* sp = vsapi->getReadPtr(src, p);
-			uint8_t* dp = vsapi->getWritePtr(dst, p);
-			int spitch = vsapi->getStride(src, p) / nbytes;
-			int dpitch = vsapi->getStride(dst, p) / nbytes;
-			// number of entries per row in the xyAndQ buffer
-			int nEntries = d->test ? 2 : d->q == 1 ? 3 : 4;
-
-			if (d->test)
-			{
-				
-				if (fi->colorFamily == cmRGB)
-				{
-					if (nbytes == 1)
-						dimplaneRGB(dp, sp, spitch, swidth, sheight, d->dim);
-					else if (nbytes == 2)
-						dimplaneRGB((uint16_t*)dp, (uint16_t*)sp, spitch, swidth, sheight, d->dim);
-					else if (nbytes == 4)
-						dimplaneRGB((float*)dp, (float*)sp, spitch, swidth, sheight, d->dim);
-				}
-
-				else if ( p == 0 && fi->colorFamily == cmYUV)
-				{
-					if (nbytes == 1)
-					{
-						uint8_t limit = (uint8_t)16;
-						dimplaneYUV(dp, dp, dpitch, dwidth, dheight, d->dim, limit);
-					}
-					else if (nbytes == 2)
-					{
-						uint16_t limit = (uint16_t)(16 << (nbits - 8));
-						dimplaneYUV((uint16_t*)dp, (uint16_t*)dp, dpitch, dwidth, dheight, d->dim, limit);
-					}
-					else if (nbytes == 4)
-						dimplaneYUV((float*)dp, (float*)dp, dpitch, dwidth, dheight, d->dim, 0.0f);
-				}
-
-				
-				int frsq = d->frad * d->frad;
-				int iCenter = d->origin_y * spitch + d->origin_x;
-				
-					// we will put dots
-				for (int h = d->ddensity / 2; h < d->oRadius; h += d->ddensity)
-				{
-					int hoff = nEntries * h * d->oRadius;
-
-					for (int w = d->ddensity / 2; w < d->oRadius; w += d->ddensity)
-					{
-						int woff = nEntries * w;
-
-						int x = d->xyAndQ[hoff + woff];
-						int y = d->xyAndQ[hoff + woff + 1];
-						// ensure points are within frame
-						if (x >= d->frad || y >= d->frad || x < 0 || y < 0)
-							continue;
-						// ensure points are within src / fish eye						
-						if ( x * x + y * y <= frsq)
-						{
-							if (nbytes == 1)
-								paint4FoldSym(dp + iCenter, dpitch,1, x, y, d->col[p]);
-							else if (nbytes == 2)
-								paint4FoldSym( (uint16_t*)dp + iCenter, dpitch,1, x, y, *((uint16_t*)d->col + p) );
-							else if (nbytes == 4)
-								paint4FoldSym((float*)dp + iCenter, dpitch,1, x, y, *((float*)d->col + p) );
-						}
-						
-					}
-
-				}
-				
-			}	// if test
-
-			else	// not test. normal processing
-			{	
-				int iCenter = d->origin_y * spitch + d->origin_x;
-				int oCenter = d->oRadius * dpitch + d->oRadius;
-				
-				uint8_t min8 = 0, max8 = (uint8_t)255;
-				uint16_t min16 = (uint16_t)(fi->colorFamily == cmYUV ? 16 << (nbits - 8) : 0);
-				uint16_t max16 = (uint16_t)((fi->colorFamily == cmYUV ? 235 : 255 << (nbits - 8)) << (nbits - 8));
-				float minf = 0, maxf = 1.0f;
-
-				if (p > 0 && fi->colorFamily == cmYUV)
-				{
-					minf = -0.5f;
-					maxf = 0.5f;
-				}
-				int x, y, qx, qy,  span2 = d->span / 2;
-				int offh, offw;
-				int index;
-				int frsq = d->frad * d->frad;
-
-				for (int h = 0; h < d->oRadius - 1; h++)
-				{
-					offh = h * d->oRadius * nEntries;
-
-					for (int w = 0; w < d->oRadius - 1; w++)
-					{				
-						offw = nEntries * w;
-
-						x = d->xyAndQ[offh + offw];
-						y = d->xyAndQ[offh + offw + 1];
-
-						if (d->q > 1)
-						{
-							qx = d->xyAndQ[offh + offw + 2];
-							qy = d->xyAndQ[offh + offw + 3];
-						}
-						else
-							index = d->xyAndQ[offh + offw + 2];
-						// was checked in init
-						//if (x >= swidth / 2   || y >= sheight / 2  || x < 0 || y < 0
-						//	|| x * x + y * y > frsq)
-						if ( x < 0)
-						{
-							// points are outside  src or fish. So make the point black
-							if (nbytes == 1)
-								paint4FoldSym(dp + oCenter, dpitch,1, w, h, d->col[p]);
-							else if (nbytes == 2)
-								paint4FoldSym((uint16_t*)dp + oCenter, dpitch, 1, w, h, *((uint16_t*)d->col + p));
-							else if (nbytes == 4)
-								paint4FoldSym((float*)dp + oCenter, dpitch, 1, w, h, *((float*)d->col + p));
-						}
-
-						else if (x >= swidth / 2 - span2 - 1 || y >= sheight / 2 - span2 -1 )
-						{
-							//  interpolation does not have sufficient points
-						// points are within src frame
-							if (nbytes == 1)
-							{
-								// near point
-								copy4FoldSym(dp + oCenter, dpitch, sp + iCenter, spitch, 1, w, h, x, y);
-							}
-							else if (nbytes == 2)
-							{
-								copy4FoldSym((uint16_t*)dp + oCenter, dpitch, (uint16_t*)sp + iCenter, spitch, 1, w, h, x, y);
-							}
-							else if (nbytes == 4)
-							{
-								
-								// near point
-								copy4FoldSym((float*)dp + oCenter, dpitch, (float*)sp + iCenter, spitch, 1, w, h, x, y);
-							}
-						}
-						
-						else
-						{
-							
-							// sufficient points for interpolation are available
-							if (nbytes == 1)
-							{
-								if (d->q == 1)
-									interpolate9pt4FoldSym(dp + oCenter, dpitch, sp + iCenter, spitch,
-										1, w, h, x, y,	index);
-								else
-									//bilinear 2x2 or cubic 4x4 or lanczos 6x6
-									interpolate4FoldSym(dp + oCenter, dpitch, sp + iCenter, spitch,
-										 1, w, h, x, y, qx, qy,  d->span, d->iCoeff, min8, max8);
-																	
-							}
-
-							else if (nbytes == 2)
-							{
-								if (d->q == 1)
-									interpolate9pt4FoldSym((uint16_t*)dp + oCenter, dpitch, (uint16_t*)sp + iCenter, spitch,
-										1, w, h, x, y, index);
-								else
-								
-									interpolate4FoldSym((uint16_t*)dp + oCenter, dpitch, (uint16_t*)sp + iCenter, spitch,
-										1, w, h, x, y, qx, qy, d->span, d->iCoeff, min16, max16);
-								
-							}
-
-							else if (nbytes == 4)
-							{
-								if (d->q == 1)
-									interpolate9pt4FoldSym((float*)dp + oCenter, dpitch, (float*)sp + iCenter, spitch,
-										1, w, h, x, y, index);
-								else
-								
-									interpolate4FoldSym((float*)dp + oCenter, dpitch, (float*)sp + iCenter, spitch,
-									1,w, h, x, y, qx, qy, d->span, d->iCoeff, minf, maxf);
-								
-							}
-						}
-					}
-
-				}
-			}
-		}
-		vsapi->freeFrame(src);
-		return dst;
-	}
-	return 0;
+static const VSFrameRef *VS_CC fisheyeGetFrame(
+    int n, int activationReason, void **instanceData, void **frameData,
+    VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) {
+    FisheyeData *d = (FisheyeData *) *instanceData;
+
+    if(activationReason == arInitial) {
+        vsapi->requestFrameFilter(n, d->node, frameCtx);
+    } else if(activationReason == arAllFramesReady) {
+        const VSFrameRef *src = vsapi->getFrameFilter(n, d->node, frameCtx);
+        VSFrameRef *dst;
+        const VSFormat *fi = d->ivi->format;
+        int sheight = vsapi->getFrameHeight(src, 0);
+        int swidth = vsapi->getFrameWidth(src, 0);
+        int nbits = fi->bitsPerSample;
+        int nbytes = fi->bytesPerSample;
+        // will not process A plane
+        int np = fi->numPlanes > 3 ? 3 : fi->numPlanes;
+        int dwidth = d->vi.width;
+        int dheight = d->vi.height;
+
+        int kb = 1;
+
+        if(d->test)
+            // get src on which dots will be overlain
+            dst = vsapi->copyFrame(src, core);
+        else
+            dst = vsapi->newVideoFrame(fi, dwidth, dheight, src, core);
+
+        dwidth = vsapi->getFrameWidth(dst, 0);
+        dheight = vsapi->getFrameHeight(dst, 0);
+
+        int frsq = d->frad * d->frad;
+
+        for(int p = 0; p < np; p++) {
+
+            const uint8_t *sp = vsapi->getReadPtr(src, p);
+            uint8_t *dp = vsapi->getWritePtr(dst, p);
+            int spitch = vsapi->getStride(src, p) / nbytes;
+            int dpitch = vsapi->getStride(dst, p) / nbytes;
+            // number of entries per row in the xyAndQ buffer
+            int nEntries = d->test ? 2 : d->q == 1 ? 3 : 4;
+
+            if(d->test) {
+
+                if(fi->colorFamily == cmRGB) {
+                    if(nbytes == 1)
+                        dimplaneRGB(dp, sp, spitch, swidth, sheight, d->dim);
+                    else if(nbytes == 2)
+                        dimplaneRGB((uint16_t *) dp, (uint16_t *) sp, spitch,
+                                    swidth, sheight, d->dim);
+                    else if(nbytes == 4)
+                        dimplaneRGB((float *) dp, (float *) sp, spitch, swidth,
+                                    sheight, d->dim);
+                }
+
+                else if(p == 0 && fi->colorFamily == cmYUV) {
+                    if(nbytes == 1) {
+                        uint8_t limit = (uint8_t) 16;
+                        dimplaneYUV(dp, dp, dpitch, dwidth, dheight, d->dim,
+                                    limit);
+                    } else if(nbytes == 2) {
+                        uint16_t limit = (uint16_t) (16 << (nbits - 8));
+                        dimplaneYUV((uint16_t *) dp, (uint16_t *) dp, dpitch,
+                                    dwidth, dheight, d->dim, limit);
+                    } else if(nbytes == 4)
+                        dimplaneYUV((float *) dp, (float *) dp, dpitch, dwidth,
+                                    dheight, d->dim, 0.0f);
+                }
+
+                int frsq = d->frad * d->frad;
+                int iCenter = d->origin_y * spitch + d->origin_x;
+
+                // we will put dots
+                for(int h = d->ddensity / 2; h < d->oRadius; h += d->ddensity) {
+                    int hoff = nEntries * h * d->oRadius;
+
+                    for(int w = d->ddensity / 2; w < d->oRadius;
+                        w += d->ddensity) {
+                        int woff = nEntries * w;
+
+                        int x = d->xyAndQ[hoff + woff];
+                        int y = d->xyAndQ[hoff + woff + 1];
+                        // ensure points are within frame
+                        if(x >= d->frad || y >= d->frad || x < 0 || y < 0)
+                            continue;
+                        // ensure points are within src / fish eye
+                        if(x * x + y * y <= frsq) {
+                            if(nbytes == 1)
+                                paint4FoldSym(dp + iCenter, dpitch, 1, x, y,
+                                              d->col[p]);
+                            else if(nbytes == 2)
+                                paint4FoldSym((uint16_t *) dp + iCenter, dpitch,
+                                              1, x, y,
+                                              *((uint16_t *) d->col + p));
+                            else if(nbytes == 4)
+                                paint4FoldSym((float *) dp + iCenter, dpitch, 1,
+                                              x, y, *((float *) d->col + p));
+                        }
+                    }
+                }
+
+            } // if test
+
+            else // not test. normal processing
+            {
+                int iCenter = d->origin_y * spitch + d->origin_x;
+                int oCenter = d->oRadius * dpitch + d->oRadius;
+
+                uint8_t min8 = 0, max8 = (uint8_t) 255;
+                uint16_t min16 =
+                    (uint16_t) (fi->colorFamily == cmYUV ? 16 << (nbits - 8)
+                                                         : 0);
+                uint16_t max16 =
+                    (uint16_t) ((fi->colorFamily == cmYUV ? 235
+                                                          : 255 << (nbits - 8))
+                                << (nbits - 8));
+                float minf = 0, maxf = 1.0f;
+
+                if(p > 0 && fi->colorFamily == cmYUV) {
+                    minf = -0.5f;
+                    maxf = 0.5f;
+                }
+                int x, y, qx, qy, span2 = d->span / 2;
+                int offh, offw;
+                int index;
+                int frsq = d->frad * d->frad;
+
+                for(int h = 0; h < d->oRadius - 1; h++) {
+                    offh = h * d->oRadius * nEntries;
+
+                    for(int w = 0; w < d->oRadius - 1; w++) {
+                        offw = nEntries * w;
+
+                        x = d->xyAndQ[offh + offw];
+                        y = d->xyAndQ[offh + offw + 1];
+
+                        if(d->q > 1) {
+                            qx = d->xyAndQ[offh + offw + 2];
+                            qy = d->xyAndQ[offh + offw + 3];
+                        } else
+                            index = d->xyAndQ[offh + offw + 2];
+                        // was checked in init
+                        // if (x >= swidth / 2   || y >= sheight / 2  || x < 0
+                        // || y < 0
+                        //	|| x * x + y * y > frsq)
+                        if(x < 0) {
+                            // points are outside  src or fish. So make the
+                            // point black
+                            if(nbytes == 1)
+                                paint4FoldSym(dp + oCenter, dpitch, 1, w, h,
+                                              d->col[p]);
+                            else if(nbytes == 2)
+                                paint4FoldSym((uint16_t *) dp + oCenter, dpitch,
+                                              1, w, h,
+                                              *((uint16_t *) d->col + p));
+                            else if(nbytes == 4)
+                                paint4FoldSym((float *) dp + oCenter, dpitch, 1,
+                                              w, h, *((float *) d->col + p));
+                        }
+
+                        else if(x >= swidth / 2 - span2 - 1 ||
+                                y >= sheight / 2 - span2 - 1) {
+                            //  interpolation does not have sufficient points
+                            // points are within src frame
+                            if(nbytes == 1) {
+                                // near point
+                                copy4FoldSym(dp + oCenter, dpitch, sp + iCenter,
+                                             spitch, 1, w, h, x, y);
+                            } else if(nbytes == 2) {
+                                copy4FoldSym((uint16_t *) dp + oCenter, dpitch,
+                                             (uint16_t *) sp + iCenter, spitch,
+                                             1, w, h, x, y);
+                            } else if(nbytes == 4) {
+
+                                // near point
+                                copy4FoldSym((float *) dp + oCenter, dpitch,
+                                             (float *) sp + iCenter, spitch, 1,
+                                             w, h, x, y);
+                            }
+                        }
+
+                        else {
+
+                            // sufficient points for interpolation are available
+                            if(nbytes == 1) {
+                                if(d->q == 1)
+                                    interpolate9pt4FoldSym(
+                                        dp + oCenter, dpitch, sp + iCenter,
+                                        spitch, 1, w, h, x, y, index);
+                                else
+                                    // bilinear 2x2 or cubic 4x4 or lanczos 6x6
+                                    interpolate4FoldSym(
+                                        dp + oCenter, dpitch, sp + iCenter,
+                                        spitch, 1, w, h, x, y, qx, qy, d->span,
+                                        d->iCoeff, min8, max8);
+
+                            }
+
+                            else if(nbytes == 2) {
+                                if(d->q == 1)
+                                    interpolate9pt4FoldSym(
+                                        (uint16_t *) dp + oCenter, dpitch,
+                                        (uint16_t *) sp + iCenter, spitch, 1, w,
+                                        h, x, y, index);
+                                else
+
+                                    interpolate4FoldSym(
+                                        (uint16_t *) dp + oCenter, dpitch,
+                                        (uint16_t *) sp + iCenter, spitch, 1, w,
+                                        h, x, y, qx, qy, d->span, d->iCoeff,
+                                        min16, max16);
+
+                            }
+
+                            else if(nbytes == 4) {
+                                if(d->q == 1)
+                                    interpolate9pt4FoldSym(
+                                        (float *) dp + oCenter, dpitch,
+                                        (float *) sp + iCenter, spitch, 1, w, h,
+                                        x, y, index);
+                                else
+
+                                    interpolate4FoldSym(
+                                        (float *) dp + oCenter, dpitch,
+                                        (float *) sp + iCenter, spitch, 1, w, h,
+                                        x, y, qx, qy, d->span, d->iCoeff, minf,
+                                        maxf);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        vsapi->freeFrame(src);
+        return dst;
+    }
+    return 0;
 }
 
 /***************************************************************/
-static void VS_CC fisheyeFree(void* instanceData, VSCore* core, const VSAPI* vsapi)
-{
-	FisheyeData* d = (FisheyeData*)instanceData;
-	vsapi->freeNode(d->node);
-	
-		vs_aligned_free(d->xyAndQ);
-		if (!d->iCoeff == NULL)
-			vs_aligned_free(d->iCoeff);
-	
-	free(d);
-}
+static void VS_CC fisheyeFree(void *instanceData, VSCore *core,
+                              const VSAPI *vsapi) {
+    FisheyeData *d = (FisheyeData *) instanceData;
+    vsapi->freeNode(d->node);
 
-static void VS_CC fisheyeCreate(const VSMap* in, VSMap* out, void* userData,
-	VSCore* core, const VSAPI* vsapi)
-{
-	FisheyeData d;
-	FisheyeData* data;
-	int err;
-	int temp;
-
-	// Get a clip reference from the input arguments. This must be freed later.
-	d.node = vsapi->propGetNode(in, "clip", 0, 0);
-	d.ivi = vsapi->getVideoInfo(d.node);
-
-	// In this first version we only want to handle 8bit integer formats. Note that
-	// vi->format can be 0 if the input clip can change format midstream.
-	if (!isConstantFormat(d.ivi) || d.ivi->width == 0 || d.ivi->height == 0
-		|| (d.ivi->format->colorFamily != cmYUV && d.ivi->format->colorFamily != cmGray
-			&& d.ivi->format->colorFamily != cmRGB))
-	{
-		vsapi->setError(out, "Fisheye: only RGB, Yuv or Gray color constant formats and const frame dimensions input supported");
-		vsapi->freeNode(d.node);
-		return;
-	}
-	if (d.ivi->format->colorFamily == cmYUV && (d.ivi->format->subSamplingH != 0 || d.ivi->format->subSamplingW != 0))
-	{
-		vsapi->setError(out, "Fisheye: for YUV input only YUV444 allowed");
-		vsapi->freeNode(d.node);
-		return;
-	}
-
-	if (d.ivi->format->sampleType == stFloat && d.ivi->format->bitsPerSample == 16)
-	{
-		vsapi->setError(out, "Fisheye: half float input not allowed.");
-		vsapi->freeNode(d.node);
-		return;
-	}
-
-	// If a property read fails for some reason (index out of bounds/wrong type)
-	// then err will have flags set to indicate why and 0 will be returned. This
-	// can be very useful to know when having optional arguments. Since we have
-	// strict checking because of what we wrote in the argument string, the only
-	// reason this could fail is when the value wasn't set by the user.
-	// And when it's not set we want it to default to enabled.
-
-	d.method = int64ToIntS(vsapi->propGetInt(in, "method", 0, &err));
-	if (err)
-		d.method = 3;
-	if (d.method < 1 || d.method > 5)
-	{
-		vsapi->setError(out, "Fisheye: method must be between 1 and 5 ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-	
-	d.origin_x = int64ToIntS(vsapi->propGetInt(in, "xo", 0, &err));
-	if (err)
-		d.origin_x = d.ivi->width / 2;
-
-	d.origin_y = int64ToIntS(vsapi->propGetInt(in, "yo", 0, &err));
-	if (err)
-		d.origin_y = d.ivi->height / 2;
-
-	int radius = VSMAX( VSMAX(abs(d.origin_x), abs(d.ivi->width - d.origin_x) ),
-		VSMAX(abs(d.origin_y), abs(d.ivi->height - d.origin_y) ) );
-	
-
-
-	d.frad = int64ToIntS(vsapi->propGetInt(in, "frad", 0, &err));	
-	if (err)
-		d.frad = radius; // (d.ivi->width > d.ivi->height ? d.ivi->height : d.ivi->width) / 2;
-
-	else if (d.frad < 64)
-	{
-		vsapi->setError(out, "Fisheye: frad must be at least 64 ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-
-	d.fov = (double)vsapi->propGetFloat(in, "fov", 0, &err);
-
-	if (err)
-		d.fov = 120.0;
-	else if (d.fov < 40 || d.fov > 170)
-	{
-		vsapi->setError(out, "Fisheye: fov can be 40 to 170 only ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-
-	bool insideFrame = false, partiallyInside = false;
-	if (d.origin_x - d.frad >= 0 && d.origin_x + d.frad < d.ivi->width && d.origin_y - d.frad >= 0 && d.origin_y + d.frad < d.ivi->height)
-	
-		insideFrame = true;
-	else if (((d.origin_x < 0 && d.origin_x + d.frad > 0) || (d.origin_x > d.ivi->width && d.origin_x - d.frad < d.ivi->width)
-		|| (d.origin_x >= 0 && d.origin_x < d.ivi->width ))
-		&& ((d.origin_y < 0 && d.origin_y + d.frad > 0) || (d.origin_y > d.ivi->height && d.origin_y - d.frad < d.ivi->height)
-			|| (d.origin_y >= 0 && d.origin_y < d.ivi->height )))
-	
-		partiallyInside = true;
-	else
-	{
-		vsapi->setError(out, "Fisheye: origin and frad must ensure at least part of fisheye image is inside frame ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-	d.fdia = d.frad * 2;
-
-	
-	temp = !!int64ToIntS(vsapi->propGetInt(in, "sqr", 0, &err));
-	if (err)
-		d.sqr = true;
-	else
-		d.sqr = temp == 0 ? false : true;
-	
-
-	d.rix = (double)(vsapi->propGetFloat(in, "rix", 0, &err));
-	if (err)
-		d.rix = 1.15;
-	if (d.rix < 1.0 || d.rix > 1.5)
-	{
-		vsapi->setError(out, "Fisheye: rix must be 1.0 to 1.5 ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-
-
-	temp = !!int64ToIntS(vsapi->propGetInt(in, "test", 0, &err));
-	if (err)
-		d.test = false;
-	else
-		d.test = temp == 0 ? false : true;
-	if (d.test)
-	{
-		
-		d.dots = int64ToIntS(vsapi->propGetInt(in, "dots", 0, &err));
-		if (err)
-			d.dots = 2;
-		else if (d.dots < 1 || d.dots > 4)
-		{
-			vsapi->setError(out, "Fisheye: dots must be 1 to 4 only ");
-			vsapi->freeNode(d.node);
-			return;
-		}
-
-		d.dim = (float)(1.0 - vsapi->propGetFloat(in, "dim", 0, &err));
-		if (err)
-			d.dim = 0.75f;
-		if (d.dim < 0.0f || d.dim > 1.0f)
-		{
-			vsapi->setError(out, "Fisheye: dim must be from 0 to 1.0 only ");
-			vsapi->freeNode(d.node);
-			return;
-		}
-		
-	}
-	else
-	{
-		
-		d.q = int64ToIntS(vsapi->propGetInt(in, "q", 0, &err));
-		if (err)
-			d.q = 1;
-		else if (d.q < 1 || d.q > 4)
-		{
-			vsapi->setError(out, "Fisheye: q must be 1 to 4 only ");
-			vsapi->freeNode(d.node);
-			return;
-		}
-	}
-	
-
-	// I usually keep the filter data struct on the stack and don't allocate it
-// until all the input validation is done.
-	data = (FisheyeData*)malloc(sizeof(d));
-	*data = d;
-
-	if (insideFrame)
-		vsapi->createFilter(in, out, "Fisheye", fisheyeInit, fisheyeGetFrame, fisheyeFree, fmParallel, 0, data, core);
-	else
-		vsapi->createFilter(in, out, "FisheyePart", fisheyepartInit, fisheyepartGetFrame, fisheyepartFree, fmParallel, 0, data, core);
-}
+    vs_aligned_free(d->xyAndQ);
+    // Warning
 
-// registerFunc("Fisheye", "clip:clip;method:int:opt;xo:int:opt;yo:int:opt;frad:int:opt;sqr:int:opt;rix:float:opt;fov:float:opt;test:int:opt;q:int:opt;dots:int:opt;", fisheyeCreate, 0, plugin);
+    // if (!d->iCoeff == NULL)
+    // Fix
+    if(d->iCoeff != NULL)
+        vs_aligned_free(d->iCoeff);
 
+    free(d);
+}
+
+static void VS_CC fisheyeCreate(const VSMap *in, VSMap *out, void *userData,
+                                VSCore *core, const VSAPI *vsapi) {
+    FisheyeData d;
+    FisheyeData *data;
+    int err;
+    int temp;
+
+    // Get a clip reference from the input arguments. This must be freed later.
+    d.node = vsapi->propGetNode(in, "clip", 0, 0);
+    d.ivi = vsapi->getVideoInfo(d.node);
+
+    // In this first version we only want to handle 8bit integer formats. Note
+    // that vi->format can be 0 if the input clip can change format midstream.
+    if(!isConstantFormat(d.ivi) || d.ivi->width == 0 || d.ivi->height == 0 ||
+       (d.ivi->format->colorFamily != cmYUV &&
+        d.ivi->format->colorFamily != cmGray &&
+        d.ivi->format->colorFamily != cmRGB)) {
+        vsapi->setError(out,
+                        "Fisheye: only RGB, Yuv or Gray color constant formats "
+                        "and const frame dimensions input supported");
+        vsapi->freeNode(d.node);
+        return;
+    }
+    if(d.ivi->format->colorFamily == cmYUV &&
+       (d.ivi->format->subSamplingH != 0 || d.ivi->format->subSamplingW != 0)) {
+        vsapi->setError(out, "Fisheye: for YUV input only YUV444 allowed");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    if(d.ivi->format->sampleType == stFloat &&
+       d.ivi->format->bitsPerSample == 16) {
+        vsapi->setError(out, "Fisheye: half float input not allowed.");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    // If a property read fails for some reason (index out of bounds/wrong type)
+    // then err will have flags set to indicate why and 0 will be returned. This
+    // can be very useful to know when having optional arguments. Since we have
+    // strict checking because of what we wrote in the argument string, the only
+    // reason this could fail is when the value wasn't set by the user.
+    // And when it's not set we want it to default to enabled.
+
+    d.method = int64ToIntS(vsapi->propGetInt(in, "method", 0, &err));
+    if(err)
+        d.method = 3;
+    if(d.method < 1 || d.method > 5) {
+        vsapi->setError(out, "Fisheye: method must be between 1 and 5 ");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    d.origin_x = int64ToIntS(vsapi->propGetInt(in, "xo", 0, &err));
+    if(err)
+        d.origin_x = d.ivi->width / 2;
+
+    d.origin_y = int64ToIntS(vsapi->propGetInt(in, "yo", 0, &err));
+    if(err)
+        d.origin_y = d.ivi->height / 2;
+
+    int radius = VSMAX(VSMAX(abs(d.origin_x), abs(d.ivi->width - d.origin_x)),
+                       VSMAX(abs(d.origin_y), abs(d.ivi->height - d.origin_y)));
+
+    d.frad = int64ToIntS(vsapi->propGetInt(in, "frad", 0, &err));
+    if(err)
+        d.frad = radius; // (d.ivi->width > d.ivi->height ? d.ivi->height :
+                         // d.ivi->width) / 2;
+
+    else if(d.frad < 64) {
+        vsapi->setError(out, "Fisheye: frad must be at least 64 ");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    d.fov = (double) vsapi->propGetFloat(in, "fov", 0, &err);
+
+    if(err)
+        d.fov = 120.0;
+    else if(d.fov < 40 || d.fov > 170) {
+        vsapi->setError(out, "Fisheye: fov can be 40 to 170 only ");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    bool insideFrame = false, partiallyInside = false;
+    if(d.origin_x - d.frad >= 0 && d.origin_x + d.frad < d.ivi->width &&
+       d.origin_y - d.frad >= 0 && d.origin_y + d.frad < d.ivi->height)
+
+        insideFrame = true;
+    else if(((d.origin_x < 0 && d.origin_x + d.frad > 0) ||
+             (d.origin_x > d.ivi->width &&
+              d.origin_x - d.frad < d.ivi->width) ||
+             (d.origin_x >= 0 && d.origin_x < d.ivi->width)) &&
+            ((d.origin_y < 0 && d.origin_y + d.frad > 0) ||
+             (d.origin_y > d.ivi->height &&
+              d.origin_y - d.frad < d.ivi->height) ||
+             (d.origin_y >= 0 && d.origin_y < d.ivi->height)))
+
+        partiallyInside = true;
+    else {
+        vsapi->setError(out, "Fisheye: origin and frad must ensure at least "
+                             "part of fisheye image is inside frame ");
+        vsapi->freeNode(d.node);
+        return;
+    }
+    d.fdia = d.frad * 2;
+
+    temp = !!int64ToIntS(vsapi->propGetInt(in, "sqr", 0, &err));
+    if(err)
+        d.sqr = true;
+    else
+        d.sqr = temp == 0 ? false : true;
+
+    d.rix = (double) (vsapi->propGetFloat(in, "rix", 0, &err));
+    if(err)
+        d.rix = 1.15;
+    if(d.rix < 1.0 || d.rix > 1.5) {
+        vsapi->setError(out, "Fisheye: rix must be 1.0 to 1.5 ");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    temp = !!int64ToIntS(vsapi->propGetInt(in, "test", 0, &err));
+    if(err)
+        d.test = false;
+    else
+        d.test = temp == 0 ? false : true;
+    if(d.test) {
+
+        d.dots = int64ToIntS(vsapi->propGetInt(in, "dots", 0, &err));
+        if(err)
+            d.dots = 2;
+        else if(d.dots < 1 || d.dots > 4) {
+            vsapi->setError(out, "Fisheye: dots must be 1 to 4 only ");
+            vsapi->freeNode(d.node);
+            return;
+        }
+
+        d.dim = (float) (1.0 - vsapi->propGetFloat(in, "dim", 0, &err));
+        if(err)
+            d.dim = 0.75f;
+        if(d.dim < 0.0f || d.dim > 1.0f) {
+            vsapi->setError(out, "Fisheye: dim must be from 0 to 1.0 only ");
+            vsapi->freeNode(d.node);
+            return;
+        }
+
+    } else {
+
+        d.q = int64ToIntS(vsapi->propGetInt(in, "q", 0, &err));
+        if(err)
+            d.q = 1;
+        else if(d.q < 1 || d.q > 4) {
+            vsapi->setError(out, "Fisheye: q must be 1 to 4 only ");
+            vsapi->freeNode(d.node);
+            return;
+        }
+    }
+
+    // I usually keep the filter data struct on the stack and don't allocate it
+    // until all the input validation is done.
+    data = (FisheyeData *) malloc(sizeof(d));
+    *data = d;
+
+    if(insideFrame)
+        vsapi->createFilter(in, out, "Fisheye", fisheyeInit, fisheyeGetFrame,
+                            fisheyeFree, fmParallel, 0, data, core);
+    else
+        vsapi->createFilter(in, out, "FisheyePart", fisheyepartInit,
+                            fisheyepartGetFrame, fisheyepartFree, fmParallel, 0,
+                            data, core);
+}
 
+// registerFunc("Fisheye",
+// "clip:clip;method:int:opt;xo:int:opt;yo:int:opt;frad:int:opt;sqr:int:opt;rix:float:opt;fov:float:opt;test:int:opt;q:int:opt;dots:int:opt;",
+// fisheyeCreate, 0, plugin);
diff --git a/FisheyeMethods.h b/FisheyeMethods.h
index d9643b0..0e5521b 100644
--- a/FisheyeMethods.h
+++ b/FisheyeMethods.h
@@ -20,275 +20,246 @@ methods are :-
  Barrel and pin cushion  type distortion correction with a,b,c,d old method
 Barrel and PinCushion type distortion correction with new c */
 
-//  rNorm radius for normalization used by methods 
-void getSourceCoord(float* xy, const float ww, const float hh, const int method,
-	const float rNormal, const float* abc);
+//  rNorm radius for normalization used by methods
+void getSourceCoord(float *xy, const float ww, const float hh, const int method,
+                    const float rNormal, const float *abc);
 // Results in xy array of 2. ww and xx are coordinates
 // focal is focal length and rix is akin to refractive index
 // used by fisheye methods
-void getSourceXY(float* xy, const float ww, const float hh, const int method,
-	const double focal, const double rNorm, const double rix);
+void getSourceXY(float *xy, const float ww, const float hh, const int method,
+                 const double focal, const double rNorm, const double rix);
 // method 1,6 ortho, 2,7 linear, 3,8 equisolid,4,9 Panoramic, 5,10 radial
 double getFocalLength(const int frad, const int method, const double fov);
-int getOutputRadius(const int frad, const double focal,  const double rix);
+int getOutputRadius(const int frad, const double focal, const double rix);
 
-int getOutputRadius(const int frad, const double focal,  const double rix)
-{
-	
-	double alfa = atan(frad / focal);
-	double theta = asin(sin(alfa) * rix);
-	return  (int)(focal * tan(theta));
+int getOutputRadius(const int frad, const double focal, const double rix) {
 
+    double alfa = atan(frad / focal);
+    double theta = asin(sin(alfa) * rix);
+    return (int) (focal * tan(theta));
 }
-double getFocalLength(const int frad, const int method, const double fov)
-{
-	// type 1,6 ortho, 2,7 linear, 3,8 equisolid,4,9 Panoramic, 5,10 radial
-	double focal;
-	double fovrad = fov * M_PI / 360.0;
-	switch (method)
-	{
-	case 1:
-	{ }
-	case 6 :
-	{
-		focal = (frad / sin(fovrad));
-		break;
-	}
-	case 2 :
-	{}
-	case 7:
-	{
-		focal = (frad / (fovrad)  );
-		break;
-	}
-	case 3:
-	{}
-	case 8 :
-	{
-		focal = (frad / (2 * sin(fovrad / 2) ) );
-		break;
-	}
-	case 4:
-	{}
-	case 9: 
-	{
-		focal = (frad / (2 * tan(fovrad / 2)));
-		break;
-	}
-	case 5 :
-	{}
-	case 10:
-	{
-		focal = (frad / tan(fovrad));
-		break;
-	}
-	}
-	return focal;
+double getFocalLength(const int frad, const int method, const double fov) {
+    // type 1,6 ortho, 2,7 linear, 3,8 equisolid,4,9 Panoramic, 5,10 radial
+    double focal;
+    double fovrad = fov * M_PI / 360.0;
+    switch(method) {
+    case 1: {
+    }
+    case 6: {
+        focal = (frad / sin(fovrad));
+        break;
+    }
+    case 2: {
+    }
+    case 7: {
+        focal = (frad / (fovrad));
+        break;
+    }
+    case 3: {
+    }
+    case 8: {
+        focal = (frad / (2 * sin(fovrad / 2)));
+        break;
+    }
+    case 4: {
+    }
+    case 9: {
+        focal = (frad / (2 * tan(fovrad / 2)));
+        break;
+    }
+    case 5: {
+    }
+    case 10: {
+        focal = (frad / tan(fovrad));
+        break;
+    }
+    }
+    return focal;
 }
 
-void getSourceXY(float* xy, const float ww, const float hh, const int method,
-	const double focal, const double rNorm, const double rix)
-{
-	
-	double h = (double)hh;
-	double w = (double)ww + 0.5;// to ensure no 0 / 0  tan does not become infinity
+void getSourceXY(float *xy, const float ww, const float hh, const int method,
+                 const double focal, const double rNorm, const double rix) {
 
-	switch (method)
-	{
-	case  11:
-	{
+    double h = (double) hh;
+    double w =
+        (double) ww + 0.5; // to ensure no 0 / 0  tan does not become infinity
 
-		// barrel
-		double rsq = hh * hh + ww * ww;
-		double denom = 1.0 - focal * rsq / rNorm;
-		xy[0] = (float)(ww / denom);
-		xy[1] = (float)(hh / denom);
-		break;
-	}
+    switch(method) {
+    case 11: {
 
-	case 12:
-	{
+        // barrel
+        double rsq = hh * hh + ww * ww;
+        double denom = 1.0 - focal * rsq / rNorm;
+        xy[0] = (float) (ww / denom);
+        xy[1] = (float) (hh / denom);
+        break;
+    }
 
-		// pin cushion
-		double rsq = hh * hh + ww * ww;
-		double denom = 1.0 + focal * rsq / rNorm;
-		xy[0] = (float)(ww / denom);
-		xy[1] = (float)(hh / denom);
-		break;
-	}
-	case 1:
-	{
-		//ortho f sin@
-		double rpersp = sqrt(1.0 * (h * h + w * w));
-		double theta = atan(rpersp / focal);
-		double alfa = asin(sin(theta) / rix);
+    case 12: {
 
-		double rfish = focal * sin(alfa);
+        // pin cushion
+        double rsq = hh * hh + ww * ww;
+        double denom = 1.0 + focal * rsq / rNorm;
+        xy[0] = (float) (ww / denom);
+        xy[1] = (float) (hh / denom);
+        break;
+    }
+    case 1: {
+        // ortho f sin@
+        double rpersp = sqrt(1.0 * (h * h + w * w));
+        double theta = atan(rpersp / focal);
+        double alfa = asin(sin(theta) / rix);
 
-		xy[0] = (float)(rfish * w / rpersp);
-		xy[1] = (float)(rfish * h / rpersp);
-		break;
-	}
-	case 2:
-	{
-		//linear f@
-		double rpersp = sqrt(1.0 * (h * h + w * w));
-		double theta = atan(rpersp / focal);
-		double alfa = asin(sin(theta) / rix);
+        double rfish = focal * sin(alfa);
 
-		double rfish = focal * alfa;
-		xy[0] = (float)(rfish * w / rpersp);
-		xy[1] = (float)(rfish * h / rpersp);
-		break;
-	}
-	case 3:
-	{
-		//equisolid 2 f sin (@ / 2)
-		double rpersp = sqrt(1.0 * (h * h + w * w));
-		double theta = atan(rpersp / focal);
-		double alfa = asin(sin(theta) / rix);
+        xy[0] = (float) (rfish * w / rpersp);
+        xy[1] = (float) (rfish * h / rpersp);
+        break;
+    }
+    case 2: {
+        // linear f@
+        double rpersp = sqrt(1.0 * (h * h + w * w));
+        double theta = atan(rpersp / focal);
+        double alfa = asin(sin(theta) / rix);
 
-		double rfish = 2 * focal * sin(alfa / 2);
-		xy[0] = (float)(rfish * w / rpersp);
-		xy[1] = (float)(rfish * h / rpersp);
-		break;
-	}
-	case 4:
-	{
-		//panoramic 2 f tan(@ / 2)
-		double rpersp = sqrt(1.0 * (h * h + w * w));
-		double theta = atan(rpersp / focal);
-		double alfa = asin(sin(theta) / rix);
+        double rfish = focal * alfa;
+        xy[0] = (float) (rfish * w / rpersp);
+        xy[1] = (float) (rfish * h / rpersp);
+        break;
+    }
+    case 3: {
+        // equisolid 2 f sin (@ / 2)
+        double rpersp = sqrt(1.0 * (h * h + w * w));
+        double theta = atan(rpersp / focal);
+        double alfa = asin(sin(theta) / rix);
 
-		double rfish = 2 * focal * tan(alfa / 2);
-		xy[0] = (float)(rfish * w / rpersp);
-		xy[1] = (float)(rfish * h / rpersp);
-		break;
-	}
-	case 5:
-	{
-		//from  fish to radial
-		//tan theta get source
-		double rpersp = sqrt(1.0 * (h * h + w * w));
-		double theta = atan(rpersp / focal);
-		//double alfa = atan(tanalfa);
-		double sinalfa = sin(theta) / rix;
-		double alfa = asin(sinalfa);
-		double rfish = focal * tan(alfa);
-		xy[0] = (float)(rfish * w / rpersp);
-		xy[1] = (float)(rfish * h / rpersp);
-		break;
-	}
-	case 6:
-	{
-		//for  ortho fish f sin@ get source ortho coord
-		double rfish = sqrt(1.0 * (h * h + w * w));
-		double alfa = atan(rfish / focal);
-		double sintheta = sin(alfa) * rix;	// same as rfish * rix / focal		
-		double theta = asin(sintheta);
-		double rortho = focal * tan(theta);
+        double rfish = 2 * focal * sin(alfa / 2);
+        xy[0] = (float) (rfish * w / rpersp);
+        xy[1] = (float) (rfish * h / rpersp);
+        break;
+    }
+    case 4: {
+        // panoramic 2 f tan(@ / 2)
+        double rpersp = sqrt(1.0 * (h * h + w * w));
+        double theta = atan(rpersp / focal);
+        double alfa = asin(sin(theta) / rix);
 
-		xy[0] = (float)(rortho * w / rfish);
-		xy[1] = (float)(rortho * h / rfish);
-		break;
-	}
-	case 7:
-	{
-		//for linear fish f @ get source 
-		double rfish = sqrt(1.0 * (h * h + w * w));
-		double alfa = (rfish / focal);
-		double sintheta = sin(alfa) * rix;
-		double theta = asin(sintheta);
-		double rlinear = focal * tan(theta);
+        double rfish = 2 * focal * tan(alfa / 2);
+        xy[0] = (float) (rfish * w / rpersp);
+        xy[1] = (float) (rfish * h / rpersp);
+        break;
+    }
+    case 5: {
+        // from  fish to radial
+        // tan theta get source
+        double rpersp = sqrt(1.0 * (h * h + w * w));
+        double theta = atan(rpersp / focal);
+        // double alfa = atan(tanalfa);
+        double sinalfa = sin(theta) / rix;
+        double alfa = asin(sinalfa);
+        double rfish = focal * tan(alfa);
+        xy[0] = (float) (rfish * w / rpersp);
+        xy[1] = (float) (rfish * h / rpersp);
+        break;
+    }
+    case 6: {
+        // for  ortho fish f sin@ get source ortho coord
+        double rfish = sqrt(1.0 * (h * h + w * w));
+        double alfa = atan(rfish / focal);
+        double sintheta = sin(alfa) * rix; // same as rfish * rix / focal
+        double theta = asin(sintheta);
+        double rortho = focal * tan(theta);
 
-		xy[0] = (float)(rlinear * w / rfish);
-		xy[1] = (float)(rlinear * h / rfish);
-		break;
-	}
-	case 8:
-	{
-		//for equi solid fish 2 f sin (@/2) get source
-		double rfish = sqrt(1.0 * (h * h + w * w));
-		double sinalfa2 = rfish / (2 * focal);
-		double alfa2 = asin(sinalfa2);
-		double alfa = 2 * alfa2;
-		double sintheta = sin(alfa) * rix;
-		double theta = asin(sintheta);
-		double rsolid = focal * tan(theta);
+        xy[0] = (float) (rortho * w / rfish);
+        xy[1] = (float) (rortho * h / rfish);
+        break;
+    }
+    case 7: {
+        // for linear fish f @ get source
+        double rfish = sqrt(1.0 * (h * h + w * w));
+        double alfa = (rfish / focal);
+        double sintheta = sin(alfa) * rix;
+        double theta = asin(sintheta);
+        double rlinear = focal * tan(theta);
 
-		xy[0] = (float)(rsolid * w / rfish);
-		xy[1] = (float)(rsolid * h / rfish);
-		break;
-	}
+        xy[0] = (float) (rlinear * w / rfish);
+        xy[1] = (float) (rlinear * h / rfish);
+        break;
+    }
+    case 8: {
+        // for equi solid fish 2 f sin (@/2) get source
+        double rfish = sqrt(1.0 * (h * h + w * w));
+        double sinalfa2 = rfish / (2 * focal);
+        double alfa2 = asin(sinalfa2);
+        double alfa = 2 * alfa2;
+        double sintheta = sin(alfa) * rix;
+        double theta = asin(sintheta);
+        double rsolid = focal * tan(theta);
 
-	case 9:
-	{
-		//from panoramic to fish
-		//for panoramic fish 2 f tan (@/2) get source
-		double rfish = sqrt(1.0 * (h * h + w * w));
-		double tanalfa2 = rfish / (2 * focal);
-		double alfa2 = atan(tanalfa2);
-		double alfa = 2 * alfa2;
-		double sintheta = sin(alfa) * rix;
-		double theta = asin(sintheta);
-		double rpan = focal * tan(theta);
+        xy[0] = (float) (rsolid * w / rfish);
+        xy[1] = (float) (rsolid * h / rfish);
+        break;
+    }
 
+    case 9: {
+        // from panoramic to fish
+        // for panoramic fish 2 f tan (@/2) get source
+        double rfish = sqrt(1.0 * (h * h + w * w));
+        double tanalfa2 = rfish / (2 * focal);
+        double alfa2 = atan(tanalfa2);
+        double alfa = 2 * alfa2;
+        double sintheta = sin(alfa) * rix;
+        double theta = asin(sintheta);
+        double rpan = focal * tan(theta);
 
-		xy[0] = (float)(rpan * w / rfish);
-		xy[1] = (float)(rpan * h / rfish);
-		break;
-	}
-	case 10:
-	{
-		//from Radial to fish
-		//for panoramic fish 2 f tan (@/2) get source
-		double rfish = sqrt(1.0 * (h * h + w * w));
-		double tanalfa = rfish / (focal);
-		double alfa = atan(tanalfa);
-		double sintheta = sin(alfa) * rix;
-		//double sinalfa = rix * asin(sintheta);
-		double theta = asin(sintheta);
-		double rRadial = focal * tan(theta);
+        xy[0] = (float) (rpan * w / rfish);
+        xy[1] = (float) (rpan * h / rfish);
+        break;
+    }
+    case 10: {
+        // from Radial to fish
+        // for panoramic fish 2 f tan (@/2) get source
+        double rfish = sqrt(1.0 * (h * h + w * w));
+        double tanalfa = rfish / (focal);
+        double alfa = atan(tanalfa);
+        double sintheta = sin(alfa) * rix;
+        // double sinalfa = rix * asin(sintheta);
+        double theta = asin(sintheta);
+        double rRadial = focal * tan(theta);
 
-		xy[0] = (float)(rRadial * w / rfish);
-		xy[1] = (float)(rRadial * h / rfish);
-		break;
-	}
+        xy[0] = (float) (rRadial * w / rfish);
+        xy[1] = (float) (rRadial * h / rfish);
+        break;
+    }
 
-
-	default:
-		break;
-	}
+    default: break;
+    }
 }
 
-void getSourceCoord(float* xy, const float ww, const float hh, const int method,
-	const float rNormal, const float *abc)
-{
-	if (method == 1)
-	{	
-		//Brown Conrady model
-		float rNorm =  (float)sqrt((double)(hh * hh  + ww * ww)) / rNormal;
-		float rnew = (((abc[0] * rNorm
+void getSourceCoord(float *xy, const float ww, const float hh, const int method,
+                    const float rNormal, const float *abc) {
+    if(method == 1) {
+        // Brown Conrady model
+        float rNorm = (float) sqrt((double) (hh * hh + ww * ww)) / rNormal;
+        float rnew = (((abc[0] * rNorm
 
-			+ abc[1]) * rNorm
+                        + abc[1]) *
+                           rNorm
 
-			+ abc[2]) * rNorm
+                       + abc[2]) *
+                          rNorm
 
-			+ (1.0f - abc[0] - abc[1] - abc[2]) );	// d
+                      + (1.0f - abc[0] - abc[1] - abc[2])); // d
 
-			xy[0] = rnew * ww;
-			xy[1] = rnew * hh;
-	}
-	else if (method == 2)
-	{
-		// division model
-		float radsq = (float)(hh * hh + ww * ww)/ (rNormal * rNormal);
-		float denom = ( 1.0f 
-			- (((abc[0] * radsq
-			+ abc[1]) * radsq
-			+ abc[2]) * radsq) );
-		xy[0] = ww / denom;
-		xy[1] = hh / denom;
-	}
+        xy[0] = rnew * ww;
+        xy[1] = rnew * hh;
+    } else if(method == 2) {
+        // division model
+        float radsq = (float) (hh * hh + ww * ww) / (rNormal * rNormal);
+        float denom =
+            (1.0f - (((abc[0] * radsq + abc[1]) * radsq + abc[2]) * radsq));
+        xy[0] = ww / denom;
+        xy[1] = hh / denom;
+    }
 }
 #endif
diff --git a/FisheyePart.cpp b/FisheyePart.cpp
index d298b4c..b752599 100644
--- a/FisheyePart.cpp
+++ b/FisheyePart.cpp
@@ -11,372 +11,369 @@ Material from Wikipedia used for barrel and pincushion corrections
  14 Oct 2021
 Copyright (C) <2021>  <V.C.Mohan>
 
-	This program is free software: you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation, version 3 of the License.
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, version 3 of the License.
 
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
 
-	A copy of the GNU General Public License is at
-	see <http://www.gnu.org/licenses/>.
+    A copy of the GNU General Public License is at
+    see <http://www.gnu.org/licenses/>.
 
-	For details of how to contact author see <http://www.avisynth.nl/users/vcmohan/vcmohan.html>
+    For details of how to contact author see
+<http://www.avisynth.nl/users/vcmohan/vcmohan.html>
 
 
 ********************************************************************************/
 
-//#include "windows.h"
-//#include <stdint.h>const finc* sp,
-// #define _USE_MATH_DEFINES
-//#include "math.h"
-//#include "InterpolationPack.h"
+// #include "windows.h"
+// #include <stdint.h>const finc* sp,
+//  #define _USE_MATH_DEFINES
+// #include "math.h"
+// #include "InterpolationPack.h"
 //
-//#include "VapourSynth.h"
+// #include "VapourSynth.h"
 //
 
 //-------------------------------------------------------------------------
 
-
 /*--------------------------------------------------
  * The following is the implementation
  * of the defined functions.
  --------------------------------------------------*/
- //Here is the acutal constructor code used
-
-static void VS_CC fisheyepartInit(VSMap* in, VSMap* out, void** instanceData, VSNode* node, VSCore* core, const VSAPI* vsapi)
-{
-	FisheyeData* d = (FisheyeData*)*instanceData;	
-	vsapi->setVideoInfo(d->ivi, 1, node);
-	double focal = getFocalLength(d->frad, d->method, d->fov);
-
-	d->oRadius = getOutputRadius(d->frad, focal, d->rix);
-	// input frame dimensions
-	int swidth = d->ivi->width;
-	int sheight = d->ivi->height;
-	int frsq = d->frad * d->frad;
-	// output
-	
-	const VSFormat* fi = d->ivi->format;
-	int nbytes = fi->bytesPerSample;
-	int nbits = fi->bitsPerSample;
-	d->quantile = 64;
-	d->nEntries = d->test ? 2 :d->q == 1? 3: 4;	
-		
-	d->xyAndQ = (int*)vs_aligned_malloc<int>(sizeof(int) * swidth * sheight * d->nEntries, 32);
-	d->rNorm = 1.0; // value not used in this part
-	int* xyQ = d->xyAndQ;
-	float xy[2];
-	int x, y, qx, qy;	
-
-	d->iCoeff = NULL;
-
-	if ( ! d->test)
-		d->iCoeff = setInterpolationScheme(d->q, d->quantile, &d->span);
-
-	float rNorm = (float)d->frad;
-	
-	//terms Barrel and Pincushion distortions are usually associated to longer focal lengths 
-	// and fish eye to wide angle(shorter focal length) lenses
-	
-	//float cUV[2]; // corresponding circle coordinates
-	for (int h = 0; h < sheight; h++)
-	{
-		float hh = (float)(h - d->origin_y);
-
-		for (int w = 0; w < swidth; w++)
-		{
-			float ww = (float)(w - d->origin_x);
-
-			getSourceXY(xy, ww, hh, d->method, focal, rNorm, d->rix);
-
-			x = (int)(floor(xy[0]));
-			y = (int)(floor(xy[1]));
-
-			// calculate nearest quantile of the fraction
-			qx = (int)((xy[0] - x) * d->quantile);
-			qy = (int)((xy[1] - y) * d->quantile);
-
-			x += d->origin_x;
-			y += d->origin_y;
-
-			int off = d->nEntries * (h * swidth + w);
-
-
-			if (x >= swidth  || y >= sheight  || x < 0 || y < 0
-				|| (x - d->origin_x) * (x - d->origin_x) + (y - d->origin_y) * (y - d->origin_y) > frsq)
-			{
-				xyQ[off] = - 1;
-			}
-			else
-			{
-				
-				xyQ[off] = x;
-				xyQ[off + 1] = y;
-
-				if (!d->test)
-				{
-					if (d->q > 1)
-					{
-						xyQ[off + 2] = qx;
-						xyQ[off + 3] = qy;
-					}
-					else if (d->q == 1)
-						// index value
-						xyQ[off + 2] = bestOfNineIndex(qx, qy, d->quantile);
-				}
-			}
-		}
-	}
-	// color to blacken out of area points
-	uint8_t bgr[] = { 0,0,0 }, yuv[] = { 16,128,128 };
-
-	if (d->test)
-	{
-		// will have white dots
-		d->ddensity = (5 - d->dots) * 16;
-		bgr[0] = 255;
-		bgr[1] = 255;
-		bgr[2] = 255;		
-	}
-	
-	convertBGRforInputFormat(d->col, bgr, fi);
-	
+// Here is the acutal constructor code used
+
+static void VS_CC fisheyepartInit(VSMap *in, VSMap *out, void **instanceData,
+                                  VSNode *node, VSCore *core,
+                                  const VSAPI *vsapi) {
+    FisheyeData *d = (FisheyeData *) *instanceData;
+    vsapi->setVideoInfo(d->ivi, 1, node);
+    double focal = getFocalLength(d->frad, d->method, d->fov);
+
+    d->oRadius = getOutputRadius(d->frad, focal, d->rix);
+    // input frame dimensions
+    int swidth = d->ivi->width;
+    int sheight = d->ivi->height;
+    int frsq = d->frad * d->frad;
+    // output
+
+    const VSFormat *fi = d->ivi->format;
+    int nbytes = fi->bytesPerSample;
+    int nbits = fi->bitsPerSample;
+    d->quantile = 64;
+    d->nEntries = d->test ? 2 : d->q == 1 ? 3 : 4;
+
+    d->xyAndQ = (int *) vs_aligned_malloc<int>(
+        sizeof(int) * swidth * sheight * d->nEntries, 32);
+    d->rNorm = 1.0; // value not used in this part
+    int *xyQ = d->xyAndQ;
+    float xy[2];
+    int x, y, qx, qy;
+
+    d->iCoeff = NULL;
+
+    if(!d->test)
+        d->iCoeff = setInterpolationScheme(d->q, d->quantile, &d->span);
+
+    float rNorm = (float) d->frad;
+
+    // terms Barrel and Pincushion distortions are usually associated to longer
+    // focal lengths
+    //  and fish eye to wide angle(shorter focal length) lenses
+
+    // float cUV[2]; // corresponding circle coordinates
+    for(int h = 0; h < sheight; h++) {
+        float hh = (float) (h - d->origin_y);
+
+        for(int w = 0; w < swidth; w++) {
+            float ww = (float) (w - d->origin_x);
+
+            getSourceXY(xy, ww, hh, d->method, focal, rNorm, d->rix);
+
+            x = (int) (floor(xy[0]));
+            y = (int) (floor(xy[1]));
+
+            // calculate nearest quantile of the fraction
+            qx = (int) ((xy[0] - x) * d->quantile);
+            qy = (int) ((xy[1] - y) * d->quantile);
+
+            x += d->origin_x;
+            y += d->origin_y;
+
+            int off = d->nEntries * (h * swidth + w);
+
+            if(x >= swidth || y >= sheight || x < 0 || y < 0 ||
+               (x - d->origin_x) * (x - d->origin_x) +
+                       (y - d->origin_y) * (y - d->origin_y) >
+                   frsq) {
+                xyQ[off] = -1;
+            } else {
+
+                xyQ[off] = x;
+                xyQ[off + 1] = y;
+
+                if(!d->test) {
+                    if(d->q > 1) {
+                        xyQ[off + 2] = qx;
+                        xyQ[off + 3] = qy;
+                    } else if(d->q == 1)
+                        // index value
+                        xyQ[off + 2] = bestOfNineIndex(qx, qy, d->quantile);
+                }
+            }
+        }
+    }
+    // color to blacken out of area points
+    uint8_t bgr[] = {0, 0, 0}, yuv[] = {16, 128, 128};
+
+    if(d->test) {
+        // will have white dots
+        d->ddensity = (5 - d->dots) * 16;
+        bgr[0] = 255;
+        bgr[1] = 255;
+        bgr[2] = 255;
+    }
+
+    convertBGRforInputFormat(d->col, bgr, fi);
 }
 
 //...............................................................
-static const VSFrameRef* VS_CC fisheyepartGetFrame(int n, int activationReason, void** instanceData,
-	void** frameData, VSFrameContext* frameCtx, VSCore* core, const VSAPI* vsapi)
-{
-	FisheyeData* d = (FisheyeData*)*instanceData;
-
-	if (activationReason == arInitial)
-	{
-		vsapi->requestFrameFilter(n, d->node, frameCtx);
-	}
-	else if (activationReason == arAllFramesReady)
-	{
-		const VSFrameRef* src = vsapi->getFrameFilter(n, d->node, frameCtx);
-		VSFrameRef* dst;
-		const VSFormat* fi = d->ivi->format;
-		int sheight = vsapi->getFrameHeight(src, 0);
-		int swidth = vsapi->getFrameWidth(src, 0);
-		int nbits = fi->bitsPerSample;
-		int nbytes = fi->bytesPerSample;
-		//will not process A plane
-		int np = fi->numPlanes > 3 ? 3 : fi->numPlanes;
-				
-		int kb = 1;
-
-		if (d->test)
-			// get src on which dots will be overlain			
-			dst = vsapi->copyFrame(src, core);
-		else
-			dst = vsapi->newVideoFrame(fi, swidth, sheight, src, core);
-
-		int dwidth = vsapi->getFrameWidth(dst, 0);
-		int dheight = vsapi->getFrameHeight(dst, 0);
-
-		int frsq = d->frad * d->frad;
-
-		for (int p = 0; p < np; p++)
-		{
-
-			const uint8_t* sp = vsapi->getReadPtr(src, p);
-			uint8_t* dp = vsapi->getWritePtr(dst, p);
-			int spitch = vsapi->getStride(src, p) / nbytes;
-			int dpitch = vsapi->getStride(dst, p) / nbytes;
-			// number of entries per row in the xyAndQ buffer
-			int nEntries = d->nEntries;
-
-			if (d->test)
-			{				
-				if (fi->colorFamily == cmRGB)
-				{
-					if (nbytes == 1)
-						dimplaneRGB(dp, sp, spitch, swidth, sheight, d->dim);
-					else if (nbytes == 2)
-						dimplaneRGB((uint16_t*)dp, (uint16_t*)sp, spitch, swidth, sheight, d->dim);
-					else if (nbytes == 4)
-						dimplaneRGB((float*)dp, (float*)sp, spitch, swidth, sheight, d->dim);
-				}
-
-				else if ( p == 0 && fi->colorFamily == cmYUV)
-				{
-					if (nbytes == 1)
-					{
-						uint8_t limit = (uint8_t)16;
-						dimplaneYUV(dp, dp, dpitch, dwidth, dheight, d->dim, limit);
-					}
-					else if (nbytes == 2)
-					{
-						uint16_t limit = (uint16_t)(16 << (nbits - 8));
-						dimplaneYUV((uint16_t*)dp, (uint16_t*)dp, dpitch, dwidth, dheight, d->dim, limit);
-					}
-					else if (nbytes == 4)
-						dimplaneYUV((float*)dp, (float*)dp, dpitch, dwidth, dheight, d->dim, 0.0f);
-				}
-				
-					// we will put dots
-				for (int h = d->ddensity / 2; h < sheight; h += d->ddensity)
-				{
-					int hoff = nEntries * h * swidth;
-
-					for (int w = d->ddensity / 2; w < swidth; w += d->ddensity)
-					{
-						int woff = nEntries * w;
-
-						int x = d->xyAndQ[hoff + woff];
-						int y = d->xyAndQ[hoff + woff + 1];
-
-						// ensure points are within src / fish eye						
-						if (x >= 0)
-						{
-							
-							if (nbytes == 1)
-								*(dp + y * dpitch + x) = d->col[p];
-							else if (nbytes == 2)
-								*( (uint16_t*)dp + y * dpitch + x) = *((uint16_t*)d->col + p);
-							else if (nbytes == 4)
-								*((float*)dp + y * dpitch + x) = *((float*)d->col + p);
-						}						
-					}
-				}				
-			}	// if test
-
-			else	// not test. normal processing
-			{	
-				
-				uint8_t min8 = 0, max8 = (uint8_t)255;
-				uint16_t min16 = (uint16_t)(fi->colorFamily == cmYUV ? 16 << (nbits - 8) : 0);
-				uint16_t max16 = (uint16_t)((fi->colorFamily == cmYUV ? 235 : 255 << (nbits - 8)) << (nbits - 8));
-				float minf = 0, maxf = 1.0f;
-
-				if (p > 0 && fi->colorFamily == cmYUV)
-				{
-					minf = -0.5f;
-					maxf = 0.5f;
-				}
-				int x, y, qx, qy,  span2 = d->span / 2;
-				int offh, offw;
-				int index;
-				int frsq = d->frad * d->frad;
-
-				for (int h = 0; h < dheight - 1; h++)
-				{
-					offh = h * dwidth * nEntries;
-
-					for (int w = 0; w < dwidth - 1; w++)
-					{				
-						offw = nEntries * w;
-
-						x = d->xyAndQ[offh + offw];
-						y = d->xyAndQ[offh + offw + 1];
-
-						if (d->q > 1)
-						{
-							qx = d->xyAndQ[offh + offw + 2];
-							qy = d->xyAndQ[offh + offw + 3];
-						}
-						else
-							index = d->xyAndQ[offh + offw + 2];
-						// was checked in init
-						//if (x >= swidth / 2   || y >= sheight / 2  || x < 0 || y < 0
-						//	|| x * x + y * y > frsq)
-						if ( x < 0)
-						{
-							// points are outside  src or fish. So make the point black
-							if (nbytes == 1)
-								*(dp + h * dpitch + w) = d->col[p];
-							else if (nbytes == 2)
-								*((uint16_t*)dp + h * dpitch + w) = *((uint16_t*)d->col + p);
-							else if (nbytes == 4)
-								*((float*)dp + h * dpitch + w) = *((float*)d->col + p);
-						}
-
-						else if (x >= swidth  - span2 - 1 || y >= sheight  - span2 -1
-							|| x < span2 + 1 || y < span2 + 1)
-						{
-							//  interpolation does not have sufficient points
-						// points are within src frame
-							if (nbytes == 1)
-							{
-								// near point
-								*(dp + h * dpitch + w) = *( sp + y * spitch + w);
-							}
-							else if (nbytes == 2)
-							{
-								*( (uint16_t*)dp + h * dpitch + w) = *((uint16_t*)sp + y * spitch + w);
-							}
-							else if (nbytes == 4)
-							{
-								
-								// near point
-								*((float*)dp + h * dpitch + w) = *((float*)sp + y * spitch + w);
-							}
-						}
-						
-						else if (x < swidth - span2 - 1 && y < sheight - span2 - 1 && x > span2 + 1 && y > span2 + 1)
-						{
-							
-							// sufficient points for interpolation are available
-							if (nbytes == 1)
-							{
-								if (d->q == 1)
-									*(dp + h * dpitch + w) = bestOfNine(sp, spitch,1, x, y, index);
-								else
-									//bilinear 2x2 or cubic 4x4 or lanczos 6x6
-									*(dp + h * dpitch + w) = clamp(LaQuantile(sp + y * spitch + x, spitch, 
-										  d->span,qx, qy,  d->iCoeff), min8, max8);
-																	
-							}
-
-							else if (nbytes == 2)
-							{
-								if (d->q == 1)
-									*((uint16_t*)dp + h * dpitch + w) = bestOfNine((uint16_t*)sp, spitch,1, x, y, index);
-								else
-								
-									*((uint16_t*)dp + h * dpitch + w) = clamp(LaQuantile((uint16_t*)sp + y * spitch + x, spitch,
-										 d->span,qx, qy, d->iCoeff), min16, max16);
-								
-							}
-
-							else if (nbytes == 4)
-							{
-								if (d->q == 1)
-									*((float*)dp + h * dpitch + w) = bestOfNine((float*)sp, spitch,1, x, y, index);
-								else
-								
-									*((float*)dp + h * dpitch + w) = clamp(LaQuantile((float*)sp + y * spitch + x, spitch,
-										d->span,qx, qy,  d->iCoeff), minf, maxf);
-								
-							}
-						}
-					}
-
-				}
-			}
-		}
-		vsapi->freeFrame(src);
-		return dst;
-	}
-	return 0;
+static const VSFrameRef *VS_CC fisheyepartGetFrame(
+    int n, int activationReason, void **instanceData, void **frameData,
+    VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) {
+    FisheyeData *d = (FisheyeData *) *instanceData;
+
+    if(activationReason == arInitial) {
+        vsapi->requestFrameFilter(n, d->node, frameCtx);
+    } else if(activationReason == arAllFramesReady) {
+        const VSFrameRef *src = vsapi->getFrameFilter(n, d->node, frameCtx);
+        VSFrameRef *dst;
+        const VSFormat *fi = d->ivi->format;
+        int sheight = vsapi->getFrameHeight(src, 0);
+        int swidth = vsapi->getFrameWidth(src, 0);
+        int nbits = fi->bitsPerSample;
+        int nbytes = fi->bytesPerSample;
+        // will not process A plane
+        int np = fi->numPlanes > 3 ? 3 : fi->numPlanes;
+
+        int kb = 1;
+
+        if(d->test)
+            // get src on which dots will be overlain
+            dst = vsapi->copyFrame(src, core);
+        else
+            dst = vsapi->newVideoFrame(fi, swidth, sheight, src, core);
+
+        int dwidth = vsapi->getFrameWidth(dst, 0);
+        int dheight = vsapi->getFrameHeight(dst, 0);
+
+        int frsq = d->frad * d->frad;
+
+        for(int p = 0; p < np; p++) {
+
+            const uint8_t *sp = vsapi->getReadPtr(src, p);
+            uint8_t *dp = vsapi->getWritePtr(dst, p);
+            int spitch = vsapi->getStride(src, p) / nbytes;
+            int dpitch = vsapi->getStride(dst, p) / nbytes;
+            // number of entries per row in the xyAndQ buffer
+            int nEntries = d->nEntries;
+
+            if(d->test) {
+                if(fi->colorFamily == cmRGB) {
+                    if(nbytes == 1)
+                        dimplaneRGB(dp, sp, spitch, swidth, sheight, d->dim);
+                    else if(nbytes == 2)
+                        dimplaneRGB((uint16_t *) dp, (uint16_t *) sp, spitch,
+                                    swidth, sheight, d->dim);
+                    else if(nbytes == 4)
+                        dimplaneRGB((float *) dp, (float *) sp, spitch, swidth,
+                                    sheight, d->dim);
+                }
+
+                else if(p == 0 && fi->colorFamily == cmYUV) {
+                    if(nbytes == 1) {
+                        uint8_t limit = (uint8_t) 16;
+                        dimplaneYUV(dp, dp, dpitch, dwidth, dheight, d->dim,
+                                    limit);
+                    } else if(nbytes == 2) {
+                        uint16_t limit = (uint16_t) (16 << (nbits - 8));
+                        dimplaneYUV((uint16_t *) dp, (uint16_t *) dp, dpitch,
+                                    dwidth, dheight, d->dim, limit);
+                    } else if(nbytes == 4)
+                        dimplaneYUV((float *) dp, (float *) dp, dpitch, dwidth,
+                                    dheight, d->dim, 0.0f);
+                }
+
+                // we will put dots
+                for(int h = d->ddensity / 2; h < sheight; h += d->ddensity) {
+                    int hoff = nEntries * h * swidth;
+
+                    for(int w = d->ddensity / 2; w < swidth; w += d->ddensity) {
+                        int woff = nEntries * w;
+
+                        int x = d->xyAndQ[hoff + woff];
+                        int y = d->xyAndQ[hoff + woff + 1];
+
+                        // ensure points are within src / fish eye
+                        if(x >= 0) {
+
+                            if(nbytes == 1)
+                                *(dp + y * dpitch + x) = d->col[p];
+                            else if(nbytes == 2)
+                                *((uint16_t *) dp + y * dpitch + x) =
+                                    *((uint16_t *) d->col + p);
+                            else if(nbytes == 4)
+                                *((float *) dp + y * dpitch + x) =
+                                    *((float *) d->col + p);
+                        }
+                    }
+                }
+            } // if test
+
+            else // not test. normal processing
+            {
+
+                uint8_t min8 = 0, max8 = (uint8_t) 255;
+                uint16_t min16 =
+                    (uint16_t) (fi->colorFamily == cmYUV ? 16 << (nbits - 8)
+                                                         : 0);
+                uint16_t max16 =
+                    (uint16_t) ((fi->colorFamily == cmYUV ? 235
+                                                          : 255 << (nbits - 8))
+                                << (nbits - 8));
+                float minf = 0, maxf = 1.0f;
+
+                if(p > 0 && fi->colorFamily == cmYUV) {
+                    minf = -0.5f;
+                    maxf = 0.5f;
+                }
+                int x, y, qx, qy, span2 = d->span / 2;
+                int offh, offw;
+                int index;
+                int frsq = d->frad * d->frad;
+
+                for(int h = 0; h < dheight - 1; h++) {
+                    offh = h * dwidth * nEntries;
+
+                    for(int w = 0; w < dwidth - 1; w++) {
+                        offw = nEntries * w;
+
+                        x = d->xyAndQ[offh + offw];
+                        y = d->xyAndQ[offh + offw + 1];
+
+                        if(d->q > 1) {
+                            qx = d->xyAndQ[offh + offw + 2];
+                            qy = d->xyAndQ[offh + offw + 3];
+                        } else
+                            index = d->xyAndQ[offh + offw + 2];
+                        // was checked in init
+                        // if (x >= swidth / 2   || y >= sheight / 2  || x < 0
+                        // || y < 0
+                        //	|| x * x + y * y > frsq)
+                        if(x < 0) {
+                            // points are outside  src or fish. So make the
+                            // point black
+                            if(nbytes == 1)
+                                *(dp + h * dpitch + w) = d->col[p];
+                            else if(nbytes == 2)
+                                *((uint16_t *) dp + h * dpitch + w) =
+                                    *((uint16_t *) d->col + p);
+                            else if(nbytes == 4)
+                                *((float *) dp + h * dpitch + w) =
+                                    *((float *) d->col + p);
+                        }
+
+                        else if(x >= swidth - span2 - 1 ||
+                                y >= sheight - span2 - 1 || x < span2 + 1 ||
+                                y < span2 + 1) {
+                            //  interpolation does not have sufficient points
+                            // points are within src frame
+                            if(nbytes == 1) {
+                                // near point
+                                *(dp + h * dpitch + w) = *(sp + y * spitch + w);
+                            } else if(nbytes == 2) {
+                                *((uint16_t *) dp + h * dpitch + w) =
+                                    *((uint16_t *) sp + y * spitch + w);
+                            } else if(nbytes == 4) {
+
+                                // near point
+                                *((float *) dp + h * dpitch + w) =
+                                    *((float *) sp + y * spitch + w);
+                            }
+                        }
+
+                        else if(x < swidth - span2 - 1 &&
+                                y < sheight - span2 - 1 && x > span2 + 1 &&
+                                y > span2 + 1) {
+
+                            // sufficient points for interpolation are available
+                            if(nbytes == 1) {
+                                if(d->q == 1)
+                                    *(dp + h * dpitch + w) =
+                                        bestOfNine(sp, spitch, 1, x, y, index);
+                                else
+                                    // bilinear 2x2 or cubic 4x4 or lanczos 6x6
+                                    *(dp + h * dpitch + w) = clamp(
+                                        LaQuantile(sp + y * spitch + x, spitch,
+                                                   d->span, qx, qy, d->iCoeff),
+                                        min8, max8);
+
+                            }
+
+                            else if(nbytes == 2) {
+                                if(d->q == 1)
+                                    *((uint16_t *) dp + h * dpitch + w) =
+                                        bestOfNine((uint16_t *) sp, spitch, 1,
+                                                   x, y, index);
+                                else
+
+                                    *((uint16_t *) dp + h * dpitch + w) = clamp(
+                                        LaQuantile(
+                                            (uint16_t *) sp + y * spitch + x,
+                                            spitch, d->span, qx, qy, d->iCoeff),
+                                        min16, max16);
+
+                            }
+
+                            else if(nbytes == 4) {
+                                if(d->q == 1)
+                                    *((float *) dp + h * dpitch + w) =
+                                        bestOfNine((float *) sp, spitch, 1, x,
+                                                   y, index);
+                                else
+
+                                    *((float *) dp + h * dpitch + w) = clamp(
+                                        LaQuantile(
+                                            (float *) sp + y * spitch + x,
+                                            spitch, d->span, qx, qy, d->iCoeff),
+                                        minf, maxf);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        vsapi->freeFrame(src);
+        return dst;
+    }
+    return 0;
 }
 
 /***************************************************************/
-static void VS_CC fisheyepartFree(void* instanceData, VSCore* core, const VSAPI* vsapi)
-{
-	FisheyeData* d = (FisheyeData*)instanceData;
-	vsapi->freeNode(d->node);
-	
-		vs_aligned_free(d->xyAndQ);
-		if (!d->iCoeff == NULL)
-			vs_aligned_free(d->iCoeff);
-	
-	free(d);
+static void VS_CC fisheyepartFree(void *instanceData, VSCore *core,
+                                  const VSAPI *vsapi) {
+    FisheyeData *d = (FisheyeData *) instanceData;
+    vsapi->freeNode(d->node);
+
+    vs_aligned_free(d->xyAndQ);
+    // Warning
+    // if (!d->iCoeff == NULL)
+    // Fix
+    if(d->iCoeff != NULL)
+        vs_aligned_free(d->iCoeff);
+
+    free(d);
 }
-
-
diff --git a/FourFoldSymmetricMarking.h b/FourFoldSymmetricMarking.h
index 3bec6c2..409511e 100644
--- a/FourFoldSymmetricMarking.h
+++ b/FourFoldSymmetricMarking.h
@@ -5,213 +5,219 @@
 // ensure no access violation occurs
 // dp and sp points to the centers, w and h are x and y distances from center
 // span 2 is bilinear, 4 is bicubic and 6 is lanczos 6x6 interpolation
-// quantile is quantized accuracy (1/q) of interpolation. LaQuantile is an interpolater.
-//iCoeff has (quantiles + 1)* span precomputed coefficients.
-template <typename finc>
-void paint4FoldSym(finc* dp, const int dpitch,const int kb, const int dw, const int dh, const finc col);
-template <typename finc>
-void paint4FoldSymIfChecks(finc* dp, const int dpitch, const int kb,
-	const int width, const int height, const int centerx, const int centery,
-	const int dw, const int dh, const int sw, const int sh, const finc col);
-template <typename finc>
-void copy4FoldSym(finc* dp, const int dpitch, const finc* sp, const int spitch, const int kb,
-	const int dw, const int dh, const int sw, const int sh);
-template <typename finc>
-void copy4FoldSymIfChecks(finc* dp, const int dpitch, const finc* sp, const int spitch, const int kb,
-	const int width, const int height, const int centerx, const int centery,
-	const int dw, const int dh, const int sw, const int sh);
-template <typename finc>
-void interpolate4FoldSym(finc* dp, const int dpitch, const finc* sp, const int spitch, const int kb,
-	const int dw, const int dh, const int sw, const int sh,
-	const int qx, const int qy, const int span,
-	const float* iCoeff, finc min, finc max);
-template <typename finc>
-void interpolate4FoldSymIfChecks(finc* dp, const int dpitch, const finc* sp, const int spitch, const int kb,
-	const int width, const int height, const int centerx, const int centery,
-	const int dw, const int dh, const int sw, const int sh,
-	const int qx, const int qy, const int span,
-	const float* iCoeff, finc min, finc max);
-template <typename finc>
-void interpolate9pt4FoldSym(finc* dp, const int dpitch, const finc* sp, const int spitch, const int kb,
-	const int dw, const int dh, const int sw, const int sh,
-	const int index);
-template <typename finc>
-void interpolate9pt4FoldSymIfChecks(finc* dp, const int dpitch, const finc* sp, const int spitch, const int kb,
-	const int width, const int height, const int centerx, const int centery,
-	const int dw, const int dh, const int sw, const int sh,
-	const int index);
+// quantile is quantized accuracy (1/q) of interpolation. LaQuantile is an
+// interpolater.
+// iCoeff has (quantiles + 1)* span precomputed coefficients.
+template <typename finc>
+void paint4FoldSym(finc *dp, const int dpitch, const int kb, const int dw,
+                   const int dh, const finc col);
+template <typename finc>
+void paint4FoldSymIfChecks(finc *dp, const int dpitch, const int kb,
+                           const int width, const int height, const int centerx,
+                           const int centery, const int dw, const int dh,
+                           const int sw, const int sh, const finc col);
+template <typename finc>
+void copy4FoldSym(finc *dp, const int dpitch, const finc *sp, const int spitch,
+                  const int kb, const int dw, const int dh, const int sw,
+                  const int sh);
+template <typename finc>
+void copy4FoldSymIfChecks(finc *dp, const int dpitch, const finc *sp,
+                          const int spitch, const int kb, const int width,
+                          const int height, const int centerx,
+                          const int centery, const int dw, const int dh,
+                          const int sw, const int sh);
+template <typename finc>
+void interpolate4FoldSym(finc *dp, const int dpitch, const finc *sp,
+                         const int spitch, const int kb, const int dw,
+                         const int dh, const int sw, const int sh, const int qx,
+                         const int qy, const int span, const float *iCoeff,
+                         finc min, finc max);
+template <typename finc>
+void interpolate4FoldSymIfChecks(
+    finc *dp, const int dpitch, const finc *sp, const int spitch, const int kb,
+    const int width, const int height, const int centerx, const int centery,
+    const int dw, const int dh, const int sw, const int sh, const int qx,
+    const int qy, const int span, const float *iCoeff, finc min, finc max);
+template <typename finc>
+void interpolate9pt4FoldSym(finc *dp, const int dpitch, const finc *sp,
+                            const int spitch, const int kb, const int dw,
+                            const int dh, const int sw, const int sh,
+                            const int index);
+template <typename finc>
+void interpolate9pt4FoldSymIfChecks(finc *dp, const int dpitch, const finc *sp,
+                                    const int spitch, const int kb,
+                                    const int width, const int height,
+                                    const int centerx, const int centery,
+                                    const int dw, const int dh, const int sw,
+                                    const int sh, const int index);
 //.......................................................................................
 template <typename finc>
-void paint4FoldSym(finc* dp, const int dpitch, const int kb, const int dw, const int dh, const finc col)
-{
-	// dp points to center of circle / square
-	*(dp + dh * dpitch + kb * dw) = col;
-	*(dp + dh * dpitch - kb * dw) = col;
-	*(dp - dh * dpitch + kb * dw) = col;
-	*(dp - dh * dpitch - kb * dw) = col;
+void paint4FoldSym(finc *dp, const int dpitch, const int kb, const int dw,
+                   const int dh, const finc col) {
+    // dp points to center of circle / square
+    *(dp + dh * dpitch + kb * dw) = col;
+    *(dp + dh * dpitch - kb * dw) = col;
+    *(dp - dh * dpitch + kb * dw) = col;
+    *(dp - dh * dpitch - kb * dw) = col;
 }
 
 template <typename finc>
-void copy4FoldSym(finc* dp, const int dpitch, const finc* sp, const int spitch, const int kb,
-	const int dw, const int dh, const int sw, const int sh)
-{
-	// dp and sp points to centers of output and input circles
-	*(dp + dh * dpitch + kb * dw) = *(sp + sh * spitch + kb * sw);
-	*(dp + dh * dpitch - kb * dw) = *(sp + sh * spitch - kb * sw);
-	*(dp - dh * dpitch + kb * dw) = *(sp - sh * spitch + kb * sw);
-	*(dp - dh * dpitch - kb * dw) = *(sp - sh * spitch - kb * sw);
-
+void copy4FoldSym(finc *dp, const int dpitch, const finc *sp, const int spitch,
+                  const int kb, const int dw, const int dh, const int sw,
+                  const int sh) {
+    // dp and sp points to centers of output and input circles
+    *(dp + dh * dpitch + kb * dw) = *(sp + sh * spitch + kb * sw);
+    *(dp + dh * dpitch - kb * dw) = *(sp + sh * spitch - kb * sw);
+    *(dp - dh * dpitch + kb * dw) = *(sp - sh * spitch + kb * sw);
+    *(dp - dh * dpitch - kb * dw) = *(sp - sh * spitch - kb * sw);
 }
 template <typename finc>
-void interpolate4FoldSym(finc* dp, const int dpitch, const finc* sp, const int spitch, const int kb,
-	const int dw, const int dh, const int sw, const int sh,
-	const int qx, const int qy,  const int span,
-	const float* iCoeff, finc min, finc max)
-{
-	// dp and sp at centers of output and input circles;
-	*(dp + dh * dpitch + kb * dw) =
-		clamp(LaQuantile(sp + sh * spitch + kb * sw, spitch,kb,
-			span, qx, qy, iCoeff), min, max);
-	*(dp + dh * dpitch - kb * dw) =
-		clamp(LaQuantile(sp + sh * spitch  - kb * sw, spitch, -kb,
-			span, qx, qy, iCoeff), min, max);
-	*(dp - dh * dpitch + kb * dw) =
-		clamp(LaQuantile(sp - sh * spitch + kb * sw, -spitch, kb,
-			span, qx, qy, iCoeff), min, max);
-	*(dp - dh * dpitch - kb * dw) =
-		clamp(LaQuantile(sp - sh * spitch - kb * sw, -spitch, -kb,
-			span, qx, qy, iCoeff), min, max);
-
+void interpolate4FoldSym(finc *dp, const int dpitch, const finc *sp,
+                         const int spitch, const int kb, const int dw,
+                         const int dh, const int sw, const int sh, const int qx,
+                         const int qy, const int span, const float *iCoeff,
+                         finc min, finc max) {
+    // dp and sp at centers of output and input circles;
+    *(dp + dh * dpitch + kb * dw) =
+        clamp(LaQuantile(sp + sh * spitch + kb * sw, spitch, kb, span, qx, qy,
+                         iCoeff),
+              min, max);
+    *(dp + dh * dpitch - kb * dw) =
+        clamp(LaQuantile(sp + sh * spitch - kb * sw, spitch, -kb, span, qx, qy,
+                         iCoeff),
+              min, max);
+    *(dp - dh * dpitch + kb * dw) =
+        clamp(LaQuantile(sp - sh * spitch + kb * sw, -spitch, kb, span, qx, qy,
+                         iCoeff),
+              min, max);
+    *(dp - dh * dpitch - kb * dw) =
+        clamp(LaQuantile(sp - sh * spitch - kb * sw, -spitch, -kb, span, qx, qy,
+                         iCoeff),
+              min, max);
 }
 
 template <typename finc>
-void interpolate9pt4FoldSym(finc* dp, const int dpitch, const finc* sp, const int spitch, const int kb,
-	const int dw, const int dh, const int sw, const int sh,
-	const int index)
-{
-	// both h and w positive
-	*(dp + dh * dpitch + kb * dw) = bestOfNine(sp, spitch, kb, sw, sh, index);
-	// both h & w negative
-	*(dp - dh * dpitch - kb * dw) = bestOfNine(sp, -spitch, -kb, sw, sh, index);
-	//  h negative w positive
-	*(dp - dh * dpitch + kb * dw) = bestOfNine(sp, -spitch, kb,	sw, sh, index);
-	// h  positive w negative
-	*(dp + dh * dpitch - kb * dw) = bestOfNine(sp, spitch, -kb,	sw, sh, index);
-
+void interpolate9pt4FoldSym(finc *dp, const int dpitch, const finc *sp,
+                            const int spitch, const int kb, const int dw,
+                            const int dh, const int sw, const int sh,
+                            const int index) {
+    // both h and w positive
+    *(dp + dh * dpitch + kb * dw) = bestOfNine(sp, spitch, kb, sw, sh, index);
+    // both h & w negative
+    *(dp - dh * dpitch - kb * dw) = bestOfNine(sp, -spitch, -kb, sw, sh, index);
+    //  h negative w positive
+    *(dp - dh * dpitch + kb * dw) = bestOfNine(sp, -spitch, kb, sw, sh, index);
+    // h  positive w negative
+    *(dp + dh * dpitch - kb * dw) = bestOfNine(sp, spitch, -kb, sw, sh, index);
 }
 
 template <typename finc>
-void paint4FoldSymIfChecks(finc* dp, const int dpitch, const int kb, 
-	const int width, const int height, const int centerx, const int centery,
-	const int dw, const int dh, const int sw, const int sh, const finc col)
-{
-	// dp points to center of circle / square
-	if (sh + centery < height)
-	{
-		if (sw + centerx < width)
-			*(dp + dh * dpitch + kb * dw) = col;
-
-		if (centerx - sw >= 0)
-			*(dp + dh * dpitch - kb * dw) = col;
-	}
-	if (centery - dh >= 0)
-	{
-		if (sw + centerx < width)
-			*(dp - dh * dpitch + kb * dw) = col;
-
-		if (centerx - sw >= 0)
-			*(dp - dh * dpitch - kb * dw) = col;
-	}
+void paint4FoldSymIfChecks(finc *dp, const int dpitch, const int kb,
+                           const int width, const int height, const int centerx,
+                           const int centery, const int dw, const int dh,
+                           const int sw, const int sh, const finc col) {
+    // dp points to center of circle / square
+    if(sh + centery < height) {
+        if(sw + centerx < width)
+            *(dp + dh * dpitch + kb * dw) = col;
+
+        if(centerx - sw >= 0)
+            *(dp + dh * dpitch - kb * dw) = col;
+    }
+    if(centery - dh >= 0) {
+        if(sw + centerx < width)
+            *(dp - dh * dpitch + kb * dw) = col;
+
+        if(centerx - sw >= 0)
+            *(dp - dh * dpitch - kb * dw) = col;
+    }
 }
 
 template <typename finc>
-void copy4FoldSymIfChecks(finc* dp, const int dpitch, const finc* sp, const int spitch, const int kb,
-	const int width, const int height, const int centerx, const int centery,
-	const int dw, const int dh, const int sw, const int sh)
-{
-	// dp and sp points to centers of output and input circles
-	
-	if (sh + centery < height)
-	{
-		if (sw + centerx < width)
-			*(dp + dh * dpitch + kb * dw) = *(sp + sh * spitch + kb * sw);
+void copy4FoldSymIfChecks(finc *dp, const int dpitch, const finc *sp,
+                          const int spitch, const int kb, const int width,
+                          const int height, const int centerx,
+                          const int centery, const int dw, const int dh,
+                          const int sw, const int sh) {
+    // dp and sp points to centers of output and input circles
 
-		if (centerx - sw >= 0)
-			*(dp + dh * dpitch - kb * dw) = *(sp + sh * spitch - kb * sw);
-	}
-	if (centery - sh >= 0)
-	{
-		if (sw + centerx < width)
-			*(dp - dh * dpitch + kb * dw) = *(sp - sh * spitch + kb * sw);
+    if(sh + centery < height) {
+        if(sw + centerx < width)
+            *(dp + dh * dpitch + kb * dw) = *(sp + sh * spitch + kb * sw);
 
-		if (centerx - sw >= 0)
-			*(dp - dh * dpitch - kb * dw) = *(sp - sh * spitch - kb * sw);
-	}
+        if(centerx - sw >= 0)
+            *(dp + dh * dpitch - kb * dw) = *(sp + sh * spitch - kb * sw);
+    }
+    if(centery - sh >= 0) {
+        if(sw + centerx < width)
+            *(dp - dh * dpitch + kb * dw) = *(sp - sh * spitch + kb * sw);
 
+        if(centerx - sw >= 0)
+            *(dp - dh * dpitch - kb * dw) = *(sp - sh * spitch - kb * sw);
+    }
 }
 template <typename finc>
-void interpolate4FoldSymIfChecks(finc* dp, const int dpitch, const finc* sp, const int spitch, const int kb,
-	const int width, const int height, const int centerx, const int centery,
-	const int dw, const int dh, const int sw, const int sh,
-	const int qx, const int qy, const int span,
-	const float* iCoeff, finc min, finc max)
-{
-	// dp and sp at centers of output and input circles;
-	if (sh + centery < height)
-	{
-		if (sw + centerx < width)
-			*(dp + dh * dpitch + kb * dw) =
-			clamp(LaQuantile(sp + sh * spitch + kb * sw, spitch, kb,
-				span, qx, qy, iCoeff), min, max);
-
-		if (centerx - sw >= 0)
-			*(dp + dh * dpitch - kb * dw) =
-			clamp(LaQuantile(sp + sh * spitch - kb * sw, spitch, -kb,
-				span, qx, qy, iCoeff), min, max);
-	}
-	if (centery - sh >= 0)
-	{
-		if (sw + centerx < width)
-			*(dp - dh * dpitch + kb * dw) =
-			clamp(LaQuantile(sp - sh * spitch + kb * sw, -spitch, kb,
-				span, qx, qy, iCoeff), min, max);
-
-		if (centerx - sw >= 0)
-			*(dp - dh * dpitch - kb * dw) =
-			clamp(LaQuantile(sp - sh * spitch - kb * sw, -spitch, -kb,
-				span, qx, qy, iCoeff), min, max);
-	}
-	
+void interpolate4FoldSymIfChecks(
+    finc *dp, const int dpitch, const finc *sp, const int spitch, const int kb,
+    const int width, const int height, const int centerx, const int centery,
+    const int dw, const int dh, const int sw, const int sh, const int qx,
+    const int qy, const int span, const float *iCoeff, finc min, finc max) {
+    // dp and sp at centers of output and input circles;
+    if(sh + centery < height) {
+        if(sw + centerx < width)
+            *(dp + dh * dpitch + kb * dw) =
+                clamp(LaQuantile(sp + sh * spitch + kb * sw, spitch, kb, span,
+                                 qx, qy, iCoeff),
+                      min, max);
+
+        if(centerx - sw >= 0)
+            *(dp + dh * dpitch - kb * dw) =
+                clamp(LaQuantile(sp + sh * spitch - kb * sw, spitch, -kb, span,
+                                 qx, qy, iCoeff),
+                      min, max);
+    }
+    if(centery - sh >= 0) {
+        if(sw + centerx < width)
+            *(dp - dh * dpitch + kb * dw) =
+                clamp(LaQuantile(sp - sh * spitch + kb * sw, -spitch, kb, span,
+                                 qx, qy, iCoeff),
+                      min, max);
+
+        if(centerx - sw >= 0)
+            *(dp - dh * dpitch - kb * dw) =
+                clamp(LaQuantile(sp - sh * spitch - kb * sw, -spitch, -kb, span,
+                                 qx, qy, iCoeff),
+                      min, max);
+    }
 }
 
 template <typename finc>
-void interpolate9pt4FoldSymIfChecks(finc* dp, const int dpitch, const finc* sp, const int spitch, const int kb,
-	const int width, const int height, const int centerx, const int centery,
-	const int dw, const int dh, const int sw, const int sh,
-	const int index)
-{
-	if (sh + centery < height)
-	{
-		if (sw + centerx < width)
-			// both h and w positive
-			*(dp + dh * dpitch + kb * dw) = bestOfNine(sp, spitch, kb,
-				sw, sh, index);
-		if (centerx - sw >= 0)
-			// h  positive w negative
-			*(dp + dh * dpitch - kb * dw) = bestOfNine(sp, spitch, -kb,
-				sw, sh, index);
-	}
-
-	if (centery - sh >= 0)
-	{
-		if (sw + centerx < width)
-			//  h negative w positive
-			*(dp - dh * dpitch + kb * dw) = bestOfNine(sp, -spitch, kb,
-				sw, sh, index);
-		if (centerx - sw >= 0)
-			// both h & w negative
-			*(dp - dh * dpitch - kb * dw) = bestOfNine(sp, -spitch, -kb,
-				sw, sh, index);
-	}
+void interpolate9pt4FoldSymIfChecks(finc *dp, const int dpitch, const finc *sp,
+                                    const int spitch, const int kb,
+                                    const int width, const int height,
+                                    const int centerx, const int centery,
+                                    const int dw, const int dh, const int sw,
+                                    const int sh, const int index) {
+    if(sh + centery < height) {
+        if(sw + centerx < width)
+            // both h and w positive
+            *(dp + dh * dpitch + kb * dw) =
+                bestOfNine(sp, spitch, kb, sw, sh, index);
+        if(centerx - sw >= 0)
+            // h  positive w negative
+            *(dp + dh * dpitch - kb * dw) =
+                bestOfNine(sp, spitch, -kb, sw, sh, index);
+    }
+
+    if(centery - sh >= 0) {
+        if(sw + centerx < width)
+            //  h negative w positive
+            *(dp - dh * dpitch + kb * dw) =
+                bestOfNine(sp, -spitch, kb, sw, sh, index);
+        if(centerx - sw >= 0)
+            // both h & w negative
+            *(dp - dh * dpitch - kb * dw) =
+                bestOfNine(sp, -spitch, -kb, sw, sh, index);
+    }
 }
 #endif
diff --git a/Squircles.h b/Squircles.h
index a90465c..ad373fb 100644
--- a/Squircles.h
+++ b/Squircles.h
@@ -2,19 +2,18 @@
 #define SQUIRCLES_H_V_C_MOHAN
 // Assume #define _USE_MATH_DEFINES
 // All coordinates are for unit circle ( rad = 1) and square (-1,1, -1, 1)
-void SquareToCircularDisc(float* uv, const float x, const float y);
-void CircularDiscToSquare(float* xy, const float cU, const float cV);
+void SquareToCircularDisc(float *uv, const float x, const float y);
+void CircularDiscToSquare(float *xy, const float cU, const float cV);
 // normalize,convert and get back in input units
-void getSquircleUV(float* cUV, const int w, const int h, const int rad);
-void getxySquircle(float* xy, const float cU, const float cV, const int rad);
-// 
+void getSquircleUV(float *cUV, const int w, const int h, const int rad);
+void getxySquircle(float *xy, const float cU, const float cV, const int rad);
+//
 // mapping a circular disc to a square region
 // input: (u,v) coordinates in the circle
 // output: xy[2] coordinates in the square
-void CircularDiscToSquare( float * xy, const float u, const float v)
-{
-    double u2 = (double)(u * u);
-    double v2 = (double)(v * v);
+void CircularDiscToSquare(float *xy, const float u, const float v) {
+    double u2 = (double) (u * u);
+    double v2 = (double) (v * v);
     double twosqrt2 = 2.0 * M_SQRT2;
     double subtermx = 2.0 + u2 - v2;
     double subtermy = 2.0 - u2 + v2;
@@ -22,43 +21,37 @@ void CircularDiscToSquare( float * xy, const float u, const float v)
     double termx2 = subtermx - u * twosqrt2;
     double termy1 = subtermy + v * twosqrt2;
     double termy2 = subtermy - v * twosqrt2;
-    xy[0] = (float)(0.5 * sqrt(termx1) - 0.5 * sqrt(termx2));
-    xy[1] = (float)(0.5 * sqrt(termy1) - 0.5 * sqrt(termy2));
-
+    xy[0] = (float) (0.5 * sqrt(termx1) - 0.5 * sqrt(termx2));
+    xy[1] = (float) (0.5 * sqrt(termy1) - 0.5 * sqrt(termy2));
 }
 
-
-// 
+//
 // mapping a square region to a circular disc
 // input: (x,y) coordinates in the square
 // output: uv[2] coordinates in the circle
-void SquareToCircularDisc(float * uv, const float x, const float y)
-{
-    uv[0] = (float)(x * sqrt(1.0 - (y * y) / 2.0));
-    uv[1] = (float)(y * sqrt(1.0 - (x * x) / 2.0));
+void SquareToCircularDisc(float *uv, const float x, const float y) {
+    uv[0] = (float) (x * sqrt(1.0 - (y * y) / 2.0));
+    uv[1] = (float) (y * sqrt(1.0 - (x * x) / 2.0));
 }
 
-void getSquircleUV(float* cUV, const int w, const int h, const int rad)
-{
+void getSquircleUV(float *cUV, const int w, const int h, const int rad) {
     // normalize
-    float ww = (float)w / (float)rad;
-    float hh = (float)h / (float)rad;
+    float ww = (float) w / (float) rad;
+    float hh = (float) h / (float) rad;
     SquareToCircularDisc(cUV, ww, hh);
     // get back in original units
     cUV[0] *= rad;
     cUV[1] *= rad;
 }
 
-void getxySquircle(float* xy, const float cU, const float cV, const int rad)
-{
+void getxySquircle(float *xy, const float cU, const float cV, const int rad) {
     // normalize
     float cUU = cU / rad;
     float cVV = cV / rad;
     CircularDiscToSquare(xy, cUU, cVV);
-    
+
     // get back in original units
     xy[0] *= rad;
     xy[1] *= rad;
 }
 #endif
-
diff --git a/VSHelper.h b/VSHelper.h
index 3d60441..8fe4c98 100644
--- a/VSHelper.h
+++ b/VSHelper.h
@@ -1,22 +1,22 @@
 /*****************************************************************************
-* Copyright (c) 2012-2015 Fredrik Mellbin
-* --- Legal stuff ---
-* This program is free software. It comes without any warranty, to
-* the extent permitted by applicable law. You can redistribute it
-* and/or modify it under the terms of the Do What The Fuck You Want
-* To Public License, Version 2, as published by Sam Hocevar. See
-* http://sam.zoy.org/wtfpl/COPYING for more details.
-*****************************************************************************/
+ * Copyright (c) 2012-2015 Fredrik Mellbin
+ * --- Legal stuff ---
+ * This program is free software. It comes without any warranty, to
+ * the extent permitted by applicable law. You can redistribute it
+ * and/or modify it under the terms of the Do What The Fuck You Want
+ * To Public License, Version 2, as published by Sam Hocevar. See
+ * http://sam.zoy.org/wtfpl/COPYING for more details.
+ *****************************************************************************/
 
 #ifndef VSHELPER_H
 #define VSHELPER_H
 
+#include <assert.h>
 #include <limits.h>
+#include <math.h>
 #include <stdint.h>
 #include <stdlib.h>
 #include <string.h>
-#include <assert.h>
-#include <math.h>
 #ifdef _WIN32
 #include <malloc.h>
 #endif
@@ -27,63 +27,83 @@
 #define inline _inline
 #endif
 
-/* A kinda portable definition of the C99 restrict keyword (or its inofficial C++ equivalent) */
-#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L /* Available in C99 */
+/* A kinda portable definition of the C99 restrict keyword (or its inofficial
+ * C++ equivalent) */
+#if defined(__STDC_VERSION__) &&                                               \
+    __STDC_VERSION__ >= 199901L /* Available in C99 */
 #define VS_RESTRICT restrict
-#elif defined(__cplusplus) || defined(_MSC_VER) /* Almost all relevant C++ compilers support it so just assume it works */
+#elif defined(__cplusplus) ||                                                  \
+    defined(_MSC_VER) /* Almost all relevant C++ compilers support it so just  \
+                         assume it works */
 #define VS_RESTRICT __restrict
 #else /* Not supported */
 #define VS_RESTRICT
 #endif
 
 #ifdef _WIN32
-#define VS_ALIGNED_MALLOC(pptr, size, alignment) do { *(pptr) = _aligned_malloc((size), (alignment)); } while (0)
-#define VS_ALIGNED_FREE(ptr) do { _aligned_free((ptr)); } while (0)
+#define VS_ALIGNED_MALLOC(pptr, size, alignment)                               \
+    do {                                                                       \
+        *(pptr) = _aligned_malloc((size), (alignment));                        \
+    } while(0)
+#define VS_ALIGNED_FREE(ptr)                                                   \
+    do {                                                                       \
+        _aligned_free((ptr));                                                  \
+    } while(0)
 #else
-#define VS_ALIGNED_MALLOC(pptr, size, alignment) do { if(posix_memalign((void**)(pptr), (alignment), (size))) *((void**)pptr) = NULL; } while (0)
-#define VS_ALIGNED_FREE(ptr) do { free((ptr)); } while (0)
+#define VS_ALIGNED_MALLOC(pptr, size, alignment)                               \
+    do {                                                                       \
+        if(posix_memalign((void **) (pptr), (alignment), (size)))              \
+            *((void **) pptr) = NULL;                                          \
+    } while(0)
+#define VS_ALIGNED_FREE(ptr)                                                   \
+    do {                                                                       \
+        free((ptr));                                                           \
+    } while(0)
 #endif
 
-#define VSMAX(a,b) ((a) > (b) ? (a) : (b))
-#define VSMIN(a,b) ((a) > (b) ? (b) : (a))
+#define VSMAX(a, b) ((a) > (b) ? (a) : (b))
+#define VSMIN(a, b) ((a) > (b) ? (b) : (a))
 
-#ifdef __cplusplus 
+#ifdef __cplusplus
 /* A nicer templated malloc for all the C++ users out there */
 #if __cplusplus >= 201103L || (defined(_MSC_VER) && _MSC_VER >= 1900)
-template<typename T=void>
+template <typename T = void>
 #else
-template<typename T>
+template <typename T>
 #endif
-static inline T* vs_aligned_malloc(size_t size, size_t alignment) {
+static inline T *vs_aligned_malloc(size_t size, size_t alignment) {
 #ifdef _WIN32
-    return (T*)_aligned_malloc(size, alignment);
+    return (T *) _aligned_malloc(size, alignment);
 #else
     void *tmp = NULL;
-    if (posix_memalign(&tmp, alignment, size))
+    if(posix_memalign(&tmp, alignment, size))
         tmp = 0;
-    return (T*)tmp;
+    return (T *) tmp;
 #endif
 }
 
-static inline void vs_aligned_free(void *ptr) {
-    VS_ALIGNED_FREE(ptr);
-}
+static inline void vs_aligned_free(void *ptr) { VS_ALIGNED_FREE(ptr); }
 #endif /* __cplusplus */
 
-/* convenience function for checking if the format never changes between frames */
+/* convenience function for checking if the format never changes between frames
+ */
 static inline int isConstantFormat(const VSVideoInfo *vi) {
     return vi->height > 0 && vi->width > 0 && vi->format;
 }
 
-/* convenience function to check for if two clips have the same format (unknown/changeable will be considered the same too) */
+/* convenience function to check for if two clips have the same format
+ * (unknown/changeable will be considered the same too) */
 static inline int isSameFormat(const VSVideoInfo *v1, const VSVideoInfo *v2) {
-    return v1->height == v2->height && v1->width == v2->width && v1->format == v2->format;
+    return v1->height == v2->height && v1->width == v2->width &&
+           v1->format == v2->format;
 }
 
-/* multiplies and divides a rational number, such as a frame duration, in place and reduces the result */
-static inline void muldivRational(int64_t *num, int64_t *den, int64_t mul, int64_t div) {
+/* multiplies and divides a rational number, such as a frame duration, in place
+ * and reduces the result */
+static inline void muldivRational(int64_t *num, int64_t *den, int64_t mul,
+                                  int64_t div) {
     /* do nothing if the rational number is invalid */
-    if (!*den)
+    if(!*den)
         return;
 
     /* nobody wants to accidentally divide by zero */
@@ -94,12 +114,12 @@ static inline void muldivRational(int64_t *num, int64_t *den, int64_t mul, int64
     *den *= div;
     a = *num;
     b = *den;
-    while (b != 0) {
+    while(b != 0) {
         int64_t t = a;
         a = b;
         b = t % b;
     }
-    if (a < 0)
+    if(a < 0)
         a = -a;
     *num /= a;
     *den /= a;
@@ -111,15 +131,16 @@ static inline void vs_normalizeRational(int64_t *num, int64_t *den) {
 }
 
 /* add two rational numbers and reduces the result */
-static inline void vs_addRational(int64_t *num, int64_t *den, int64_t addnum, int64_t addden) {
+static inline void vs_addRational(int64_t *num, int64_t *den, int64_t addnum,
+                                  int64_t addden) {
     /* do nothing if the rational number is invalid */
-    if (!*den)
+    if(!*den)
         return;
 
     /* nobody wants to accidentally add an invalid rational number */
     assert(addden);
 
-    if (*den == addden) {
+    if(*den == addden) {
         *num += addnum;
     } else {
         int64_t temp = addden;
@@ -134,24 +155,27 @@ static inline void vs_addRational(int64_t *num, int64_t *den, int64_t addnum, in
     }
 }
 
-/* converts an int64 to int with saturation, useful to silence warnings when reading int properties among other things */
+/* converts an int64 to int with saturation, useful to silence warnings when
+ * reading int properties among other things */
 static inline int int64ToIntS(int64_t i) {
-    if (i > INT_MAX)
+    if(i > INT_MAX)
         return INT_MAX;
-    else if (i < INT_MIN)
+    else if(i < INT_MIN)
         return INT_MIN;
-    else return (int)i;
+    else
+        return (int) i;
 }
 
-static inline void vs_bitblt(void *dstp, int dst_stride, const void *srcp, int src_stride, size_t row_size, size_t height) {
-    if (height) {
-        if (src_stride == dst_stride && src_stride == (int)row_size) {
+static inline void vs_bitblt(void *dstp, int dst_stride, const void *srcp,
+                             int src_stride, size_t row_size, size_t height) {
+    if(height) {
+        if(src_stride == dst_stride && src_stride == (int) row_size) {
             memcpy(dstp, srcp, row_size * height);
         } else {
-            const uint8_t *srcp8 = (const uint8_t *)srcp;
-            uint8_t *dstp8 = (uint8_t *)dstp;
+            const uint8_t *srcp8 = (const uint8_t *) srcp;
+            uint8_t *dstp8 = (uint8_t *) dstp;
             size_t i;
-            for (i = 0; i < height; i++) {
+            for(i = 0; i < height; i++) {
                 memcpy(dstp8, srcp8, row_size);
                 srcp8 += src_stride;
                 dstp8 += dst_stride;
@@ -162,8 +186,10 @@ static inline void vs_bitblt(void *dstp, int dst_stride, const void *srcp, int s
 
 /* check if the frame dimensions are valid for a given format */
 /* returns non-zero for valid width and height */
-static inline int areValidDimensions(const VSFormat *fi, int width, int height) {
-    return !(width % (1 << fi->subSamplingW) || height % (1 << fi->subSamplingH));
+static inline int areValidDimensions(const VSFormat *fi, int width,
+                                     int height) {
+    return !(width % (1 << fi->subSamplingW) ||
+             height % (1 << fi->subSamplingH));
 }
 
 /* Visual Studio doesn't recognize inline in c mode */
diff --git a/VapourSynth.h b/VapourSynth.h
index e03dc61..7c97fda 100644
--- a/VapourSynth.h
+++ b/VapourSynth.h
@@ -1,22 +1,22 @@
 /*
-* Copyright (c) 2012-2017 Fredrik Mellbin
-*
-* This file is part of VapourSynth.
-*
-* VapourSynth is free software; you can redistribute it and/or
-* modify it under the terms of the GNU Lesser General Public
-* License as published by the Free Software Foundation; either
-* version 2.1 of the License, or (at your option) any later version.
-*
-* VapourSynth is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-* Lesser General Public License for more details.
-*
-* You should have received a copy of the GNU Lesser General Public
-* License along with VapourSynth; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
-*/
+ * Copyright (c) 2012-2017 Fredrik Mellbin
+ *
+ * This file is part of VapourSynth.
+ *
+ * VapourSynth is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * VapourSynth is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with VapourSynth; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
 
 #ifndef VAPOURSYNTH_H
 #define VAPOURSYNTH_H
@@ -25,40 +25,42 @@
 
 #define VAPOURSYNTH_API_MAJOR 3
 #define VAPOURSYNTH_API_MINOR 6
-#define VAPOURSYNTH_API_VERSION ((VAPOURSYNTH_API_MAJOR << 16) | (VAPOURSYNTH_API_MINOR))
+#define VAPOURSYNTH_API_VERSION                                                \
+    ((VAPOURSYNTH_API_MAJOR << 16) | (VAPOURSYNTH_API_MINOR))
 
 /* Convenience for C++ users. */
 #ifdef __cplusplus
-#    define VS_EXTERN_C extern "C"
-#    if __cplusplus >= 201103L || (defined(_MSC_VER) && _MSC_VER >= 1900)
-#        define VS_NOEXCEPT noexcept
-#    else
-#        define VS_NOEXCEPT
-#    endif
+#define VS_EXTERN_C extern "C"
+#if __cplusplus >= 201103L || (defined(_MSC_VER) && _MSC_VER >= 1900)
+#define VS_NOEXCEPT noexcept
 #else
-#    define VS_EXTERN_C
-#    define VS_NOEXCEPT
+#define VS_NOEXCEPT
+#endif
+#else
+#define VS_EXTERN_C
+#define VS_NOEXCEPT
 #endif
 
 #if defined(_WIN32) && !defined(_WIN64)
-#    define VS_CC __stdcall
+#define VS_CC __stdcall
 #else
-#    define VS_CC
+#define VS_CC
 #endif
 
 /* And now for some symbol hide-and-seek... */
 #if defined(_WIN32) /* Windows being special */
-#    define VS_EXTERNAL_API(ret) VS_EXTERN_C __declspec(dllexport) ret VS_CC
+#define VS_EXTERNAL_API(ret) VS_EXTERN_C __declspec(dllexport) ret VS_CC
 #elif defined(__GNUC__) && __GNUC__ >= 4
-#    define VS_EXTERNAL_API(ret) VS_EXTERN_C __attribute__((visibility("default"))) ret VS_CC
+#define VS_EXTERNAL_API(ret)                                                   \
+    VS_EXTERN_C __attribute__((visibility("default"))) ret VS_CC
 #else
-#    define VS_EXTERNAL_API(ret) VS_EXTERN_C ret VS_CC
+#define VS_EXTERNAL_API(ret) VS_EXTERN_C ret VS_CC
 #endif
 
 #if !defined(VS_CORE_EXPORTS) && defined(_WIN32)
-#    define VS_API(ret) VS_EXTERN_C __declspec(dllimport) ret VS_CC
+#define VS_API(ret) VS_EXTERN_C __declspec(dllimport) ret VS_CC
 #else
-#    define VS_API(ret) VS_EXTERNAL_API(ret)
+#define VS_API(ret) VS_EXTERNAL_API(ret)
 #endif
 
 typedef struct VSFrameRef VSFrameRef;
@@ -73,20 +75,18 @@ typedef struct VSFrameContext VSFrameContext;
 
 typedef enum VSColorFamily {
     /* all planar formats */
-    cmGray   = 1000000,
-    cmRGB    = 2000000,
-    cmYUV    = 3000000,
-    cmYCoCg  = 4000000,
+    cmGray = 1000000,
+    cmRGB = 2000000,
+    cmYUV = 3000000,
+    cmYCoCg = 4000000,
     /* special for compatibility */
     cmCompat = 9000000
 } VSColorFamily;
 
-typedef enum VSSampleType {
-    stInteger = 0,
-    stFloat = 1
-} VSSampleType;
+typedef enum VSSampleType { stInteger = 0, stFloat = 1 } VSSampleType;
 
-/* The +10 is so people won't be using the constants interchangably "by accident" */
+/* The +10 is so people won't be using the constants interchangably "by
+ * accident" */
 typedef enum VSPresetFormat {
     pfNone = 0,
 
@@ -134,7 +134,8 @@ typedef enum VSPresetFormat {
     pfRGBH,
     pfRGBS,
 
-    /* special for compatibility, if you implement these in any filter I'll personally kill you */
+    /* special for compatibility, if you implement these in any filter I'll
+       personally kill you */
     /* I'll also change their ids around to break your stuff regularly */
     pfCompatBGR32 = cmCompat + 10,
     pfCompatYUY2
@@ -142,28 +143,35 @@ typedef enum VSPresetFormat {
 
 typedef enum VSFilterMode {
     fmParallel = 100, /* completely parallel execution */
-    fmParallelRequests = 200, /* for filters that are serial in nature but can request one or more frames they need in advance */
-    fmUnordered = 300, /* for filters that modify their internal state every request */
-    fmSerial = 400 /* for source filters and compatibility with other filtering architectures */
+    fmParallelRequests =
+        200, /* for filters that are serial in nature but can request one or
+                more frames they need in advance */
+    fmUnordered =
+        300, /* for filters that modify their internal state every request */
+    fmSerial = 400 /* for source filters and compatibility with other filtering
+                      architectures */
 } VSFilterMode;
 
 typedef struct VSFormat {
     char name[32];
     int id;
-    int colorFamily; /* see VSColorFamily */
-    int sampleType; /* see VSSampleType */
-    int bitsPerSample; /* number of significant bits */
-    int bytesPerSample; /* actual storage is always in a power of 2 and the smallest possible that can fit the number of bits used per sample */
-
-    int subSamplingW; /* log2 subsampling factor, applied to second and third plane */
+    int colorFamily;    /* see VSColorFamily */
+    int sampleType;     /* see VSSampleType */
+    int bitsPerSample;  /* number of significant bits */
+    int bytesPerSample; /* actual storage is always in a power of 2 and the
+                           smallest possible that can fit the number of bits
+                           used per sample */
+
+    int subSamplingW; /* log2 subsampling factor, applied to second and third
+                         plane */
     int subSamplingH;
 
     int numPlanes; /* implicit from colorFamily */
 } VSFormat;
 
 typedef enum VSNodeFlags {
-    nfNoCache    = 1,
-    nfIsCache    = 2,
+    nfNoCache = 1,
+    nfIsCache = 2,
     nfMakeLinear = 4 /* api 3.3 */
 } VSNodeFlags;
 
@@ -179,14 +187,14 @@ typedef enum VSPropTypes {
 
 typedef enum VSGetPropErrors {
     peUnset = 1,
-    peType  = 2,
+    peType = 2,
     peIndex = 4
 } VSGetPropErrors;
 
 typedef enum VSPropAppendMode {
     paReplace = 0,
-    paAppend  = 1,
-    paTouch   = 2
+    paAppend = 1,
+    paTouch = 2
 } VSPropAppendMode;
 
 typedef struct VSCoreInfo {
@@ -226,121 +234,206 @@ typedef enum VSMessageType {
 typedef const VSAPI *(VS_CC *VSGetVapourSynthAPI)(int version);
 
 /* plugin function and filter typedefs */
-typedef void (VS_CC *VSPublicFunction)(const VSMap *in, VSMap *out, void *userData, VSCore *core, const VSAPI *vsapi);
-typedef void (VS_CC *VSRegisterFunction)(const char *name, const char *args, VSPublicFunction argsFunc, void *functionData, VSPlugin *plugin);
-typedef void (VS_CC *VSConfigPlugin)(const char *identifier, const char *defaultNamespace, const char *name, int apiVersion, int readonly, VSPlugin *plugin);
-typedef void (VS_CC *VSInitPlugin)(VSConfigPlugin configFunc, VSRegisterFunction registerFunc, VSPlugin *plugin);
-typedef void (VS_CC *VSFreeFuncData)(void *userData);
-typedef void (VS_CC *VSFilterInit)(VSMap *in, VSMap *out, void **instanceData, VSNode *node, VSCore *core, const VSAPI *vsapi);
-typedef const VSFrameRef *(VS_CC *VSFilterGetFrame)(int n, int activationReason, void **instanceData, void **frameData, VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi);
-typedef void (VS_CC *VSFilterFree)(void *instanceData, VSCore *core, const VSAPI *vsapi);
+typedef void(VS_CC *VSPublicFunction)(const VSMap *in, VSMap *out,
+                                      void *userData, VSCore *core,
+                                      const VSAPI *vsapi);
+typedef void(VS_CC *VSRegisterFunction)(const char *name, const char *args,
+                                        VSPublicFunction argsFunc,
+                                        void *functionData, VSPlugin *plugin);
+typedef void(VS_CC *VSConfigPlugin)(const char *identifier,
+                                    const char *defaultNamespace,
+                                    const char *name, int apiVersion,
+                                    int readonly, VSPlugin *plugin);
+typedef void(VS_CC *VSInitPlugin)(VSConfigPlugin configFunc,
+                                  VSRegisterFunction registerFunc,
+                                  VSPlugin *plugin);
+typedef void(VS_CC *VSFreeFuncData)(void *userData);
+typedef void(VS_CC *VSFilterInit)(VSMap *in, VSMap *out, void **instanceData,
+                                  VSNode *node, VSCore *core,
+                                  const VSAPI *vsapi);
+typedef const VSFrameRef *(VS_CC *VSFilterGetFrame)(
+    int n, int activationReason, void **instanceData, void **frameData,
+    VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi);
+typedef void(VS_CC *VSFilterFree)(void *instanceData, VSCore *core,
+                                  const VSAPI *vsapi);
 
 /* other */
-typedef void (VS_CC *VSFrameDoneCallback)(void *userData, const VSFrameRef *f, int n, VSNodeRef *, const char *errorMsg);
-typedef void (VS_CC *VSMessageHandler)(int msgType, const char *msg, void *userData);
-typedef void (VS_CC *VSMessageHandlerFree)(void *userData);
+typedef void(VS_CC *VSFrameDoneCallback)(void *userData, const VSFrameRef *f,
+                                         int n, VSNodeRef *,
+                                         const char *errorMsg);
+typedef void(VS_CC *VSMessageHandler)(int msgType, const char *msg,
+                                      void *userData);
+typedef void(VS_CC *VSMessageHandlerFree)(void *userData);
 
 struct VSAPI {
     VSCore *(VS_CC *createCore)(int threads) VS_NOEXCEPT;
-    void (VS_CC *freeCore)(VSCore *core) VS_NOEXCEPT;
-    const VSCoreInfo *(VS_CC *getCoreInfo)(VSCore *core) VS_NOEXCEPT; /* deprecated as of api 3.6, use getCoreInfo2 instead */
+    void(VS_CC *freeCore)(VSCore *core) VS_NOEXCEPT;
+    const VSCoreInfo *(VS_CC *getCoreInfo)(VSCore *core)
+        VS_NOEXCEPT; /* deprecated as of api 3.6, use getCoreInfo2 instead */
 
     const VSFrameRef *(VS_CC *cloneFrameRef)(const VSFrameRef *f) VS_NOEXCEPT;
     VSNodeRef *(VS_CC *cloneNodeRef)(VSNodeRef *node) VS_NOEXCEPT;
     VSFuncRef *(VS_CC *cloneFuncRef)(VSFuncRef *f) VS_NOEXCEPT;
 
-    void (VS_CC *freeFrame)(const VSFrameRef *f) VS_NOEXCEPT;
-    void (VS_CC *freeNode)(VSNodeRef *node) VS_NOEXCEPT;
-    void (VS_CC *freeFunc)(VSFuncRef *f) VS_NOEXCEPT;
-
-    VSFrameRef *(VS_CC *newVideoFrame)(const VSFormat *format, int width, int height, const VSFrameRef *propSrc, VSCore *core) VS_NOEXCEPT;
-    VSFrameRef *(VS_CC *copyFrame)(const VSFrameRef *f, VSCore *core) VS_NOEXCEPT;
-    void (VS_CC *copyFrameProps)(const VSFrameRef *src, VSFrameRef *dst, VSCore *core) VS_NOEXCEPT;
-
-    void (VS_CC *registerFunction)(const char *name, const char *args, VSPublicFunction argsFunc, void *functionData, VSPlugin *plugin) VS_NOEXCEPT;
-    VSPlugin *(VS_CC *getPluginById)(const char *identifier, VSCore *core) VS_NOEXCEPT;
+    void(VS_CC *freeFrame)(const VSFrameRef *f) VS_NOEXCEPT;
+    void(VS_CC *freeNode)(VSNodeRef *node) VS_NOEXCEPT;
+    void(VS_CC *freeFunc)(VSFuncRef *f) VS_NOEXCEPT;
+
+    VSFrameRef *(VS_CC *newVideoFrame)(const VSFormat *format, int width,
+                                       int height, const VSFrameRef *propSrc,
+                                       VSCore *core) VS_NOEXCEPT;
+    VSFrameRef *(VS_CC *copyFrame)(const VSFrameRef *f,
+                                   VSCore *core) VS_NOEXCEPT;
+    void(VS_CC *copyFrameProps)(const VSFrameRef *src, VSFrameRef *dst,
+                                VSCore *core) VS_NOEXCEPT;
+
+    void(VS_CC *registerFunction)(const char *name, const char *args,
+                                  VSPublicFunction argsFunc, void *functionData,
+                                  VSPlugin *plugin) VS_NOEXCEPT;
+    VSPlugin *(VS_CC *getPluginById)(const char *identifier,
+                                     VSCore *core) VS_NOEXCEPT;
     VSPlugin *(VS_CC *getPluginByNs)(const char *ns, VSCore *core) VS_NOEXCEPT;
     VSMap *(VS_CC *getPlugins)(VSCore *core) VS_NOEXCEPT;
     VSMap *(VS_CC *getFunctions)(VSPlugin *plugin) VS_NOEXCEPT;
-    void (VS_CC *createFilter)(const VSMap *in, VSMap *out, const char *name, VSFilterInit init, VSFilterGetFrame getFrame, VSFilterFree free, int filterMode, int flags, void *instanceData, VSCore *core) VS_NOEXCEPT;
-    void (VS_CC *setError)(VSMap *map, const char *errorMessage) VS_NOEXCEPT; /* use to signal errors outside filter getframe functions */
-    const char *(VS_CC *getError)(const VSMap *map) VS_NOEXCEPT; /* use to query errors, returns 0 if no error */
-    void (VS_CC *setFilterError)(const char *errorMessage, VSFrameContext *frameCtx) VS_NOEXCEPT; /* use to signal errors in the filter getframe function */
-    VSMap *(VS_CC *invoke)(VSPlugin *plugin, const char *name, const VSMap *args) VS_NOEXCEPT;
+    void(VS_CC *createFilter)(const VSMap *in, VSMap *out, const char *name,
+                              VSFilterInit init, VSFilterGetFrame getFrame,
+                              VSFilterFree free, int filterMode, int flags,
+                              void *instanceData, VSCore *core) VS_NOEXCEPT;
+    void(VS_CC *setError)(VSMap *map, const char *errorMessage)
+        VS_NOEXCEPT; /* use to signal errors outside filter getframe functions
+                      */
+    const char *(VS_CC *getError)(const VSMap *map)
+        VS_NOEXCEPT; /* use to query errors, returns 0 if no error */
+    void(VS_CC *setFilterError)(const char *errorMessage,
+                                VSFrameContext *frameCtx)
+        VS_NOEXCEPT; /* use to signal errors in the filter getframe function */
+    VSMap *(VS_CC *invoke)(VSPlugin *plugin, const char *name,
+                           const VSMap *args) VS_NOEXCEPT;
 
     const VSFormat *(VS_CC *getFormatPreset)(int id, VSCore *core) VS_NOEXCEPT;
-    const VSFormat *(VS_CC *registerFormat)(int colorFamily, int sampleType, int bitsPerSample, int subSamplingW, int subSamplingH, VSCore *core) VS_NOEXCEPT;
-
-    const VSFrameRef *(VS_CC *getFrame)(int n, VSNodeRef *node, char *errorMsg, int bufSize) VS_NOEXCEPT; /* do never use inside a filter's getframe function, for external applications using the core as a library or for requesting frames in a filter constructor */
-    void (VS_CC *getFrameAsync)(int n, VSNodeRef *node, VSFrameDoneCallback callback, void *userData) VS_NOEXCEPT; /* do never use inside a filter's getframe function, for external applications using the core as a library or for requesting frames in a filter constructor */
-    const VSFrameRef *(VS_CC *getFrameFilter)(int n, VSNodeRef *node, VSFrameContext *frameCtx) VS_NOEXCEPT; /* only use inside a filter's getframe function */
-    void (VS_CC *requestFrameFilter)(int n, VSNodeRef *node, VSFrameContext *frameCtx) VS_NOEXCEPT; /* only use inside a filter's getframe function */
-    void (VS_CC *queryCompletedFrame)(VSNodeRef **node, int *n, VSFrameContext *frameCtx) VS_NOEXCEPT; /* only use inside a filter's getframe function */
-    void (VS_CC *releaseFrameEarly)(VSNodeRef *node, int n, VSFrameContext *frameCtx) VS_NOEXCEPT; /* only use inside a filter's getframe function */
-
-    int (VS_CC *getStride)(const VSFrameRef *f, int plane) VS_NOEXCEPT;
-    const uint8_t *(VS_CC *getReadPtr)(const VSFrameRef *f, int plane) VS_NOEXCEPT;
+    const VSFormat *(VS_CC *registerFormat)(int colorFamily, int sampleType,
+                                            int bitsPerSample, int subSamplingW,
+                                            int subSamplingH,
+                                            VSCore *core) VS_NOEXCEPT;
+
+    const VSFrameRef *(VS_CC *getFrame)(int n, VSNodeRef *node, char *errorMsg,
+                                        int bufSize)
+        VS_NOEXCEPT; /* do never use inside a filter's getframe function, for
+                        external applications using the core as a library or for
+                        requesting frames in a filter constructor */
+    void(VS_CC *getFrameAsync)(int n, VSNodeRef *node,
+                               VSFrameDoneCallback callback, void *userData)
+        VS_NOEXCEPT; /* do never use inside a filter's getframe function, for
+                        external applications using the core as a library or for
+                        requesting frames in a filter constructor */
+    const VSFrameRef *(VS_CC *getFrameFilter)(int n, VSNodeRef *node,
+                                              VSFrameContext *frameCtx)
+        VS_NOEXCEPT; /* only use inside a filter's getframe function */
+    void(VS_CC *requestFrameFilter)(int n, VSNodeRef *node,
+                                    VSFrameContext *frameCtx)
+        VS_NOEXCEPT; /* only use inside a filter's getframe function */
+    void(VS_CC *queryCompletedFrame)(VSNodeRef **node, int *n,
+                                     VSFrameContext *frameCtx)
+        VS_NOEXCEPT; /* only use inside a filter's getframe function */
+    void(VS_CC *releaseFrameEarly)(VSNodeRef *node, int n,
+                                   VSFrameContext *frameCtx)
+        VS_NOEXCEPT; /* only use inside a filter's getframe function */
+
+    int(VS_CC *getStride)(const VSFrameRef *f, int plane) VS_NOEXCEPT;
+    const uint8_t *(VS_CC *getReadPtr)(const VSFrameRef *f,
+                                       int plane) VS_NOEXCEPT;
     uint8_t *(VS_CC *getWritePtr)(VSFrameRef *f, int plane) VS_NOEXCEPT;
 
-    VSFuncRef *(VS_CC *createFunc)(VSPublicFunction func, void *userData, VSFreeFuncData free, VSCore *core, const VSAPI *vsapi) VS_NOEXCEPT;
-    void (VS_CC *callFunc)(VSFuncRef *func, const VSMap *in, VSMap *out, VSCore *core, const VSAPI *vsapi) VS_NOEXCEPT; /* core and vsapi arguments are completely ignored, they only remain to preserve ABI */
+    VSFuncRef *(VS_CC *createFunc)(VSPublicFunction func, void *userData,
+                                   VSFreeFuncData free, VSCore *core,
+                                   const VSAPI *vsapi) VS_NOEXCEPT;
+    void(VS_CC *callFunc)(VSFuncRef *func, const VSMap *in, VSMap *out,
+                          VSCore *core, const VSAPI *vsapi)
+        VS_NOEXCEPT; /* core and vsapi arguments are completely ignored, they
+                        only remain to preserve ABI */
 
     /* property access functions */
     VSMap *(VS_CC *createMap)(void) VS_NOEXCEPT;
-    void (VS_CC *freeMap)(VSMap *map) VS_NOEXCEPT;
-    void (VS_CC *clearMap)(VSMap *map) VS_NOEXCEPT;
+    void(VS_CC *freeMap)(VSMap *map) VS_NOEXCEPT;
+    void(VS_CC *clearMap)(VSMap *map) VS_NOEXCEPT;
 
     const VSVideoInfo *(VS_CC *getVideoInfo)(VSNodeRef *node) VS_NOEXCEPT;
-    void (VS_CC *setVideoInfo)(const VSVideoInfo *vi, int numOutputs, VSNode *node) VS_NOEXCEPT;
+    void(VS_CC *setVideoInfo)(const VSVideoInfo *vi, int numOutputs,
+                              VSNode *node) VS_NOEXCEPT;
     const VSFormat *(VS_CC *getFrameFormat)(const VSFrameRef *f) VS_NOEXCEPT;
-    int (VS_CC *getFrameWidth)(const VSFrameRef *f, int plane) VS_NOEXCEPT;
-    int (VS_CC *getFrameHeight)(const VSFrameRef *f, int plane) VS_NOEXCEPT;
+    int(VS_CC *getFrameWidth)(const VSFrameRef *f, int plane) VS_NOEXCEPT;
+    int(VS_CC *getFrameHeight)(const VSFrameRef *f, int plane) VS_NOEXCEPT;
     const VSMap *(VS_CC *getFramePropsRO)(const VSFrameRef *f) VS_NOEXCEPT;
     VSMap *(VS_CC *getFramePropsRW)(VSFrameRef *f) VS_NOEXCEPT;
 
-    int (VS_CC *propNumKeys)(const VSMap *map) VS_NOEXCEPT;
+    int(VS_CC *propNumKeys)(const VSMap *map) VS_NOEXCEPT;
     const char *(VS_CC *propGetKey)(const VSMap *map, int index) VS_NOEXCEPT;
-    int (VS_CC *propNumElements)(const VSMap *map, const char *key) VS_NOEXCEPT;
-    char (VS_CC *propGetType)(const VSMap *map, const char *key) VS_NOEXCEPT;
-
-    int64_t(VS_CC *propGetInt)(const VSMap *map, const char *key, int index, int *error) VS_NOEXCEPT;
-    double(VS_CC *propGetFloat)(const VSMap *map, const char *key, int index, int *error) VS_NOEXCEPT;
-    const char *(VS_CC *propGetData)(const VSMap *map, const char *key, int index, int *error) VS_NOEXCEPT;
-    int (VS_CC *propGetDataSize)(const VSMap *map, const char *key, int index, int *error) VS_NOEXCEPT;
-    VSNodeRef *(VS_CC *propGetNode)(const VSMap *map, const char *key, int index, int *error) VS_NOEXCEPT;
-    const VSFrameRef *(VS_CC *propGetFrame)(const VSMap *map, const char *key, int index, int *error) VS_NOEXCEPT;
-    VSFuncRef *(VS_CC *propGetFunc)(const VSMap *map, const char *key, int index, int *error) VS_NOEXCEPT;
-
-    int (VS_CC *propDeleteKey)(VSMap *map, const char *key) VS_NOEXCEPT;
-    int (VS_CC *propSetInt)(VSMap *map, const char *key, int64_t i, int append) VS_NOEXCEPT;
-    int (VS_CC *propSetFloat)(VSMap *map, const char *key, double d, int append) VS_NOEXCEPT;
-    int (VS_CC *propSetData)(VSMap *map, const char *key, const char *data, int size, int append) VS_NOEXCEPT;
-    int (VS_CC *propSetNode)(VSMap *map, const char *key, VSNodeRef *node, int append) VS_NOEXCEPT;
-    int (VS_CC *propSetFrame)(VSMap *map, const char *key, const VSFrameRef *f, int append) VS_NOEXCEPT;
-    int (VS_CC *propSetFunc)(VSMap *map, const char *key, VSFuncRef *func, int append) VS_NOEXCEPT;
-
-    int64_t (VS_CC *setMaxCacheSize)(int64_t bytes, VSCore *core) VS_NOEXCEPT;
-    int (VS_CC *getOutputIndex)(VSFrameContext *frameCtx) VS_NOEXCEPT;
-    VSFrameRef *(VS_CC *newVideoFrame2)(const VSFormat *format, int width, int height, const VSFrameRef **planeSrc, const int *planes, const VSFrameRef *propSrc, VSCore *core) VS_NOEXCEPT;
-    void (VS_CC *setMessageHandler)(VSMessageHandler handler, void *userData) VS_NOEXCEPT; /* deprecated as of api 3.6, use addMessageHandler and removeMessageHandler instead */
-    int (VS_CC *setThreadCount)(int threads, VSCore *core) VS_NOEXCEPT;
+    int(VS_CC *propNumElements)(const VSMap *map, const char *key) VS_NOEXCEPT;
+    char(VS_CC *propGetType)(const VSMap *map, const char *key) VS_NOEXCEPT;
+
+    int64_t(VS_CC *propGetInt)(const VSMap *map, const char *key, int index,
+                               int *error) VS_NOEXCEPT;
+    double(VS_CC *propGetFloat)(const VSMap *map, const char *key, int index,
+                                int *error) VS_NOEXCEPT;
+    const char *(VS_CC *propGetData)(const VSMap *map, const char *key,
+                                     int index, int *error) VS_NOEXCEPT;
+    int(VS_CC *propGetDataSize)(const VSMap *map, const char *key, int index,
+                                int *error) VS_NOEXCEPT;
+    VSNodeRef *(VS_CC *propGetNode)(const VSMap *map, const char *key,
+                                    int index, int *error) VS_NOEXCEPT;
+    const VSFrameRef *(VS_CC *propGetFrame)(const VSMap *map, const char *key,
+                                            int index, int *error) VS_NOEXCEPT;
+    VSFuncRef *(VS_CC *propGetFunc)(const VSMap *map, const char *key,
+                                    int index, int *error) VS_NOEXCEPT;
+
+    int(VS_CC *propDeleteKey)(VSMap *map, const char *key) VS_NOEXCEPT;
+    int(VS_CC *propSetInt)(VSMap *map, const char *key, int64_t i,
+                           int append) VS_NOEXCEPT;
+    int(VS_CC *propSetFloat)(VSMap *map, const char *key, double d,
+                             int append) VS_NOEXCEPT;
+    int(VS_CC *propSetData)(VSMap *map, const char *key, const char *data,
+                            int size, int append) VS_NOEXCEPT;
+    int(VS_CC *propSetNode)(VSMap *map, const char *key, VSNodeRef *node,
+                            int append) VS_NOEXCEPT;
+    int(VS_CC *propSetFrame)(VSMap *map, const char *key, const VSFrameRef *f,
+                             int append) VS_NOEXCEPT;
+    int(VS_CC *propSetFunc)(VSMap *map, const char *key, VSFuncRef *func,
+                            int append) VS_NOEXCEPT;
+
+    int64_t(VS_CC *setMaxCacheSize)(int64_t bytes, VSCore *core) VS_NOEXCEPT;
+    int(VS_CC *getOutputIndex)(VSFrameContext *frameCtx) VS_NOEXCEPT;
+    VSFrameRef *(VS_CC *newVideoFrame2)(const VSFormat *format, int width,
+                                        int height, const VSFrameRef **planeSrc,
+                                        const int *planes,
+                                        const VSFrameRef *propSrc,
+                                        VSCore *core) VS_NOEXCEPT;
+    void(VS_CC *setMessageHandler)(VSMessageHandler handler, void *userData)
+        VS_NOEXCEPT; /* deprecated as of api 3.6, use addMessageHandler and
+                        removeMessageHandler instead */
+    int(VS_CC *setThreadCount)(int threads, VSCore *core) VS_NOEXCEPT;
 
     const char *(VS_CC *getPluginPath)(const VSPlugin *plugin) VS_NOEXCEPT;
 
     /* api 3.1 */
-    const int64_t *(VS_CC *propGetIntArray)(const VSMap *map, const char *key, int *error) VS_NOEXCEPT;
-    const double *(VS_CC *propGetFloatArray)(const VSMap *map, const char *key, int *error) VS_NOEXCEPT;
+    const int64_t *(VS_CC *propGetIntArray)(const VSMap *map, const char *key,
+                                            int *error) VS_NOEXCEPT;
+    const double *(VS_CC *propGetFloatArray)(const VSMap *map, const char *key,
+                                             int *error) VS_NOEXCEPT;
 
-    int (VS_CC *propSetIntArray)(VSMap *map, const char *key, const int64_t *i, int size) VS_NOEXCEPT;
-    int (VS_CC *propSetFloatArray)(VSMap *map, const char *key, const double *d, int size) VS_NOEXCEPT;
+    int(VS_CC *propSetIntArray)(VSMap *map, const char *key, const int64_t *i,
+                                int size) VS_NOEXCEPT;
+    int(VS_CC *propSetFloatArray)(VSMap *map, const char *key, const double *d,
+                                  int size) VS_NOEXCEPT;
 
     /* api 3.4 */
-    void (VS_CC *logMessage)(int msgType, const char *msg) VS_NOEXCEPT;
+    void(VS_CC *logMessage)(int msgType, const char *msg) VS_NOEXCEPT;
 
     /* api 3.6 */
-    int (VS_CC *addMessageHandler)(VSMessageHandler handler, VSMessageHandlerFree free, void *userData) VS_NOEXCEPT;
-    int (VS_CC *removeMessageHandler)(int id) VS_NOEXCEPT;
-    void (VS_CC *getCoreInfo2)(VSCore *core, VSCoreInfo *info) VS_NOEXCEPT;
+    int(VS_CC *addMessageHandler)(VSMessageHandler handler,
+                                  VSMessageHandlerFree free,
+                                  void *userData) VS_NOEXCEPT;
+    int(VS_CC *removeMessageHandler)(int id) VS_NOEXCEPT;
+    void(VS_CC *getCoreInfo2)(VSCore *core, VSCoreInfo *info) VS_NOEXCEPT;
 };
 
 VS_API(const VSAPI *) getVapourSynthAPI(int version) VS_NOEXCEPT;
diff --git a/colorconverter.h b/colorconverter.h
index c9ba9e6..aa81028 100644
--- a/colorconverter.h
+++ b/colorconverter.h
@@ -2,299 +2,282 @@
 #ifndef COLOR_COMPONENTS_CONVERSION_H_V_C_MOHAN
 #define COLOR_COMPONENTS_CONVERSION_H_V_C_MOHAN
 //-------------------------------------------------------
-void colorToBGRtoYUV(int color, unsigned char * bgr, unsigned char * yuv);
-void colorToBGR(int color, unsigned char * bgr);
-void BGRtoYUV(const unsigned char * bgr, unsigned char * yuv);
-void YUVtoBGR(const unsigned char * yuv, unsigned char * bgr);
-
-
+void colorToBGRtoYUV(int color, unsigned char *bgr, unsigned char *yuv);
+void colorToBGR(int color, unsigned char *bgr);
+void BGRtoYUV(const unsigned char *bgr, unsigned char *yuv);
+void YUVtoBGR(const unsigned char *yuv, unsigned char *bgr);
 
 int clampRGBcolor(int i);
-void YUVfromBGR(unsigned char *YUV, const unsigned char* BGR);
-void BGRfromYUV(unsigned char* BGR, unsigned char* YUV);
-void BGR8YUV(uint8_t* yuv, const uint8_t* bgr);
-void BGR16YUV(uint16_t* yuv, const uint16_t* bgr, int nbits);
-void BGR32YUV(float* yuv, const float* bgr);
-void YUV8BGR(uint8_t* bgr, const uint8_t* yuv);
-void YUV16BGR(uint16_t* bgr, const uint16_t* yuv, int nbits);
-void YUV32BGR(float* bgr, const float* yuv);
+void YUVfromBGR(unsigned char *YUV, const unsigned char *BGR);
+void BGRfromYUV(unsigned char *BGR, unsigned char *YUV);
+void BGR8YUV(uint8_t *yuv, const uint8_t *bgr);
+void BGR16YUV(uint16_t *yuv, const uint16_t *bgr, int nbits);
+void BGR32YUV(float *yuv, const float *bgr);
+void YUV8BGR(uint8_t *bgr, const uint8_t *yuv);
+void YUV16BGR(uint16_t *bgr, const uint16_t *yuv, int nbits);
+void YUV32BGR(float *bgr, const float *yuv);
 int clampYUVcolor(int i);
-// Always conversion to or from 8 bit bgr color 
-void YUV_BGR8(uint8_t* bgr, uint8_t* yuv, int nbits);
-void YUV_BGR8(uint8_t* bgr, uint16_t* yuv, int nbits);
-void YUV_BGR8(uint8_t* bgr, float* yuv, int nbits);
-
-void BGR8_YUV(uint8_t* yuv, uint8_t* bgr, int nbits);
-void BGR8_YUV(uint16_t* yuv, uint8_t* bgr, int nbits);
-void BGR8_YUV(float* yuv, uint8_t* bgr, int nbits);
-template <typename finc>
-finc Clamp(float val, finc min, finc max);
-
-float clamp_color(float val, float min, float max)
-{
-	return val < min ? min : val > max ? max : val;
+// Always conversion to or from 8 bit bgr color
+void YUV_BGR8(uint8_t *bgr, uint8_t *yuv, int nbits);
+void YUV_BGR8(uint8_t *bgr, uint16_t *yuv, int nbits);
+void YUV_BGR8(uint8_t *bgr, float *yuv, int nbits);
+
+void BGR8_YUV(uint8_t *yuv, uint8_t *bgr, int nbits);
+void BGR8_YUV(uint16_t *yuv, uint8_t *bgr, int nbits);
+void BGR8_YUV(float *yuv, uint8_t *bgr, int nbits);
+template <typename finc> finc Clamp(float val, finc min, finc max);
+
+float clamp_color(float val, float min, float max) {
+    return val < min ? min : val > max ? max : val;
 }
 
-template <typename finc>
-finc Clamp(float val, finc min, finc max)
-{
-	return (finc)(val < min ? min : val > max ? max : val);
+template <typename finc> finc Clamp(float val, finc min, finc max) {
+    return (finc) (val < min ? min : val > max ? max : val);
 }
 //-------------------------------------------------------
-void RGBandYUVfromColor(int col, unsigned char* BGR, unsigned char* YUV)
-{
-	colorToBGR(col, BGR);
-	YUVfromBGR(YUV, BGR);
+void RGBandYUVfromColor(int col, unsigned char *BGR, unsigned char *YUV) {
+    colorToBGR(col, BGR);
+    YUVfromBGR(YUV, BGR);
 }
 
 //-------------------------------------------------------------------------
-void colorToBGRtoYUV(int color, unsigned char * bgr, unsigned char * yuv)
-{
-	// separate components
-	colorToBGR(color, bgr);
+void colorToBGRtoYUV(int color, unsigned char *bgr, unsigned char *yuv) {
+    // separate components
+    colorToBGR(color, bgr);
 
-	BGRtoYUV(bgr, yuv);
+    BGRtoYUV(bgr, yuv);
 }
 //------------------------------------------------------------------------
-void colorToBGR(int color, unsigned char * bgr)
-{
-	// color specified as RGB
-	// separate components
-	//blue 
-	bgr[0] = color & 255;
-	//green
-	bgr[1] = (color & 0xff00) >> 8;
-	//red
-	bgr[2] = (color & 0xff0000) >> 16;
-
+void colorToBGR(int color, unsigned char *bgr) {
+    // color specified as RGB
+    // separate components
+    // blue
+    bgr[0] = color & 255;
+    // green
+    bgr[1] = (color & 0xff00) >> 8;
+    // red
+    bgr[2] = (color & 0xff0000) >> 16;
 }
-void BGRtoYUV(const unsigned char * bgr, unsigned char * yuv)
-{
-	// convert bgr values  to Y u v
-	yuv[0] = (unsigned char)clampYUVcolor((int)(0.299 * bgr[2] + 0.587 * bgr[1] + 0.114 * bgr[0]));
-	yuv[1] = (unsigned char )clampYUVcolor((int)(- 0.169 * bgr[2] - 0.332 * bgr[1] + 0.5 * bgr[0] + 128));
-	yuv[2] = (unsigned char)clampYUVcolor((int)(0.5 * bgr[2] - bgr[1] * 0.419 - bgr[0] * 0.0813 + 128));
+void BGRtoYUV(const unsigned char *bgr, unsigned char *yuv) {
+    // convert bgr values  to Y u v
+    yuv[0] = (unsigned char) clampYUVcolor(
+        (int) (0.299 * bgr[2] + 0.587 * bgr[1] + 0.114 * bgr[0]));
+    yuv[1] = (unsigned char) clampYUVcolor(
+        (int) (-0.169 * bgr[2] - 0.332 * bgr[1] + 0.5 * bgr[0] + 128));
+    yuv[2] = (unsigned char) clampYUVcolor(
+        (int) (0.5 * bgr[2] - bgr[1] * 0.419 - bgr[0] * 0.0813 + 128));
 }
 //------------------------------------------------------------------------------
 
-void YUVtoBGR(const unsigned char * yuv, unsigned char * bgr)
-{
-	//bgr[2] = yuv[0] + 1.4075*(yuv[2] - 128);
-	//bgr[1] = yuv[0] - 0.3455*(yuv[1] - 128) - 0.7169*(yuv[2] - 128);
-	//bgr[0] = yuv[0] + 1.779*(yuv[1] - 128);
-
-	//bgr[2] = yuv[0] + 1.14075*(yuv[2] - 128);
-//bgr[1] = yuv[0] - 0.3955*(yuv[1] - 128) - 0.581*(yuv[2] - 128);
-//bgr[0] = yuv[0] + 2.033*(yuv[1] - 128);
+void YUVtoBGR(const unsigned char *yuv, unsigned char *bgr) {
+    // bgr[2] = yuv[0] + 1.4075*(yuv[2] - 128);
+    // bgr[1] = yuv[0] - 0.3455*(yuv[1] - 128) - 0.7169*(yuv[2] - 128);
+    // bgr[0] = yuv[0] + 1.779*(yuv[1] - 128);
 
-int c = yuv[0] - 16, d = yuv[1] - 128, e = yuv[2] - 128;;
+    // bgr[2] = yuv[0] + 1.14075*(yuv[2] - 128);
+    // bgr[1] = yuv[0] - 0.3955*(yuv[1] - 128) - 0.581*(yuv[2] - 128);
+    // bgr[0] = yuv[0] + 2.033*(yuv[1] - 128);
 
-bgr[2] = (unsigned char)clampYUVcolor((298 * c + 409 * e + 128) >> 8);
-bgr[1] = (unsigned char)clampYUVcolor((298 * c - 100 * d - 208 * e + 128) >> 8);
-bgr[0] = (unsigned char)clampYUVcolor((298 * c + 516 * d + 128) >> 8);
+    int c = yuv[0] - 16, d = yuv[1] - 128, e = yuv[2] - 128;
+    ;
 
+    bgr[2] = (unsigned char) clampYUVcolor((298 * c + 409 * e + 128) >> 8);
+    bgr[1] =
+        (unsigned char) clampYUVcolor((298 * c - 100 * d - 208 * e + 128) >> 8);
+    bgr[0] = (unsigned char) clampYUVcolor((298 * c + 516 * d + 128) >> 8);
 }
 
-int clampYUVcolor(int i)
-{
-	return (i < 16 ? 16 : i > 235 ? 235 : i);
-}
+int clampYUVcolor(int i) { return (i < 16 ? 16 : i > 235 ? 235 : i); }
 
-int clampRGBcolor(int i)
-{
-	return (i < 0 ? 0 : i > 255 ? 255 : i);
-}
-int clamp(int i)
-{
-	return (i < 0 ? 0 : i > 255 ? 255 : i);
-}
+int clampRGBcolor(int i) { return (i < 0 ? 0 : i > 255 ? 255 : i); }
+int clamp(int i) { return (i < 0 ? 0 : i > 255 ? 255 : i); }
 //-----------------------------------------------------------------------------------------------
 // changed from GITHUB
-void YUVfromBGR(unsigned char* YUV, const unsigned char* BGR)
-{
-	YUV[0] = (unsigned char)clampYUVcolor((int)(0.257 * BGR[2] + 0.504 * BGR[1] + 0.098 * BGR[0] + 16));
-	YUV[1] = (unsigned char)clampYUVcolor((int)(-0.148 * BGR[2] - 0.291 * BGR[1] + 0.439 * BGR[0] + 128));
-	YUV[2] = (unsigned char)clampYUVcolor((int)(0.439 * BGR[2] - 0.368 * BGR[1] - 0.071 * BGR[0] + 128));
+void YUVfromBGR(unsigned char *YUV, const unsigned char *BGR) {
+    YUV[0] = (unsigned char) clampYUVcolor(
+        (int) (0.257 * BGR[2] + 0.504 * BGR[1] + 0.098 * BGR[0] + 16));
+    YUV[1] = (unsigned char) clampYUVcolor(
+        (int) (-0.148 * BGR[2] - 0.291 * BGR[1] + 0.439 * BGR[0] + 128));
+    YUV[2] = (unsigned char) clampYUVcolor(
+        (int) (0.439 * BGR[2] - 0.368 * BGR[1] - 0.071 * BGR[0] + 128));
 }
-void BGRfromYUV(unsigned char* BGR, unsigned char* YUV)
-{
-	double Y = YUV[0] - 16;
-	double U = YUV[1] - 128;
-	double V = YUV[2] - 128;
-	BGR[2] = (unsigned char)(1.164 * Y + 1.596 * V);
-	BGR[1] = (unsigned char)(1.164 * Y - 0.392 * U - 0.813 * V);
-	BGR[0] = (unsigned char)(1.164 * Y + 2.017 * U);
+void BGRfromYUV(unsigned char *BGR, unsigned char *YUV) {
+    double Y = YUV[0] - 16;
+    double U = YUV[1] - 128;
+    double V = YUV[2] - 128;
+    BGR[2] = (unsigned char) (1.164 * Y + 1.596 * V);
+    BGR[1] = (unsigned char) (1.164 * Y - 0.392 * U - 0.813 * V);
+    BGR[0] = (unsigned char) (1.164 * Y + 2.017 * U);
 }
 //------------------------------------------------------------
 /*
  * RGB -> YUV conversion macros
  */
-#define RGB2Y(r, g, b) (uint8_t)(((66 * (r) + 129 * (g) +  25 * (b) + 128) / 256) +  16)
-#define RGB2U(r, g, b) (uint8_t)(((-38 * (r) - 74 * (g) + 112 * (b) + 128) / 256) + 128)
-#define RGB2V(r, g, b) (uint8_t)(((112 * (r) - 94 * (g) -  18 * (b) + 128) / 256) + 128)
+#define RGB2Y(r, g, b)                                                         \
+    (uint8_t)(((66 * (r) + 129 * (g) + 25 * (b) + 128) / 256) + 16)
+#define RGB2U(r, g, b)                                                         \
+    (uint8_t)(((-38 * (r) - 74 * (g) + 112 * (b) + 128) / 256) + 128)
+#define RGB2V(r, g, b)                                                         \
+    (uint8_t)(((112 * (r) - 94 * (g) - 18 * (b) + 128) / 256) + 128)
 /*
-YUV[0] = (unsigned char)clampYUVcolor((0.257 * BGR[2] + 0.504 * BGR[1] + 0.098 * BGR[0] + 16));
-YUV[1] = (unsigned char)clampYUVcolor((-0.148 * BGR[2] - 0.291 * BGR[1] + 0.439 * BGR[0] + 128));
-YUV[2] = (unsigned char)clampYUVcolor((0.439 * BGR[2] - 0.368 * BGR[1] - 0.071 * BGR[0] + 128));
+YUV[0] = (unsigned char)clampYUVcolor((0.257 * BGR[2] + 0.504 * BGR[1] + 0.098 *
+BGR[0] + 16)); YUV[1] = (unsigned char)clampYUVcolor((-0.148 * BGR[2] - 0.291 *
+BGR[1] + 0.439 * BGR[0] + 128)); YUV[2] = (unsigned char)clampYUVcolor((0.439 *
+BGR[2] - 0.368 * BGR[1] - 0.071 * BGR[0] + 128));
 */
-#define ADD16Y(n) ( 1 << (n - 4))
-#define ADD16UV(n) (1 << (n  - 1))
-
-#define BGR16Y(yuv,bgr, n) yuv[0] = (uint16_t)(0.257 * bgr[2] + 0.504 * bgr[1] + 0.098 * bgr[0] + ADD16Y(n))
-#define BGR16U(yuv,bgr, n) yuv[1] = (uint16_t)(-0.148 * bgr[2] - 0.291 * bgr[1] + 0.439 * bgr[0] + ADD16UV(n))
-#define BGR16V(yuv,bgr, n) yuv[2] = (uint16_t)(0.439 * bgr[2] - 0.368 * bgr[1] - 0.071 * bgr[0] + ADD16UV(n))
-
-#define BGR32Y(yuv, bgr) yuv[0] = (float)(0.257 * bgr[2] + 0.504 * bgr[1] + 0.098 * bgr[0] )
-#define BGR32U(yuv, bgr) yuv[1] = (float)(-0.148 * bgr[2] - 0.291 * bgr[1] + 0.439 * bgr[0] )
-#define BGR32V(yuv, bgr) yuv[2] = (float)(0.439 * bgr[2] - 0.368 * bgr[1] - 0.071 * bgr[0] )
- /*
-  *   macros that take the original Y, U, and V values
-  */
-#define YUV2R(y, u, v) clamp((298 * ((y)-16) + 409 * ((v)-128) + 128) / 256)
-#define YUV2G(y, u, v) clamp((298 * ((y)-16) - 100 * ((u)-128) - 208 * ((v)-128) + 128) / 256)
-#define YUV2B(y, u, v) clamp((298 * ((y)-16) + 516 * ((u)-128) + 128) / 256)
-  //----------------------------------------------------------------------------------------
-  /*
-   * YUV -> RGB conversion macros
-   */
-   /* "Optimized" macros that take specialy prepared Y, U, and V values:
-	*  C = Y - 16
-	*  D = U - 128
-	*  E = V - 128
-	*/
+#define ADD16Y(n) (1 << (n - 4))
+#define ADD16UV(n) (1 << (n - 1))
+
+#define BGR16Y(yuv, bgr, n)                                                    \
+    yuv[0] = (uint16_t) (0.257 * bgr[2] + 0.504 * bgr[1] + 0.098 * bgr[0] +    \
+                         ADD16Y(n))
+#define BGR16U(yuv, bgr, n)                                                    \
+    yuv[1] = (uint16_t) (-0.148 * bgr[2] - 0.291 * bgr[1] + 0.439 * bgr[0] +   \
+                         ADD16UV(n))
+#define BGR16V(yuv, bgr, n)                                                    \
+    yuv[2] = (uint16_t) (0.439 * bgr[2] - 0.368 * bgr[1] - 0.071 * bgr[0] +    \
+                         ADD16UV(n))
+
+#define BGR32Y(yuv, bgr)                                                       \
+    yuv[0] = (float) (0.257 * bgr[2] + 0.504 * bgr[1] + 0.098 * bgr[0])
+#define BGR32U(yuv, bgr)                                                       \
+    yuv[1] = (float) (-0.148 * bgr[2] - 0.291 * bgr[1] + 0.439 * bgr[0])
+#define BGR32V(yuv, bgr)                                                       \
+    yuv[2] = (float) (0.439 * bgr[2] - 0.368 * bgr[1] - 0.071 * bgr[0])
+/*
+ *   macros that take the original Y, U, and V values
+ */
+#define YUV2R(y, u, v) clamp((298 * ((y) - 16) + 409 * ((v) - 128) + 128) / 256)
+#define YUV2G(y, u, v)                                                         \
+    clamp((298 * ((y) - 16) - 100 * ((u) - 128) - 208 * ((v) - 128) + 128) /   \
+          256)
+#define YUV2B(y, u, v) clamp((298 * ((y) - 16) + 516 * ((u) - 128) + 128) / 256)
+//----------------------------------------------------------------------------------------
+/*
+ * YUV -> RGB conversion macros
+ */
+/* "Optimized" macros that take specialy prepared Y, U, and V values:
+ *  C = Y - 16
+ *  D = U - 128
+ *  E = V - 128
+ */
 #define YUV2RO(C, D, E) clamp((298 * (C) + 409 * (E) + 128) >> 8)
 #define YUV2GO(C, D, E) clamp((298 * (C) - 100 * (D) - 208 * (E) + 128) >> 8)
 #define YUV2BO(C, D, E) clamp((298 * (C) + 516 * (D) + 128) >> 8)
-	/*
-	 *   macros that take RGB and give individual components
-	 */
+/*
+ *   macros that take RGB and give individual components
+ */
 #define RGB2R(RGB) RGB & 0xFF
 #define RGB2G(RGB) (RGB >> 8) & 0xFF
 #define RGB2B(RGB) (RGB >> 16) & 0xFF
 #define RGB2BGR(RGB) (RGB2B << 16) | (RGB2G << 8) | (RGB2R)
 
-	 //-------------------------------------------------------------
-void RGB8ToYUV(uint8_t r, uint8_t g, uint8_t b, uint8_t* y, uint8_t* u, uint8_t* v)
-{
-	*y = RGB2Y((int)r, (int)g, (int)b);
-	*u = RGB2U((int)r, (int)g, (int)b);
-	*v = RGB2V((int)r, (int)g, (int)b);
+//-------------------------------------------------------------
+void RGB8ToYUV(uint8_t r, uint8_t g, uint8_t b, uint8_t *y, uint8_t *u,
+               uint8_t *v) {
+    *y = RGB2Y((int) r, (int) g, (int) b);
+    *u = RGB2U((int) r, (int) g, (int) b);
+    *v = RGB2V((int) r, (int) g, (int) b);
 }
 
-void BGR2YUV(uint8_t* bgr, uint8_t* yuv)
-{
-	RGB8ToYUV(bgr[2], bgr[1], bgr[0], yuv, yuv + 1, yuv + 2);
+void BGR2YUV(uint8_t *bgr, uint8_t *yuv) {
+    RGB8ToYUV(bgr[2], bgr[1], bgr[0], yuv, yuv + 1, yuv + 2);
 }
-void YUV2BGR(uint8_t* yuv, uint8_t* bgr)
-{
-	bgr[0] = YUV2B(yuv[0], yuv[1], yuv[2]);
-	bgr[1] = YUV2G(yuv[0], yuv[1], yuv[2]);
-	bgr[2] = YUV2R(yuv[0], yuv[1], yuv[2]);
+void YUV2BGR(uint8_t *yuv, uint8_t *bgr) {
+    bgr[0] = YUV2B(yuv[0], yuv[1], yuv[2]);
+    bgr[1] = YUV2G(yuv[0], yuv[1], yuv[2]);
+    bgr[2] = YUV2R(yuv[0], yuv[1], yuv[2]);
 }
 
-void BGR8YUV(uint8_t* yuv, uint8_t* bgr)
-{
-	*yuv	=	 RGB2Y((int)(bgr[2]), (int)(bgr[1]), (int)(bgr[0]) );
-	*(yuv + 1) = RGB2U((int)(bgr[2]), (int)(bgr[1]), (int)(bgr[0]) );
-	*(yuv + 2) = RGB2V((int)(bgr[2]), (int)(bgr[1]), (int)(bgr[0]) );
-
+void BGR8YUV(uint8_t *yuv, uint8_t *bgr) {
+    *yuv = RGB2Y((int) (bgr[2]), (int) (bgr[1]), (int) (bgr[0]));
+    *(yuv + 1) = RGB2U((int) (bgr[2]), (int) (bgr[1]), (int) (bgr[0]));
+    *(yuv + 2) = RGB2V((int) (bgr[2]), (int) (bgr[1]), (int) (bgr[0]));
 }
 
-void BGR16YUV(uint16_t* yuv, const uint16_t* bgr, int nbits)
-{
-	BGR16Y(yuv,bgr, nbits);
-	BGR16U(yuv,bgr, nbits);
-	BGR16V(yuv,bgr, nbits);
-
+void BGR16YUV(uint16_t *yuv, const uint16_t *bgr, int nbits) {
+    BGR16Y(yuv, bgr, nbits);
+    BGR16U(yuv, bgr, nbits);
+    BGR16V(yuv, bgr, nbits);
 }
 
-void BGR32YUV(float* yuv, const float* bgr)
-{
-	BGR32Y(yuv, bgr);
-	BGR32U(yuv, bgr);
-	BGR32V(yuv, bgr);
-
+void BGR32YUV(float *yuv, const float *bgr) {
+    BGR32Y(yuv, bgr);
+    BGR32U(yuv, bgr);
+    BGR32V(yuv, bgr);
 }
-void YUV8BGR(uint8_t* bgr, const uint8_t* yuv)
-{
-	/*float y = yuv[0] - 16;
-	//float u = yuv[1] - 128;
-	//float v = yuv[2] - 128;
-	//bgr[2] = (unsigned char)(1.164 * y + 1.596 * v);
-	//bgr[1] = (unsigned char)(1.164 * y - 0.392 * u - 0.813 * v);
-	//bgr[0] = (unsigned char)(1.164 * y + 2.017 * u);*/
-	uint8_t y = yuv[0] - 16;
-	uint8_t u = yuv[1] - 128;
-	uint8_t v = yuv[2] - 128;
-	bgr[0] = YUV2BO(y, u, v);
-	bgr[1] = YUV2GO(y, u, v);
-	bgr[2] = YUV2RO(y, u, v);
+void YUV8BGR(uint8_t *bgr, const uint8_t *yuv) {
+    /*float y = yuv[0] - 16;
+    //float u = yuv[1] - 128;
+    //float v = yuv[2] - 128;
+    //bgr[2] = (unsigned char)(1.164 * y + 1.596 * v);
+    //bgr[1] = (unsigned char)(1.164 * y - 0.392 * u - 0.813 * v);
+    //bgr[0] = (unsigned char)(1.164 * y + 2.017 * u);*/
+    uint8_t y = yuv[0] - 16;
+    uint8_t u = yuv[1] - 128;
+    uint8_t v = yuv[2] - 128;
+    bgr[0] = YUV2BO(y, u, v);
+    bgr[1] = YUV2GO(y, u, v);
+    bgr[2] = YUV2RO(y, u, v);
 }
 
-void YUV16BGR(uint16_t* bgr, const uint16_t* yuv, int nbits)
-{
-	float y = (float)(yuv[0] - (16 << (nbits - 8)) );
-	float u = (float)(yuv[1] - (128 << (nbits - 8)));
-	float v = (float)(yuv[2] - (128 << (nbits - 8)));
-	bgr[2] = (uint16_t)(1.164 * y + 1.596 * v);
-	bgr[1] = (uint16_t)(1.164 * y - 0.392 * u - 0.813 * v);
-	bgr[0] = (uint16_t)(1.164 * y + 2.017 * u);
+void YUV16BGR(uint16_t *bgr, const uint16_t *yuv, int nbits) {
+    float y = (float) (yuv[0] - (16 << (nbits - 8)));
+    float u = (float) (yuv[1] - (128 << (nbits - 8)));
+    float v = (float) (yuv[2] - (128 << (nbits - 8)));
+    bgr[2] = (uint16_t) (1.164 * y + 1.596 * v);
+    bgr[1] = (uint16_t) (1.164 * y - 0.392 * u - 0.813 * v);
+    bgr[0] = (uint16_t) (1.164 * y + 2.017 * u);
 }
 
-
-void YUV32BGR (float * bgr, const float* yuv)
-{
-	float y = yuv[0];
-	float u = yuv[1];
-	float v = yuv[2];
-	bgr[2] = (float)(1.164 * y + 1.596 * v);
-	bgr[1] = (float)(1.164 * y - 0.392 * u - 0.813 * v);
-	bgr[0] = (float)(1.164 * y + 2.017 * u);
+void YUV32BGR(float *bgr, const float *yuv) {
+    float y = yuv[0];
+    float u = yuv[1];
+    float v = yuv[2];
+    bgr[2] = (float) (1.164 * y + 1.596 * v);
+    bgr[1] = (float) (1.164 * y - 0.392 * u - 0.813 * v);
+    bgr[0] = (float) (1.164 * y + 2.017 * u);
 }
 
-
-void YUV_BGR8(uint8_t* bgr, uint8_t* yuv, int nbits)
-{
-	bgr[2] = YUV2R(yuv[0], yuv[1], yuv[2]);
-	bgr[1] = YUV2G(yuv[0], yuv[1], yuv[2]);
-	bgr[0] = YUV2B(yuv[0], yuv[1], yuv[2]);
+void YUV_BGR8(uint8_t *bgr, uint8_t *yuv, int nbits) {
+    bgr[2] = YUV2R(yuv[0], yuv[1], yuv[2]);
+    bgr[1] = YUV2G(yuv[0], yuv[1], yuv[2]);
+    bgr[0] = YUV2B(yuv[0], yuv[1], yuv[2]);
 }
 
-void YUV_BGR8(uint8_t* bgr, uint16_t* yuv, int nbits)
-{
-	bgr[2] = YUV2R(yuv[0] >> (nbits - 8), yuv[1] >> (nbits - 8), yuv[2] >> (nbits - 8));
-	bgr[1] = YUV2G(yuv[0] >> (nbits - 8), yuv[1] >> (nbits - 8), yuv[2] >> (nbits - 8));
-	bgr[0] = YUV2B(yuv[0] >> (nbits - 8), yuv[1] >> (nbits - 8), yuv[2] >> (nbits - 8));
+void YUV_BGR8(uint8_t *bgr, uint16_t *yuv, int nbits) {
+    bgr[2] = YUV2R(yuv[0] >> (nbits - 8), yuv[1] >> (nbits - 8),
+                   yuv[2] >> (nbits - 8));
+    bgr[1] = YUV2G(yuv[0] >> (nbits - 8), yuv[1] >> (nbits - 8),
+                   yuv[2] >> (nbits - 8));
+    bgr[0] = YUV2B(yuv[0] >> (nbits - 8), yuv[1] >> (nbits - 8),
+                   yuv[2] >> (nbits - 8));
 }
 
-void YUV_BGR8(uint8_t* bgr, float* yuv, int nbits)
-{
-	uint8_t y = (uint8_t)(yuv[0] * 255);
-	uint8_t u = (uint8_t)(yuv[1] * 255 + 127);
-	uint8_t v = (uint8_t)(yuv[2] * 255 + 127);
+void YUV_BGR8(uint8_t *bgr, float *yuv, int nbits) {
+    uint8_t y = (uint8_t) (yuv[0] * 255);
+    uint8_t u = (uint8_t) (yuv[1] * 255 + 127);
+    uint8_t v = (uint8_t) (yuv[2] * 255 + 127);
 
-	bgr[2] = (uint8_t)YUV2R(y, u, v);
-	bgr[1] = (uint8_t)YUV2G(y, u, v);
-	bgr[0] = (uint8_t)YUV2B(y, u, v);
+    bgr[2] = (uint8_t) YUV2R(y, u, v);
+    bgr[1] = (uint8_t) YUV2G(y, u, v);
+    bgr[0] = (uint8_t) YUV2B(y, u, v);
 }
-void BGR8_YUV(uint8_t* yuv, uint8_t* bgr, int nbits)
-{
-	yuv[0] = RGB2Y(bgr[2], bgr[1], bgr[0]);
-	yuv[1] = RGB2U(bgr[2], bgr[1], bgr[0]);
-	yuv[2] = RGB2V(bgr[2], bgr[1], bgr[0]);
+void BGR8_YUV(uint8_t *yuv, uint8_t *bgr, int nbits) {
+    yuv[0] = RGB2Y(bgr[2], bgr[1], bgr[0]);
+    yuv[1] = RGB2U(bgr[2], bgr[1], bgr[0]);
+    yuv[2] = RGB2V(bgr[2], bgr[1], bgr[0]);
 }
 
-void BGR8_YUV(uint16_t* yuv, uint8_t* bgr, int nbits)
-{
-	yuv[0] = (RGB2Y(bgr[2], bgr[1], bgr[0])) << (nbits - 8);
-	yuv[1] = (RGB2U(bgr[2], bgr[1], bgr[0])) << (nbits - 8);
-	yuv[2] = (RGB2V(bgr[2], bgr[1], bgr[0])) << (nbits - 8);
+void BGR8_YUV(uint16_t *yuv, uint8_t *bgr, int nbits) {
+    yuv[0] = (RGB2Y(bgr[2], bgr[1], bgr[0])) << (nbits - 8);
+    yuv[1] = (RGB2U(bgr[2], bgr[1], bgr[0])) << (nbits - 8);
+    yuv[2] = (RGB2V(bgr[2], bgr[1], bgr[0])) << (nbits - 8);
 }
 
-void BGR8_YUV(float* yuv, uint8_t* bgr, int nbits)
-{
-	yuv[0] = (RGB2Y(bgr[2], bgr[1], bgr[0])) / 255.0f;
-	yuv[1] = (RGB2U(bgr[2], bgr[1], bgr[0])) / 255.0f - 0.5f;
-	yuv[2] = (RGB2V(bgr[2], bgr[1], bgr[0])) / 255.0f - 0.5f;
+void BGR8_YUV(float *yuv, uint8_t *bgr, int nbits) {
+    yuv[0] = (RGB2Y(bgr[2], bgr[1], bgr[0])) / 255.0f;
+    yuv[1] = (RGB2U(bgr[2], bgr[1], bgr[0])) / 255.0f - 0.5f;
+    yuv[2] = (RGB2V(bgr[2], bgr[1], bgr[0])) / 255.0f - 0.5f;
 }
 #endif
diff --git a/fftLateBindingClassParams.cpp b/fftLateBindingClassParams.cpp
index 566f63a..8de68da 100644
--- a/fftLateBindingClassParams.cpp
+++ b/fftLateBindingClassParams.cpp
@@ -1,7 +1,16 @@
+// late binding of fft dll
 
+// Error Only for Windows
+// HINSTANCE hinstLib;
 
-// late binding of fft dll
+// Fix
+#ifdef _WIN32
+#include <windows.h>
 HINSTANCE hinstLib;
+#else
+#include <dlfcn.h>
+void *hinstLib; // dlopen-Handle (Ã¤quivalent zu HINSTANCE)
+#endif
 
 fftwf_malloc_proc fftwf_malloc;
 fftwf_free_proc fftwf_free;
@@ -12,12 +21,11 @@ fftwf_plan_dft_c2r_1d_proc fftwf_plan_dft_c2r_1d;
 fftwf_plan_dft_r2c_2d_proc fftwf_plan_dft_r2c_2d;
 fftwf_plan_dft_c2r_2d_proc fftwf_plan_dft_c2r_2d;
 
-
 fftwf_destroy_plan_proc fftwf_destroy_plan;
 fftwf_execute_proc fftwf_execute;
 
-fftwf_execute_dft_r2c_proc  fftwf_execute_dft_r2c;
-fftwf_execute_dft_c2r_proc  fftwf_execute_dft_c2r;
+fftwf_execute_dft_r2c_proc fftwf_execute_dft_r2c;
+fftwf_execute_dft_c2r_proc fftwf_execute_dft_c2r;
 
 fftwf_init_threads_proc fftwf_init_threads;
 fftwf_plan_with_nthreads_proc fftwf_plan_with_nthreads;
diff --git a/fftwlite.h b/fftwlite.h
index ea94412..f3f65c7 100644
--- a/fftwlite.h
+++ b/fftwlite.h
@@ -1,35 +1,50 @@
 // Lite version of fftw header on base of fftw3.h
 // some needed fftwf typedefs added  for delayed loading
 // (by Fizick) modified by vcmohan
-// 
+//
 #ifndef __FFTWLITE_H__
 #define __FFTWLITE_H__
 
 typedef float fftwf_complex[2];
-typedef struct fftwf_plan_s  *fftwf_plan;
-typedef fftwf_complex* (*fftwf_malloc_proc)(size_t n); 
-
-typedef void (*fftwf_free_proc) (void *ptr);
-		// 1d transforms
-typedef fftwf_plan (*fftwf_plan_dft_r2c_1d_proc)( int wbest, float *in, fftwf_complex *out, int flags);
-typedef fftwf_plan (*fftwf_plan_dft_c2r_1d_proc)( int wbest, fftwf_complex *out, float *in, int flags);
-		// 2d transforms
-typedef fftwf_plan (*fftwf_plan_dft_r2c_2d_proc) (int winy, int winx, float *in, fftwf_complex *out, int flags);
-typedef fftwf_plan (*fftwf_plan_dft_c2r_2d_proc) (int winy, int winx, fftwf_complex *out, float *in, int flags);
-
-typedef fftwf_plan (*fftwf_plan_dft_2d_proc)(int winy, int winx, fftwf_complex *in, fftwf_complex *out, int inv, int flags);
-
-//typedef fftwf_plan (*fftwf_plan_many_dft_r2c_proc) (int rank, const int *n,	int howmany,  float *in, const int *inembed, int istride, int idist, fftwf_complex *out, const int *onembed, int ostride, int odist, unsigned flags);
-//typedef fftwf_plan (*fftwf_plan_many_dft_c2r_proc) (int rank, const int *n,	int howmany,  fftwf_complex *out, const int *inembed, int istride, int idist, float *in, const int *onembed, int ostride, int odist, unsigned flags);
-
-typedef void (*fftwf_destroy_plan_proc) (fftwf_plan);
-
-typedef void (*fftwf_execute_dft_r2c_proc) (fftwf_plan, float *realdata, fftwf_complex *fftsrc);
-typedef void (*fftwf_execute_dft_c2r_proc) (fftwf_plan, fftwf_complex *fftsrc, float *realdata);
-typedef void (*fftwf_execute_proc) (fftwf_plan);
-
-typedef int  (*fftwf_init_threads_proc) (void);
-typedef void (*fftwf_plan_with_nthreads_proc) (int nthreads);
+typedef struct fftwf_plan_s *fftwf_plan;
+typedef fftwf_complex *(*fftwf_malloc_proc)(size_t n);
+
+typedef void (*fftwf_free_proc)(void *ptr);
+// 1d transforms
+typedef fftwf_plan (*fftwf_plan_dft_r2c_1d_proc)(int wbest, float *in,
+                                                 fftwf_complex *out, int flags);
+typedef fftwf_plan (*fftwf_plan_dft_c2r_1d_proc)(int wbest, fftwf_complex *out,
+                                                 float *in, int flags);
+// 2d transforms
+typedef fftwf_plan (*fftwf_plan_dft_r2c_2d_proc)(int winy, int winx, float *in,
+                                                 fftwf_complex *out, int flags);
+typedef fftwf_plan (*fftwf_plan_dft_c2r_2d_proc)(int winy, int winx,
+                                                 fftwf_complex *out, float *in,
+                                                 int flags);
+
+typedef fftwf_plan (*fftwf_plan_dft_2d_proc)(int winy, int winx,
+                                             fftwf_complex *in,
+                                             fftwf_complex *out, int inv,
+                                             int flags);
+
+// typedef fftwf_plan (*fftwf_plan_many_dft_r2c_proc) (int rank, const int *n,
+// int howmany,  float *in, const int *inembed, int istride, int idist,
+// fftwf_complex *out, const int *onembed, int ostride, int odist, unsigned
+// flags); typedef fftwf_plan (*fftwf_plan_many_dft_c2r_proc) (int rank, const
+// int *n,	int howmany,  fftwf_complex *out, const int *inembed, int istride,
+// int idist, float *in, const int *onembed, int ostride, int odist, unsigned
+// flags);
+
+typedef void (*fftwf_destroy_plan_proc)(fftwf_plan);
+
+typedef void (*fftwf_execute_dft_r2c_proc)(fftwf_plan, float *realdata,
+                                           fftwf_complex *fftsrc);
+typedef void (*fftwf_execute_dft_c2r_proc)(fftwf_plan, fftwf_complex *fftsrc,
+                                           float *realdata);
+typedef void (*fftwf_execute_proc)(fftwf_plan);
+
+typedef int (*fftwf_init_threads_proc)(void);
+typedef void (*fftwf_plan_with_nthreads_proc)(int nthreads);
 typedef void (*fftwf_cleanup_threads_proc)(void);
 typedef void (*fftwf_cleanup_proc)(void);
 
diff --git a/fillPlaneWithVal.h b/fillPlaneWithVal.h
index ac43db2..45baffc 100644
--- a/fillPlaneWithVal.h
+++ b/fillPlaneWithVal.h
@@ -2,19 +2,16 @@
 #define FILLPLANEWITHVALUE_V_C_MOHAN
 
 template <typename finc>
-void fillPlaneWithVal(finc * dp, int pitch, int wd, int ht, finc val);
+void fillPlaneWithVal(finc *dp, int pitch, int wd, int ht, finc val);
 
 template <typename finc>
-void fillPlaneWithVal(finc * dp, int pitch, int wd, int ht, finc val)
-{
-	for (int h = 0; h < ht; h++)
-	{
-		for (int w = 0; w < wd; w++)
-		{
-			dp[w] = val;
-		}
+void fillPlaneWithVal(finc *dp, int pitch, int wd, int ht, finc val) {
+    for(int h = 0; h < ht; h++) {
+        for(int w = 0; w < wd; w++) {
+            dp[w] = val;
+        }
 
-		dp += pitch;
-	}
+        dp += pitch;
+    }
 }
 #endif
\ No newline at end of file
diff --git a/interpolationMethods.h b/interpolationMethods.h
index 8cb02e4..35df528 100644
--- a/interpolationMethods.h
+++ b/interpolationMethods.h
@@ -1,276 +1,261 @@
 #ifndef INTERPOLATION_STUFF_V_C_MOHAN
 #define INTERPOLATION_STUFF_V_C_MOHAN
 //-------------------------------------------------------------------
-void LanczosCoeff(float* cbuf, const int span, const int quantp);
+void LanczosCoeff(float *cbuf, const int span, const int quantp);
 
 float sinc(float f);
 
-void CubicIntCoeff(float* cbuf, const int quantiles);
+void CubicIntCoeff(float *cbuf, const int quantiles);
 
-void LinearIntCoeff(float* cbuf, const int quantiles);
+void LinearIntCoeff(float *cbuf, const int quantiles);
 
-float* setInterpolationScheme(const int q, const int quantiles, int *dspan);
+float *setInterpolationScheme(const int q, const int quantiles, int *dspan);
 //..................................................................
 // IIT Manipur scheme
 template <typename finc>
-finc bestOfNine(const finc* sp, const int pitch, const int kb,
-						const int  x, const int  y, const int index);
-int bestOfNineIndex(const int qx, const int qy, const int quantiles);// quantiles must be a multiple of 4
+finc bestOfNine(const finc *sp, const int pitch, const int kb, const int x,
+                const int y, const int index);
+int bestOfNineIndex(const int qx, const int qy,
+                    const int quantiles); // quantiles must be a multiple of 4
 int bestOfNineIndex(const float remx, const float remy);
 //-------------------------------------------------------------------
 template <typename finc>
-float LaQuantile(const finc* point, const int spitch,
-	const int span, const int qx, const int qy, const float* lbuf);
+float LaQuantile(const finc *point, const int spitch, const int span,
+                 const int qx, const int qy, const float *lbuf);
 template <typename finc>
-float LaQuantile(const finc* point, const int spitch, const int kb,
-	const int span, const int qx, const int qy, const float* lbuf);
+float LaQuantile(const finc *point, const int spitch, const int kb,
+                 const int span, const int qx, const int qy, const float *lbuf);
 template <typename finc>
-bool needNotInterpolate(const finc* sp, const int pitch, const int kb);
+bool needNotInterpolate(const finc *sp, const int pitch, const int kb);
 
 template <typename finc>
-float alongLineInterpolate(const finc* point, const int step,
-	const int span, const int quant, const float *iBuf);
+float alongLineInterpolate(const finc *point, const int step, const int span,
+                           const int quant, const float *iBuf);
 
-//restricts values to min and max
+// restricts values to min and max
 //---------------------------------------------------------------------------------
-template <typename  finc>
-finc clamp(float val, const finc min, const finc max);
+template <typename finc> finc clamp(float val, const finc min, const finc max);
 //--------------------------------------------------------------------------------
-template <typename  finc>
-finc clamp(float val, const finc min, const finc max)
-{
+template <typename finc> finc clamp(float val, const finc min, const finc max) {
 
-	return (finc)(val < min ? min : val > max ? max : val);
+    return (finc) (val < min ? min : val > max ? max : val);
 }
 //----------------------------------------------------------------------------------
-float fclamp(float val, const float min, const float max)
-{
-	return val < min ? min : val > max ? max : val;
+float fclamp(float val, const float min, const float max) {
+    return val < min ? min : val > max ? max : val;
 }
 
 //-------------------------------------------------------------------
 template <typename finc>
-finc bestOfNine(const finc* sp, const int pitch,const int kb,
-	const int  x, const int  y, const int index )
-{
-	finc val;
-	switch (index)
-	{
-	case 0: val = *(sp + y * pitch + x * kb);
-		break;
-	case 1: val = (*(sp + y * pitch + x * kb)
-		+ *(sp + y * pitch + kb *(x + 1))) / 2;
-		break;
-	case 2: val = *(sp + y * pitch + (x + 1) * kb);
-		break;
-	case 3: val = *(sp + y * pitch + x * kb);
-		break;
-	case 4: val = (*(sp + y * pitch + x * kb)
-		+ *(sp + y * pitch + (x + 1) * kb)
-		+ *(sp + y * pitch + x * kb)
-		+ *(sp + (y + 1) * pitch + x * kb)) / 4;
-		break;
-	case 5: val = (*(sp + y * pitch + (x + 1) * kb)
-		+ *(sp + (y + 1) * pitch + (x + 1) * kb)) / 2;
-		break;
-	case 6: val = *(sp + (y + 1) * pitch + x * kb);
-		break;
-	case 7: val = (*(sp + (y + 1) * pitch + x * kb)
-		+ *(sp + (y + 1) * pitch + (x + 1) * kb)) / 2;
-		break;
-	case 8: val = *(sp + (y + 1) * pitch + (x + 1) * kb);
-		break;
-	}
-	return val;
+finc bestOfNine(const finc *sp, const int pitch, const int kb, const int x,
+                const int y, const int index) {
+    finc val;
+    switch(index) {
+    case 0: val = *(sp + y * pitch + x * kb); break;
+    case 1:
+        val =
+            (*(sp + y * pitch + x * kb) + *(sp + y * pitch + kb * (x + 1))) / 2;
+        break;
+    case 2: val = *(sp + y * pitch + (x + 1) * kb); break;
+    case 3: val = *(sp + y * pitch + x * kb); break;
+    case 4:
+        val = (*(sp + y * pitch + x * kb) + *(sp + y * pitch + (x + 1) * kb) +
+               *(sp + y * pitch + x * kb) + *(sp + (y + 1) * pitch + x * kb)) /
+              4;
+        break;
+    case 5:
+        val = (*(sp + y * pitch + (x + 1) * kb) +
+               *(sp + (y + 1) * pitch + (x + 1) * kb)) /
+              2;
+        break;
+    case 6: val = *(sp + (y + 1) * pitch + x * kb); break;
+    case 7:
+        val = (*(sp + (y + 1) * pitch + x * kb) +
+               *(sp + (y + 1) * pitch + (x + 1) * kb)) /
+              2;
+        break;
+    case 8: val = *(sp + (y + 1) * pitch + (x + 1) * kb); break;
+    }
+    return val;
 }
-int bestOfNineIndex(const int qx, const int qy, int quantiles)
-{
-	// quantiles must be a multiple of 4
-	int index = 0;
-
-	if (qx < quantiles / 4)
-		index = 0;
-	else if (qx < (3 * quantiles) / 4)
-		index = 1;
-	else
-		index = 2;
-	if (qy < quantiles / 4)
-		index += 0;
-	if (qy < (3 * quantiles) / 4)
-		index += 3;
-	else
-		index += 6;
-	return index;
+int bestOfNineIndex(const int qx, const int qy, int quantiles) {
+    // quantiles must be a multiple of 4
+    int index = 0;
+
+    if(qx < quantiles / 4)
+        index = 0;
+    else if(qx < (3 * quantiles) / 4)
+        index = 1;
+    else
+        index = 2;
+    if(qy < quantiles / 4)
+        index += 0;
+    if(qy < (3 * quantiles) / 4)
+        index += 3;
+    else
+        index += 6;
+    return index;
 }
-int bestOfNineIndex(const float remx, const float remy)
-{
-	int index;
-	if (remx < 0.25f)
-		index = 0;
-	else if (remx < 0.75f)
-		index = 1;
-	else
-		index = 2;
-	if (remy < 0.25f)
-		index += 0;
-	if (remy < 0.75f)
-		index += 3;
-	else
-		index += 6;
-	return index;
+int bestOfNineIndex(const float remx, const float remy) {
+    int index;
+    if(remx < 0.25f)
+        index = 0;
+    else if(remx < 0.75f)
+        index = 1;
+    else
+        index = 2;
+    if(remy < 0.25f)
+        index += 0;
+    if(remy < 0.75f)
+        index += 3;
+    else
+        index += 6;
+    return index;
 }
 
 template <typename finc>
-// this is general. can be used for any span 2 4 6 and bytes per pixel planar formats
-
-float LaQuantile(const finc* point, const int spitch,
-	const int span, const int qx, const int qy, const float* lbuf)
-{
-	// nb = bit depth of sample. for float 0
-	// span = 6 for 6 x 6 point interpolation
-	// point is input nearest (floor) pixel
-	// qx, qy are quantiles in x and y 
-	// lbuf has precomputed coefficients for quantiles
-	if (span == 0)
-	{
-		// near point
-		return (float)(*point);
-	}
-	float xy[6];	//
-	point += (-span / 2 + 1) * spitch;
-	const float* lbufr = lbuf + span * qx;
-
-	for (int h = 0; h < span; h++)
-	{
-		xy[h] = 0;
-
-		for (int w = 0; w < span; w++)
-		{
-			xy[h] += point[w - span / 2 + 1] * lbufr[w];
-		}
-
-		point += spitch;
-	}
-
-	float sum = 0;
-	lbufr = lbuf + span * qy;
-
-	for (int h = 0; h < span; h++)
-	{
-		sum += xy[h] * lbufr[h];
-	}
-
-	return sum;
-
+// this is general. can be used for any span 2 4 6 and bytes per pixel planar
+// formats
+
+float LaQuantile(const finc *point, const int spitch, const int span,
+                 const int qx, const int qy, const float *lbuf) {
+    // nb = bit depth of sample. for float 0
+    // span = 6 for 6 x 6 point interpolation
+    // point is input nearest (floor) pixel
+    // qx, qy are quantiles in x and y
+    // lbuf has precomputed coefficients for quantiles
+    if(span == 0) {
+        // near point
+        return (float) (*point);
+    }
+    float xy[6]; //
+    point += (-span / 2 + 1) * spitch;
+    const float *lbufr = lbuf + span * qx;
+
+    for(int h = 0; h < span; h++) {
+        xy[h] = 0;
+
+        for(int w = 0; w < span; w++) {
+            xy[h] += point[w - span / 2 + 1] * lbufr[w];
+        }
+
+        point += spitch;
+    }
+
+    float sum = 0;
+    lbufr = lbuf + span * qy;
+
+    for(int h = 0; h < span; h++) {
+        sum += xy[h] * lbufr[h];
+    }
+
+    return sum;
 }
-//-------------------------------------------------------------------------------------------------	
+//-------------------------------------------------------------------------------------------------
 template <typename finc>
-// this is general. can be used for any span 2 4 6 and bytes per pixel planar formats
+// this is general. can be used for any span 2 4 6 and bytes per pixel planar
+// formats
 
-float LaQuantile(const finc* point, const int spitch, const int kb,
-	const int span, const int qx, const int qy, const float* lbuf)
-{
-	// kb = dist between sample. 1 or -1
-	// span = 6 for 6 x 6 point interpolation
-	// point is input nearest (floor) pixel
-	// qx, qy are quantiles in x and y 
-	// lbuf has precomputed coefficients for quantiles
-	if (span == 0)
-	{
-		// near point
-		return (float)(*point);
-	}
-	float xy[6];	//
-	point += (-span / 2 + 1) * spitch;
-
-	const float* lbufr = lbuf + span * qx;
+float LaQuantile(const finc *point, const int spitch, const int kb,
+                 const int span, const int qx, const int qy,
+                 const float *lbuf) {
+    // kb = dist between sample. 1 or -1
+    // span = 6 for 6 x 6 point interpolation
+    // point is input nearest (floor) pixel
+    // qx, qy are quantiles in x and y
+    // lbuf has precomputed coefficients for quantiles
+    if(span == 0) {
+        // near point
+        return (float) (*point);
+    }
+    float xy[6]; //
+    point += (-span / 2 + 1) * spitch;
 
-	for (int h = 0; h < span; h++)
-	{
-		xy[h] = 0;
+    const float *lbufr = lbuf + span * qx;
 
-		for (int w = 0; w < span; w++)
-		{
-			xy[h] += point[(w - span / 2 + 1) * kb] * lbufr[w];
-		}
+    for(int h = 0; h < span; h++) {
+        xy[h] = 0;
 
-		point += spitch;
-	}
+        for(int w = 0; w < span; w++) {
+            xy[h] += point[(w - span / 2 + 1) * kb] * lbufr[w];
+        }
 
-	float sum = 0;
+        point += spitch;
+    }
 
-	lbufr = lbuf + span * qy;
+    float sum = 0;
 
-	for (int h = 0; h < span; h++)
-	{
-		sum += xy[h] * lbufr[h];
-	}
+    lbufr = lbuf + span * qy;
 
-	return sum;
+    for(int h = 0; h < span; h++) {
+        sum += xy[h] * lbufr[h];
+    }
 
+    return sum;
 }
 //-------------------------------------------------------------------------------
 template <typename finc>
-bool needNotInterpolate(const finc* sp, const int pitch, const int kb)
-{
-	return (*sp == *(sp + kb) && *sp == *(sp + pitch) && *sp == *(sp + pitch + kb));
+bool needNotInterpolate(const finc *sp, const int pitch, const int kb) {
+    return (*sp == *(sp + kb) && *sp == *(sp + pitch) &&
+            *sp == *(sp + pitch + kb));
 }
 //-------------------------------------------------
 template <typename finc>
-float alongLineInterpolate(const finc* point, const int step,
-	const int span, const int quant, const float* iBuf)
-{
-	float sum = 0.0;
-
-	for (int i = 0; i < span; i++)
-	{
-		sum += iBuf[span * quant + i] * point[(i + 1 - span / 2) * step];
-	}
-	return sum;
+float alongLineInterpolate(const finc *point, const int step, const int span,
+                           const int quant, const float *iBuf) {
+    float sum = 0.0;
+
+    for(int i = 0; i < span; i++) {
+        sum += iBuf[span * quant + i] * point[(i + 1 - span / 2) * step];
+    }
+    return sum;
 }
 //.....................................................................
-void LinearIntCoeff(float* cbuf, const int quantiles)
-{
-	float q = 0, qinc = 1.0f / quantiles;
+void LinearIntCoeff(float *cbuf, const int quantiles) {
+    float q = 0, qinc = 1.0f / quantiles;
 
-	for (int i = 0; i < 2 * quantiles; i += 2)
-	{
-		cbuf[i] = 1.0f - q;
-		cbuf[i + 1] = q;
+    for(int i = 0; i < 2 * quantiles; i += 2) {
+        cbuf[i] = 1.0f - q;
+        cbuf[i + 1] = q;
 
-		q += qinc;
-	}
+        q += qinc;
+    }
 }
 //------------------------------------------------
 
 /* For cubic interpolation generates coefficients for each quantile
  between 0.0 and 3.0
  cbuf should be 4 * quantiles per unit interval  * 3 plus 4
- given a quantile from a0,, multiply values at a0, a1, a2, a3 to get interpolated value
+ given a quantile from a0,, multiply values at a0, a1, a2, a3 to get
+ interpolated value
 */
 /*
 void CubicIntCoeff( int * cbuf, int quantiles,  int prec)
 {
-	float inc = 1.0 / quantiles;
+    float inc = 1.0 / quantiles;
 
-	float startx = 0;
+    float startx = 0;
 
-	for( int i = 0, i <= 3 * quantiles; i ++)
-	{
-		float x = startx;
-		float xsq = x * x;
-		float xcube = x * xsq;
+    for( int i = 0, i <= 3 * quantiles; i ++)
+    {
+        float x = startx;
+        float xsq = x * x;
+        float xcube = x * xsq;
 
-		cbuf[4 * i    ] = ( 1.0 - 29 * x /18 + 4 * xsq / 6 - xcube / 18) * prec;	// a0 multiplier
+        cbuf[4 * i    ] = ( 1.0 - 29 * x /18 + 4 * xsq / 6 - xcube / 18) * prec;
+// a0 multiplier
 
-		cbuf[4 * i + 1] = ( 42 * x / 18 - 9 * xsq / 6 + xcube / 6) * prec;			// a1 multiplier
+        cbuf[4 * i + 1] = ( 42 * x / 18 - 9 * xsq / 6 + xcube / 6) * prec;
+// a1 multiplier
 
-		cbuf[4 * i + 2] = ( - 15* x / 18 + xsq - xcube / 6) * prec;					// a2 multiplier
+        cbuf[4 * i + 2] = ( - 15* x / 18 + xsq - xcube / 6) * prec;
+// a2 multiplier
 
-		cbuf[4 * i + 3] = ( x / 9 - xsq / 6 + xcube / 18) * prec;					// a3 multiplier
+        cbuf[4 * i + 3] = ( x / 9 - xsq / 6 + xcube / 18) * prec;
+// a3 multiplier
 
-		startx += inc;
-	}
+        startx += inc;
+    }
 }
 
 */
@@ -281,14 +266,14 @@ void CubicIntCoeff( int * cbuf, int quantiles,  int prec)
  at   x-1, x0, x1, x2
  for any given x ( between x0 and x1)
  f( p0,p1,p2,p3,x) = ( -1/2 p0 + 3/2 p1 - 3/2 p2 + 1/2 p3) * x*x*x
-					+ ( p0 -5/2 p1 + 2 p2 - 1/2 p3) * x *x
-					+(- 1/2 p0 + 1/2 p2) * x
-					+ p1
+                    + ( p0 -5/2 p1 + 2 p2 - 1/2 p3) * x *x
+                    +(- 1/2 p0 + 1/2 p2) * x
+                    + p1
 Or as coefficients at discrete quantiles of x
-	( -x*x*x + 2*x*x - x) /2  for p0
-	(3*x*x* - 5*x*x + 2) /2 for p1
-	(-3*x*x*x + 4*x*x + x) /2 for p2
-	( x*X*X - x*x) / 2 for p3
+    ( -x*x*x + 2*x*x - x) /2  for p0
+    (3*x*x* - 5*x*x + 2) /2 for p1
+    (-3*x*x*x + 4*x*x + x) /2 for p2
+    ( x*X*X - x*x) / 2 for p3
 
 cbuf should be 4 * quantiles  plus 4
  given a quant from x0,, multiply values at
@@ -299,140 +284,129 @@ cbuf should be 4 * quantiles  plus 4
  final result is left shifted same amount
 */
 
-void CubicIntCoeff(float* cbuf, const int quantiles)
-{
+void CubicIntCoeff(float *cbuf, const int quantiles) {
 
+    float inc = 1.0f / quantiles;
 
-	float inc = 1.0f / quantiles;
+    float x = 0;
 
-	float x = 0;
+    for(int i = 0; i <= 4 * quantiles; i += 4) {
 
-	for (int i = 0; i <= 4 * quantiles; i += 4)
-	{
+        float xsq = x * x;
 
-		float xsq = x * x;
+        float xcube = x * xsq;
 
-		float xcube = x * xsq;
+        cbuf[i] = ((-x + 2 * xsq - xcube)); // p0 multiplier
 
-		cbuf[i] = ((-x + 2 * xsq - xcube));	// p0 multiplier
+        cbuf[i + 1] = ((2 - 5 * xsq + 3 * xcube)); // p1 multiplier
 
-		cbuf[i + 1] = ((2 - 5 * xsq + 3 * xcube));	// p1 multiplier
+        cbuf[i + 2] = ((x + 4 * xsq - 3 * xcube)); // p2 multiplier
 
-		cbuf[i + 2] = ((x + 4 * xsq - 3 * xcube));// p2 multiplier
+        cbuf[i + 3] = ((-xsq + xcube)); // p3  multiplier
 
-		cbuf[i + 3] = ((-xsq + xcube));			// p3  multiplier
+        float sum = cbuf[i] + cbuf[i + 1] + cbuf[i + 2] + cbuf[i + 3];
+        //	normalize
 
-		float sum = cbuf[i] + cbuf[i + 1] + cbuf[i + 2] + cbuf[i + 3];
-		//	normalize
+        for(int n = 0; n < 4; n++)
 
-		for ( int n = 0; n < 4; n ++)
+            cbuf[i + n] /= sum;
 
-			cbuf[i + n] /=  sum;
-
-		x += inc;
-	}
+        x += inc;
+    }
 }
 
 //-------------------------------------------------------------------
 
-void LanczosCoeff(float* cbuf, const int span, const int quantp)
-{
-	/*
-	Fills buffer with coefficients
-	cbuf: in which coefficients to be placed. Must be (quantp + 1) span
-	span:  lanczos  number of values used for one interpolation 4 or 6
-	quantp: quantile precision interval for interpolation
-
-	*/
-	for (int s = 0; s < span; s++)
-	{
-		// zero out first and last quantile ( zero value quantile)
-
-		cbuf[s] = 0;
-		cbuf[quantp * span + s] = 0;
-	}
-
-	cbuf[span / 2 - 1] = 1.0;	// so that the nearest pixel value is used 
-
-	cbuf[quantp * span + span / 2] = 1.0f;
-
-	float fraction = 1.0f / quantp;
-
-	float frac = fraction;
-
-	for (int s = span; s < span * quantp; s += span)
-	{
-		float csum = 0.0f;		// sum of coefficients should equal 1.0 
-
-		for (int i = 0; i < span; i++)
-		{
-			// calculte lanczos coefficients
-			cbuf[s + i] = sinc(span / 2 - 1 - i + frac) * sinc((span / 2 - 1 - i + frac) / (span / 2));
-
-			csum += cbuf[s + i];
-		}
-		for (int i = 0; i < span; i++)
-		{
-			cbuf[s + i] *= (1.0f / csum);
-		}
-		frac += fraction;
-	}
+void LanczosCoeff(float *cbuf, const int span, const int quantp) {
+    /*
+    Fills buffer with coefficients
+    cbuf: in which coefficients to be placed. Must be (quantp + 1) span
+    span:  lanczos  number of values used for one interpolation 4 or 6
+    quantp: quantile precision interval for interpolation
+
+    */
+    for(int s = 0; s < span; s++) {
+        // zero out first and last quantile ( zero value quantile)
+
+        cbuf[s] = 0;
+        cbuf[quantp * span + s] = 0;
+    }
+
+    cbuf[span / 2 - 1] = 1.0; // so that the nearest pixel value is used
+
+    cbuf[quantp * span + span / 2] = 1.0f;
+
+    float fraction = 1.0f / quantp;
+
+    float frac = fraction;
+
+    for(int s = span; s < span * quantp; s += span) {
+        float csum = 0.0f; // sum of coefficients should equal 1.0
+
+        for(int i = 0; i < span; i++) {
+            // calculte lanczos coefficients
+            cbuf[s + i] = sinc(span / 2 - 1 - i + frac) *
+                          sinc((span / 2 - 1 - i + frac) / (span / 2));
+
+            csum += cbuf[s + i];
+        }
+        for(int i = 0; i < span; i++) {
+            cbuf[s + i] *= (1.0f / csum);
+        }
+        frac += fraction;
+    }
 }
 
 //-----------------------------------------------------------------------------------
 
-float sinc(float f)
-{
-	if (f < 0.0)
+float sinc(float f) {
+    if(f < 0.0)
 
-		f = -f;
+        f = -f;
 
-	f *= (float)M_PI;	// pi
+    f *= (float) M_PI; // pi
 
-	return (f != 0) ? sin(f) / f : 1.0f; ;
+    return (f != 0) ? sin(f) / f : 1.0f;
+    ;
 }
-//----------------------------------------------------------------------------------------------	
-float* setInterpolationScheme(const int q, const int quantiles, int *dspan)
-{
-	float* iCoeff = NULL;
-	int span = 1;
-	switch (q)
-	{
-	case 1:
-	{
-		// use for near point or manipal 9 pt
-		span = 2;
-		iCoeff = NULL;
-		break;
-	}
-	case 2:
-	{
-		// bilinear
-		span = 2;
-		iCoeff = (float*)vs_aligned_malloc<float>(sizeof(float) * span * (quantiles + 1), 32);
-		LinearIntCoeff(iCoeff, quantiles);
-		break;
-	}
-
-	case 3:
-	{
-
-		span = 4; // cubic
-		iCoeff = (float*)vs_aligned_malloc<float>(sizeof(float) * span * (quantiles + 1), 32);
-		CubicIntCoeff(iCoeff, quantiles);
-		break;
-	}
-	case 4:
-	{
-		span = 6; // lanczos is 6 x 6
-		iCoeff = (float*)vs_aligned_malloc<float>(sizeof(float) * span * (quantiles + 1), 32);
-		// create lanczos coefficients for every quantile
-		LanczosCoeff(iCoeff, span, quantiles);
-		break;
-	}
-	}
-	*dspan = span;
-	return iCoeff;
+//----------------------------------------------------------------------------------------------
+float *setInterpolationScheme(const int q, const int quantiles, int *dspan) {
+    float *iCoeff = NULL;
+    int span = 1;
+    switch(q) {
+    case 1: {
+        // use for near point or manipal 9 pt
+        span = 2;
+        iCoeff = NULL;
+        break;
+    }
+    case 2: {
+        // bilinear
+        span = 2;
+        iCoeff = (float *) vs_aligned_malloc<float>(
+            sizeof(float) * span * (quantiles + 1), 32);
+        LinearIntCoeff(iCoeff, quantiles);
+        break;
+    }
+
+    case 3: {
+
+        span = 4; // cubic
+        iCoeff = (float *) vs_aligned_malloc<float>(
+            sizeof(float) * span * (quantiles + 1), 32);
+        CubicIntCoeff(iCoeff, quantiles);
+        break;
+    }
+    case 4: {
+        span = 6; // lanczos is 6 x 6
+        iCoeff = (float *) vs_aligned_malloc<float>(
+            sizeof(float) * span * (quantiles + 1), 32);
+        // create lanczos coefficients for every quantile
+        LanczosCoeff(iCoeff, span, quantiles);
+        break;
+    }
+    }
+    *dspan = span;
+    return iCoeff;
 }
 #endif // !INTERPOLATION_STUFF_V_C_MOHAN
-
diff --git a/modHistogram.cpp b/modHistogram.cpp
index 683f5d9..2ada700 100644
--- a/modHistogram.cpp
+++ b/modHistogram.cpp
@@ -1,16 +1,16 @@
 /*********************************************************************************************
 HistogramAdjust filter plugin for vapoursynth by V.C.Mohan
 
-	Full frame  or windowed equalization or matching Histograms.
+    Full frame  or windowed equalization or matching Histograms.
 
-	For matching either a table or a frame of a clip can be used.
+    For matching either a table or a frame of a clip can be used.
 
-	YUV  and Gray scale formats only are accepted as input.
+    YUV  and Gray scale formats only are accepted as input.
 
-	Thread safe.
+    Thread safe.
 
-	22 jun 2015 20 Aug 2020
-	 Copyright (C) <2005-2020>  <V.C.Mohan>
+    22 jun 2015 20 Aug 2020
+     Copyright (C) <2005-2020>  <V.C.Mohan>
 
     This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -23,608 +23,585 @@ HistogramAdjust filter plugin for vapoursynth by V.C.Mohan
 
     A copy of the GNU General Public License is at
     http://www.gnu.org/licenses/.
-	
+
  Author V.C.Mohan
 
- 
-*************************************************************************************************/ 
+
+*************************************************************************************************/
 /*
-#include <stdlib.h>
-#include "vapoursynth.h"
-#include "VSHelper.h"
 #include "HistogramAdjustHelper.cpp"
+#include "VSHelper.h"
+#include "vapoursynth.h"
+#include <stdlib.h>
 */
 typedef struct {
-				VSNodeRef *node[2];
-				const VSVideoInfo *vi[2];
-				int type;			// 1. equalize,2. match clip, 3 match %age table 4. match cummulative table
-				int table[40];				// histogram values from this table  to be used for matching
-				int nentries;
-				int mf;				// frame number of example clip to be used for matching Histogram
-				bool window;		// is windowed equalization required? true yes
-		
-				int limit;			// in windowed processing max %age increase allowed
-		
-				float *histbuf, *matchbuf;			// buffers to get frame, local and matching clip  histograms;
-				float *lbuf, *cbuf;				// buffer for lookup table to match histograms
-
-				
-
-}HistogramAdjustData;
+    VSNodeRef *node[2];
+    const VSVideoInfo *vi[2];
+    int type;      // 1. equalize,2. match clip, 3 match %age table 4. match
+                   // cummulative table
+    int table[40]; // histogram values from this table  to be used for matching
+    int nentries;
+    int mf; // frame number of example clip to be used for matching Histogram
+    bool window; // is windowed equalization required? true yes
+
+    int limit; // in windowed processing max %age increase allowed
+
+    float *histbuf,
+        *matchbuf; // buffers to get frame, local and matching clip  histograms;
+    float *lbuf, *cbuf; // buffer for lookup table to match histograms
+
+} HistogramAdjustData;
 
 //-------------------------------------------------------------------------------------------------
 
-static void VS_CC histogramadjustInit(VSMap *in, VSMap *out, void **instanceData, VSNode *node, VSCore *core, const VSAPI *vsapi)
-{
-    HistogramAdjustData *d = (HistogramAdjustData *) * instanceData;
+static void VS_CC histogramadjustInit(VSMap *in, VSMap *out,
+                                      void **instanceData, VSNode *node,
+                                      VSCore *core, const VSAPI *vsapi) {
+    HistogramAdjustData *d = (HistogramAdjustData *) *instanceData;
     vsapi->setVideoInfo(d->vi[0], 1, node);
 
-	int nb = d->vi[0]->format->bitsPerSample;
-	int maxvalue = nb <= 12 ? 1 << nb : 4096;	// corresponds to 12 bit depth
-
-	d->matchbuf = NULL;
-
-	if ( d->type != 1)
-		// not equalization
-		d->matchbuf = vs_aligned_malloc <float>(sizeof( float) * maxvalue , 32);	 
-		
-	if (d->type == 2)	// matching with given frame of a clip
-	{		
-					// so get the frame of that clip		
-		const VSFrameRef *matchf = vsapi->getFrame(d->mf, d->node[1], NULL, NULL);
-			
-        // The reason we query this on a per frame basis is because we want our filter
-        // to accept clips with varying dimensions. If we reject such content using d->vi
-        // would be better.
+    int nb = d->vi[0]->format->bitsPerSample;
+    int maxvalue = nb <= 12 ? 1 << nb : 4096; // corresponds to 12 bit depth
+
+    d->matchbuf = NULL;
+
+    if(d->type != 1)
+        // not equalization
+        d->matchbuf = vs_aligned_malloc<float>(sizeof(float) * maxvalue, 32);
+
+    if(d->type == 2) // matching with given frame of a clip
+    {
+        // so get the frame of that clip
+        // Warning
+        // const VSFrameRef *matchf = vsapi->getFrame(d->mf, d->node[1], NULL,
+        // NULL);
+
+        // Fix
+        const VSFrameRef *matchf = vsapi->getFrame(d->mf, d->node[1], NULL, 0);
+
+        // The reason we query this on a per frame basis is because we want our
+        // filter to accept clips with varying dimensions. If we reject such
+        // content using d->vi would be better.
         const VSFormat *matchfi = d->vi[1]->format;
         int mht = vsapi->getFrameHeight(matchf, 0);
         int mwd = vsapi->getFrameWidth(matchf, 0);
-		const uint8_t *mfp = vsapi->getReadPtr(matchf, 0);
+        const uint8_t *mfp = vsapi->getReadPtr(matchf, 0);
         int m_stride = vsapi->getStride(matchf, 0);
-		int pitch = m_stride / matchfi->bytesPerSample;
-            
-		if (matchfi->sampleType == stInteger)
-		{
-			int mb = matchfi->bitsPerSample; 			
-
-			if ( mb == 8)
-			{
-					// get its histogram
-				getHistFromWindow8(mfp, pitch, mb,  mwd, mht, d->matchbuf);
-			}
-
-			else 
-			{
-				const uint16_t * mp = (const uint16_t *) mfp;				
-
-				getHistFromWindow16( mp, pitch , mb, mwd, mht, d->matchbuf);
-			}			
-			
-		}
-
-		else		// floating format. limit bins to 4096
-		{
-			const float * mp = (const float *) mfp;
-			
-			getHistFromWindowf( mp, pitch , 12, mwd, mht, d->matchbuf);			
-		}
-
-		sigmaHist(d->matchbuf, d->matchbuf,maxvalue);
-
-		vsapi->freeFrame( matchf);			
-
-		vsapi->freeNode (d->node[1]);
-	
-	}
-	else if (d->type == 3)		 
-	{
-		// construct histogram from table of luma and population %ages
-		getHistFromTable(d->table, d->nentries, maxvalue, d->matchbuf);
-		// progrssive sum. 
-		sigmaHist(d->matchbuf, d->matchbuf, maxvalue);
-	}
-	else if (d->type == 4)
-	{
-		// construct histogram from table of luma and cummulative population %ages
-		int count = getHistCummTable(d->table, d->nentries, maxvalue, d->matchbuf);
-
-		if (count != maxvalue)
-		{
-			vsapi->setError(out, "in correct count ");
-			free(d->matchbuf);
-			vsapi->freeNode(d->node[0]);
-			return;
-		}
-		
-	}
+        int pitch = m_stride / matchfi->bytesPerSample;
+
+        if(matchfi->sampleType == stInteger) {
+            int mb = matchfi->bitsPerSample;
+
+            if(mb == 8) {
+                // get its histogram
+                getHistFromWindow8(mfp, pitch, mb, mwd, mht, d->matchbuf);
+            }
+
+            else {
+                const uint16_t *mp = (const uint16_t *) mfp;
+
+                getHistFromWindow16(mp, pitch, mb, mwd, mht, d->matchbuf);
+            }
+
+        }
+
+        else // floating format. limit bins to 4096
+        {
+            const float *mp = (const float *) mfp;
+
+            getHistFromWindowf(mp, pitch, 12, mwd, mht, d->matchbuf);
+        }
+
+        sigmaHist(d->matchbuf, d->matchbuf, maxvalue);
+
+        vsapi->freeFrame(matchf);
+
+        vsapi->freeNode(d->node[1]);
+
+    } else if(d->type == 3) {
+        // construct histogram from table of luma and population %ages
+        getHistFromTable(d->table, d->nentries, maxvalue, d->matchbuf);
+        // progrssive sum.
+        sigmaHist(d->matchbuf, d->matchbuf, maxvalue);
+    } else if(d->type == 4) {
+        // construct histogram from table of luma and cummulative population
+        // %ages
+        int count =
+            getHistCummTable(d->table, d->nentries, maxvalue, d->matchbuf);
+
+        if(count != maxvalue) {
+            vsapi->setError(out, "in correct count ");
+            free(d->matchbuf);
+            vsapi->freeNode(d->node[0]);
+            return;
+        }
+    }
 }
 
 //-------------------------------------------------------------------------------------
 
-static void VS_CC histogramadjustFree(void *instanceData, VSCore *core, const VSAPI *vsapi)
-{
-    HistogramAdjustData *d = (HistogramAdjustData *)instanceData;
+static void VS_CC histogramadjustFree(void *instanceData, VSCore *core,
+                                      const VSAPI *vsapi) {
+    HistogramAdjustData *d = (HistogramAdjustData *) instanceData;
     vsapi->freeNode(d->node[0]);
-	if (d->matchbuf != NULL)
-		vs_aligned_free (d->matchbuf);
+    if(d->matchbuf != NULL)
+        vs_aligned_free(d->matchbuf);
 
     free(d);
 }
 //-------------------------------------------------------------------------------------
 
- // This is the main function that gets called when a frame should be produced-> It will in most cases get
-// called several times to produce one frame. This state is being kept track of by the value of
-// activationReason. The first call to produce a certain frame n is always arInitial. In this state
-// you should request all input frames you need-> Always do it i ascending order to play nice with the
-// upstream filters.
-// Once all frames are ready the the filter will be called with arAllFramesReady. It is now time to
-// do the actual processing.
-static const VSFrameRef *VS_CC histogramadjustGetFrame
-				(int n, int activationReason, void **instanceData, 
-				void **frameData, VSFrameContext *frameCtx, 
-				VSCore *core, const VSAPI *vsapi)
-{
-    HistogramAdjustData *d = (HistogramAdjustData *) * instanceData;
-
-    if (activationReason == arInitial) 
-	{
+// This is the main function that gets called when a frame should be produced->
+// It will in most cases get
+// called several times to produce one frame. This state is being kept track of
+// by the value of activationReason. The first call to produce a certain frame n
+// is always arInitial. In this state you should request all input frames you
+// need-> Always do it i ascending order to play nice with the upstream filters.
+// Once all frames are ready the the filter will be called with
+// arAllFramesReady. It is now time to do the actual processing.
+static const VSFrameRef *VS_CC histogramadjustGetFrame(
+    int n, int activationReason, void **instanceData, void **frameData,
+    VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) {
+    HistogramAdjustData *d = (HistogramAdjustData *) *instanceData;
+
+    if(activationReason == arInitial) {
         // Request the source frame on the first call
         vsapi->requestFrameFilter(n, d->node[0], frameCtx);
-    }
-	else if (activationReason == arAllFramesReady) 
-	{
+    } else if(activationReason == arAllFramesReady) {
         const VSFrameRef *src = vsapi->getFrameFilter(n, d->node[0], frameCtx);
-       
+
         const VSFormat *fi = d->vi[0]->format;
 
-		int nbits = fi->bitsPerSample;
-		
-        VSFrameRef *dst = vsapi->newVideoFrame(fi, d->vi[0]->width, d->vi[0]->height, src, core);
-		int fwidth;	// number of samples to get. Will be multiplied number of bytes per sample by NewVideoFrame
-		if(fi->sampleType== stInteger)
-		{
-			fwidth = nbits > 12 ? 4096 : 1 << nbits;
-			
-		}
-		else
-			fwidth  = 4096;	// floating point
-		
-		float *histbuf = vs_aligned_malloc<float>(sizeof(float) * fwidth, 32);
-		
-		for(int plane = 0; plane < fi->numPlanes; plane ++)
-		{
-			const uint8_t *srcp = vsapi->getReadPtr(src, plane);
-			int src_stride = vsapi->getStride(src, plane);
-			uint8_t *dstp = vsapi->getWritePtr(dst, plane);
-			int bht = vsapi->getFrameHeight(src, plane);            
-			int bwd = vsapi->getFrameWidth(src, plane);
-			int samplesize = fi->bytesPerSample; 
-			int pitch = src_stride / samplesize;
-			if (plane > 0  && fi->colorFamily == cmYUV)
-			{
-				vs_bitblt(dstp, src_stride, srcp, src_stride, bwd * samplesize, bht);
-
-				continue;
-			}
-	
-			bool windowed = false;
-				// check whether frame dimensions are adequate for windowed processing
-			if (d->window == 1 && bht >= 200 && bwd >= 200	)
-			{			
-				windowed = true;
-			}
-		
-				// processing frame
-			if( ! windowed)
-			{
-					// full frame processing
-				if (fi->sampleType == stInteger)
-				{
-					int nb = fi->bitsPerSample;
-
-					int maxval = fwidth;
-
-					if(nb == 8)
-					{
-						const uint8_t * sp = (const uint8_t *)srcp;
-						uint8_t * dp = (uint8_t *)dstp;				
-
-						getHistFromWindow8( sp, pitch, nb,  bwd , bht , histbuf);
-
-						sigmaHist(histbuf, histbuf, maxval);
-
-						if (d->type == 1)
-						{
-
-							fillAdjustedValues8(sp , dp , pitch, bwd, bht, nb, histbuf,  d->limit );
-						}
-						else
-							fillMatchedValues8(sp , dp , pitch , bwd, bht, nb, histbuf, d->matchbuf,  d->limit );
-
-					}
-
-					else
-					{
-						const uint16_t * sp =  (const uint16_t *)srcp;
-						uint16_t * dp = (uint16_t *)dstp;					
-					
-						getHistFromWindow16(  sp, pitch , nb,  bwd , bht , histbuf);
-					
-						sigmaHist(histbuf, histbuf, maxval);
-
-						if( d-> type == 1)
-						{
-
-							fillAdjustedValues16(sp , dp , pitch , bwd, bht, nb, histbuf,  d->limit );
-						}
-						else
-
-							fillMatchedValues16(sp , dp , pitch , bwd, bht, nb, histbuf,  d->matchbuf,  d->limit );
-
-					}
-				}
-
-				else	// floating point
-				{
-					int nb = 12;	// limit to 4096 values
-				
-					const float * sp = (const float *)srcp;
-					float * dp = (float *) dstp;				
-
-					getHistFromWindowf( sp, pitch , nb,  bwd , bht , histbuf);
-
-					sigmaHist(histbuf, histbuf, 4096);
-
-					if (d->type == 1)
-					{
-
-						fillAdjustedValuesf(sp , dp , pitch , bwd, bht, nb, histbuf,  d->limit );
-					}
-
-					else
-
-						fillMatchedValuesf(sp , dp , pitch , bwd, bht, nb, histbuf, d->matchbuf,  d->limit );
-				}
-			}
-
-			else //if (windowed)
-			{
-				int nb = fi->bitsPerSample;
-					// window dimensions
-				int wside =  nb > 10? 128 : 64;	// 128 x 128 or  64 x 64 ensure sufficient statistics
-				int innerw = wside / 4;	// 32x32 or 16x16
-				int iwinstart = (wside - innerw) /2 ;	// 48 or  24
-				int iwinend = wside - innerw / 2; // 112 or 56		
-				
-				int woverlap = innerw; // window overlap dimensions
-
-				int offset, wstart, wd, ht;
-
-				for( int w = 0; w < bwd - wside; w += woverlap)
-				{
-					for ( int h = 0; h < bht - wside; h += woverlap)
-					{			
-				
-						if ( h == 0)
-						{	// top row processing 
-							if ( w <= bwd - wside * 2)
-							{
-								// left top corner or less than right top corner
-								wstart = w == 0? 0 : w + iwinstart;
-								wd = w == 0 ? iwinend : innerw;
-								ht = iwinend;
-								offset = wstart;
-							
-							}
-
-							else if( w > bwd - wside * 2 )
-							{
-								// top right corner
-								wstart = w + iwinstart;
-								wd = bwd - w - iwinstart;
-								ht = iwinend;
-								offset = wstart;
-						
-							}
-						}	// h == 0?
-
-						else if ( h > bht - 2 * wside)
-						{// bottom row processing
-							if ( w <= bwd - wside * 2)
-							{
-								// left bottom corner  up to right bottom corner
-								wstart = w == 0? 0 : w + iwinstart;
-								wd = w == 0 ? iwinend : innerw;
-								ht = bht - h - iwinstart;
-								offset = ( h + iwinstart ) * pitch + wstart;
-							
-							}
-
-							else if ( w > bwd - 2 * wside)
-							{
-								// right bottom corner
-								wstart =  w + iwinstart;
-								wd =  bwd - w - iwinstart;
-								ht =  bht - h - iwinstart;
-								offset = ( h + iwinstart ) * pitch + wstart;
-
-							
-							}
-						}
-						//  process left margin excluding corners
-						else if ( w == 0)
-						{
-							wstart = 0;
-							wd = iwinend;
-							ht = innerw;
-							offset = (h + iwinstart ) * pitch;
-						
-						
-						}
-							// right margin
-						else if ( w > bwd - 2 * wside)
-						{
-							wstart = w + iwinstart;
-							wd = bwd - w - innerw;
-							ht = innerw;
-							offset = ( h + iwinstart ) * pitch + wstart;
-						}
-
-						else		//well inside frame
-						{
-							wstart = w + iwinstart;
-							wd = innerw;
-							ht = innerw;
-							offset = ( h + iwinstart ) * pitch + wstart;
-						}
-
-						if (fi->sampleType == stInteger)
-						{
-							int nb = fi->bitsPerSample;				
-
-							if(fi->bitsPerSample == 8)						
-							{
-								const uint8_t *sp = (const uint8_t *) srcp; 
-								uint8_t *dp = (uint8_t *) dstp;
-
-								getHistFromWindow8( sp + h * pitch + w , pitch, nb, wside, wside, histbuf);
-
-								sigmaHist( histbuf, histbuf, 1 << nb );
-
-								fillAdjustedValues8(sp + offset, dp + offset, pitch, wd, ht, nb, histbuf,  d->limit );			
-
-							}
-
-							else
-							{
-								// 10 or 12 or 16 bit depth samples
-								const uint16_t * sp = (const uint16_t *) srcp;
-								uint16_t * dp = (uint16_t *) dstp;
-								int nmax = nb <= 12 ? 1 << nb : 4096;
-								getHistFromWindow16( sp + h * pitch + w , pitch, nb, wside, wside, histbuf);
-
-								sigmaHist( histbuf, histbuf, nmax );
-							
-								fillAdjustedValues16(sp + offset, dp + offset, pitch, wd, ht, nb, histbuf,  d->limit );
-
-							}
-						}
-
-						else
-						{// floating point
-
-							const float * sp = (const float *) srcp;
-							float * dp = (float *) dstp;
-							int nb = 12;
-
-							getHistFromWindowf( sp + h * pitch + w , pitch, nb, wside, wside, histbuf);
-
-							sigmaHist( histbuf, histbuf, 1 << nb );
-
-							fillAdjustedValuesf(sp + offset, dp + offset, pitch, wd, ht, nb, histbuf,  d->limit );
-						}
-
-					}	//for  int h
-
-				}	// for int w
-			}	// window
-
-		}
-	
-		vsapi->freeFrame (src);	
-		vs_aligned_free(histbuf);
-		return dst;	
-	}	// get frame
-
-	return 0;
-}
+        int nbits = fi->bitsPerSample;
+
+        VSFrameRef *dst = vsapi->newVideoFrame(fi, d->vi[0]->width,
+                                               d->vi[0]->height, src, core);
+        int fwidth; // number of samples to get. Will be multiplied number of
+                    // bytes per sample by NewVideoFrame
+        if(fi->sampleType == stInteger) {
+            fwidth = nbits > 12 ? 4096 : 1 << nbits;
+
+        } else
+            fwidth = 4096; // floating point
+
+        float *histbuf = vs_aligned_malloc<float>(sizeof(float) * fwidth, 32);
+
+        for(int plane = 0; plane < fi->numPlanes; plane++) {
+            const uint8_t *srcp = vsapi->getReadPtr(src, plane);
+            int src_stride = vsapi->getStride(src, plane);
+            uint8_t *dstp = vsapi->getWritePtr(dst, plane);
+            int bht = vsapi->getFrameHeight(src, plane);
+            int bwd = vsapi->getFrameWidth(src, plane);
+            int samplesize = fi->bytesPerSample;
+            int pitch = src_stride / samplesize;
+            if(plane > 0 && fi->colorFamily == cmYUV) {
+                vs_bitblt(dstp, src_stride, srcp, src_stride, bwd * samplesize,
+                          bht);
+
+                continue;
+            }
+
+            bool windowed = false;
+            // check whether frame dimensions are adequate for windowed
+            // processing
+            if(d->window == 1 && bht >= 200 && bwd >= 200) {
+                windowed = true;
+            }
+
+            // processing frame
+            if(!windowed) {
+                // full frame processing
+                if(fi->sampleType == stInteger) {
+                    int nb = fi->bitsPerSample;
 
+                    int maxval = fwidth;
+
+                    if(nb == 8) {
+                        const uint8_t *sp = (const uint8_t *) srcp;
+                        uint8_t *dp = (uint8_t *) dstp;
+
+                        getHistFromWindow8(sp, pitch, nb, bwd, bht, histbuf);
+
+                        sigmaHist(histbuf, histbuf, maxval);
+
+                        if(d->type == 1) {
+
+                            fillAdjustedValues8(sp, dp, pitch, bwd, bht, nb,
+                                                histbuf, d->limit);
+                        } else
+                            fillMatchedValues8(sp, dp, pitch, bwd, bht, nb,
+                                               histbuf, d->matchbuf, d->limit);
+
+                    }
+
+                    else {
+                        const uint16_t *sp = (const uint16_t *) srcp;
+                        uint16_t *dp = (uint16_t *) dstp;
+
+                        getHistFromWindow16(sp, pitch, nb, bwd, bht, histbuf);
+
+                        sigmaHist(histbuf, histbuf, maxval);
+
+                        if(d->type == 1) {
+
+                            fillAdjustedValues16(sp, dp, pitch, bwd, bht, nb,
+                                                 histbuf, d->limit);
+                        } else
+
+                            fillMatchedValues16(sp, dp, pitch, bwd, bht, nb,
+                                                histbuf, d->matchbuf, d->limit);
+                    }
+                }
+
+                else // floating point
+                {
+                    int nb = 12; // limit to 4096 values
+
+                    const float *sp = (const float *) srcp;
+                    float *dp = (float *) dstp;
+
+                    getHistFromWindowf(sp, pitch, nb, bwd, bht, histbuf);
+
+                    sigmaHist(histbuf, histbuf, 4096);
+
+                    if(d->type == 1) {
+
+                        fillAdjustedValuesf(sp, dp, pitch, bwd, bht, nb,
+                                            histbuf, d->limit);
+                    }
+
+                    else
+
+                        fillMatchedValuesf(sp, dp, pitch, bwd, bht, nb, histbuf,
+                                           d->matchbuf, d->limit);
+                }
+            }
+
+            else // if (windowed)
+            {
+                int nb = fi->bitsPerSample;
+                // window dimensions
+                int wside = nb > 10 ? 128 : 64; // 128 x 128 or  64 x 64 ensure
+                                                // sufficient statistics
+                int innerw = wside / 4;         // 32x32 or 16x16
+                int iwinstart = (wside - innerw) / 2; // 48 or  24
+                int iwinend = wside - innerw / 2;     // 112 or 56
+
+                int woverlap = innerw; // window overlap dimensions
+
+                int offset, wstart, wd, ht;
+
+                for(int w = 0; w < bwd - wside; w += woverlap) {
+                    for(int h = 0; h < bht - wside; h += woverlap) {
+
+                        if(h == 0) { // top row processing
+                            if(w <= bwd - wside * 2) {
+                                // left top corner or less than right top corner
+                                wstart = w == 0 ? 0 : w + iwinstart;
+                                wd = w == 0 ? iwinend : innerw;
+                                ht = iwinend;
+                                offset = wstart;
+
+                            }
+
+                            else if(w > bwd - wside * 2) {
+                                // top right corner
+                                wstart = w + iwinstart;
+                                wd = bwd - w - iwinstart;
+                                ht = iwinend;
+                                offset = wstart;
+                            }
+                        } // h == 0?
+
+                        else if(h > bht - 2 * wside) { // bottom row processing
+                            if(w <= bwd - wside * 2) {
+                                // left bottom corner  up to right bottom corner
+                                wstart = w == 0 ? 0 : w + iwinstart;
+                                wd = w == 0 ? iwinend : innerw;
+                                ht = bht - h - iwinstart;
+                                offset = (h + iwinstart) * pitch + wstart;
+
+                            }
+
+                            else if(w > bwd - 2 * wside) {
+                                // right bottom corner
+                                wstart = w + iwinstart;
+                                wd = bwd - w - iwinstart;
+                                ht = bht - h - iwinstart;
+                                offset = (h + iwinstart) * pitch + wstart;
+                            }
+                        }
+                        //  process left margin excluding corners
+                        else if(w == 0) {
+                            wstart = 0;
+                            wd = iwinend;
+                            ht = innerw;
+                            offset = (h + iwinstart) * pitch;
+
+                        }
+                        // right margin
+                        else if(w > bwd - 2 * wside) {
+                            wstart = w + iwinstart;
+                            wd = bwd - w - innerw;
+                            ht = innerw;
+                            offset = (h + iwinstart) * pitch + wstart;
+                        }
+
+                        else // well inside frame
+                        {
+                            wstart = w + iwinstart;
+                            wd = innerw;
+                            ht = innerw;
+                            offset = (h + iwinstart) * pitch + wstart;
+                        }
+
+                        if(fi->sampleType == stInteger) {
+                            int nb = fi->bitsPerSample;
+
+                            if(fi->bitsPerSample == 8) {
+                                const uint8_t *sp = (const uint8_t *) srcp;
+                                uint8_t *dp = (uint8_t *) dstp;
+
+                                getHistFromWindow8(sp + h * pitch + w, pitch,
+                                                   nb, wside, wside, histbuf);
+
+                                sigmaHist(histbuf, histbuf, 1 << nb);
+
+                                fillAdjustedValues8(sp + offset, dp + offset,
+                                                    pitch, wd, ht, nb, histbuf,
+                                                    d->limit);
+
+                            }
+
+                            else {
+                                // 10 or 12 or 16 bit depth samples
+                                const uint16_t *sp = (const uint16_t *) srcp;
+                                uint16_t *dp = (uint16_t *) dstp;
+                                int nmax = nb <= 12 ? 1 << nb : 4096;
+                                getHistFromWindow16(sp + h * pitch + w, pitch,
+                                                    nb, wside, wside, histbuf);
+
+                                sigmaHist(histbuf, histbuf, nmax);
+
+                                fillAdjustedValues16(sp + offset, dp + offset,
+                                                     pitch, wd, ht, nb, histbuf,
+                                                     d->limit);
+                            }
+                        }
+
+                        else { // floating point
+
+                            const float *sp = (const float *) srcp;
+                            float *dp = (float *) dstp;
+                            int nb = 12;
+
+                            getHistFromWindowf(sp + h * pitch + w, pitch, nb,
+                                               wside, wside, histbuf);
+
+                            sigmaHist(histbuf, histbuf, 1 << nb);
+
+                            fillAdjustedValuesf(sp + offset, dp + offset, pitch,
+                                                wd, ht, nb, histbuf, d->limit);
+                        }
+
+                    } // for  int h
+
+                } // for int w
+            } // window
+        }
+
+        vsapi->freeFrame(src);
+        vs_aligned_free(histbuf);
+        return dst;
+    } // get frame
+
+    return 0;
+}
 
 // Calls the constructor with the arguments provied->
-// This function is responsible for validating arguments and creating a new filter
-static void VS_CC histogramadjustCreate(const VSMap *in, 
-					VSMap *out, void *userData, VSCore *core,
-					const VSAPI *vsapi) 
-{
+// This function is responsible for validating arguments and creating a new
+// filter
+static void VS_CC histogramadjustCreate(const VSMap *in, VSMap *out,
+                                        void *userData, VSCore *core,
+                                        const VSAPI *vsapi) {
 
     HistogramAdjustData d;
     HistogramAdjustData *data;
-//  VSNodeRef *cref;
+    //  VSNodeRef *cref;
     int err;
-	int temp;
-
+    int temp;
 
     // Get a clip reference from the input arguments. This must be freed later.
     d.node[0] = vsapi->propGetNode(in, "clip", 0, 0);
     d.vi[0] = vsapi->getVideoInfo(d.node[0]);
-	d.node[1] = NULL;
-    // In this first version we only want to handle 8 bit integer formats. Note that
-    // vi->format can be 0 if the input clip can change format midstream.
-    //if (!isConstantFormat(d->vi) || d->vi->format->sampleType != stInteger || d->vi->format->bitsPerSample != 8) {
-    //    vsapi->setError(out, "HistogramAdjust: only constant format 8 bit integer input supported");
-    //    vsapi->freeNode(d->node);
-    //    return;
-
-	if (!isConstantFormat(d.vi[0]) )
-	{
-		vsapi->setError(out,"hist accepts const  format clip only");
-		vsapi->freeNode(d.node[0]);
-		return;
+    d.node[1] = NULL;
+    // In this first version we only want to handle 8 bit integer formats. Note
+    // that vi->format can be 0 if the input clip can change format midstream.
+    // if (!isConstantFormat(d->vi) || d->vi->format->sampleType != stInteger ||
+    // d->vi->format->bitsPerSample != 8) {
+    //    vsapi->setError(out, "HistogramAdjust: only constant format 8 bit
+    //    integer input supported"); vsapi->freeNode(d->node); return;
+
+    if(!isConstantFormat(d.vi[0])) {
+        vsapi->setError(out, "hist accepts const  format clip only");
+        vsapi->freeNode(d.node[0]);
+        return;
     }
 
-	if(  d.vi[0]->format->colorFamily != cmYUV && d.vi[0]->format->colorFamily != cmGray)
-	{
-		vsapi->setError(out,"hist accepts YUV and Gray formats only");
-		vsapi->freeNode(d.node[0]);
-		return;
+    if(d.vi[0]->format->colorFamily != cmYUV &&
+       d.vi[0]->format->colorFamily != cmGray) {
+        vsapi->setError(out, "hist accepts YUV and Gray formats only");
+        vsapi->freeNode(d.node[0]);
+        return;
     }
 
     // If a property read fails for some reason (index out of bounds/wrong type)
-    // then err will have flags set to indicate why and 0 will be returned-> This
-    // can be very useful to know when having optional arguments. Since we have
-    // strict checking because of what we wrote in the argument string the only reason
-    // this could fail is when the value wasn't set by the user.
-    // And when it's not set we want it to default to enabled->
-    d.type = vsapi->propGetInt(in, "type",0, &err);
-	if(err)
-		d.type = 1;
-	if(d.type < 1 || d.type > 3)
-	{
-		// 1 =  equalisation, 2 = match using table values 3 = match using a specified frame of matching clip
-        vsapi->setError(out, "hist: type can have value of 1 for equalization, 2 match with frame of mclip, 3.match table of luma and population %ages or 4 match with table of luma and cummulative population %ages.y");
+    // then err will have flags set to indicate why and 0 will be returned->
+    // This can be very useful to know when having optional arguments. Since we
+    // have strict checking because of what we wrote in the argument string the
+    // only reason this could fail is when the value wasn't set by the user. And
+    // when it's not set we want it to default to enabled->
+    d.type = vsapi->propGetInt(in, "type", 0, &err);
+    if(err)
+        d.type = 1;
+    if(d.type < 1 || d.type > 3) {
+        // 1 =  equalisation, 2 = match using table values 3 = match using a
+        // specified frame of matching clip
+        vsapi->setError(
+            out,
+            "hist: type can have value of 1 for equalization, 2 match with "
+            "frame of mclip, 3.match table of luma and population %ages or 4 "
+            "match with table of luma and cummulative population %ages.y");
+        vsapi->freeNode(d.node[0]);
+        return;
+    }
+
+    if(d.type == 2) {
+
+        int m = vsapi->propNumElements(in, "table");
+
+        if(m < 4 || (m & 1) != 0 || m > 40) {
+            vsapi->setError(out,
+                            "hist atleast 2 and not more than 20 pairs   of "
+                            "table values for matching to be specified");
+            vsapi->freeNode(d.node[0]);
+
+            return;
+        }
+
+        for(int i = 0; i < m; i++)
+            d.table[i] = vsapi->propGetInt(in, "table", i, 0);
+
+        for(int i = 0, j = -1, k = 0; i < m; i += 2) {
+            // check pairs of values
+            if(d.type == 3) {
+                if(d.table[i] <= j || d.table[i] > 100 || d.table[i + 1] < 0 ||
+                   d.table[i + 1] > 100) {
+                    vsapi->setError(
+                        out, "hist first member values of  pairs must be in "
+                             "ascending order and not more than 100. the "
+                             "second value of pair must be between 0 and 100");
+                    vsapi->freeNode(d.node[0]);
+                    return;
+                }
+            }
+
+            else if(d.type == 4) {
+
+                if(d.table[i] <= j || d.table[i] > 100 || d.table[i + 1] < k ||
+                   d.table[i + 1] > 100) {
+                    vsapi->setError(
+                        out,
+                        "hist  luma and cummulative populatio values of  "
+                        "pairs. Both must be in ascending order 0 to 100.");
+                    vsapi->freeNode(d.node[0]);
+                    return;
+                }
+            }
+
+            j = d.table[i];
+            k = d.table[i + 1];
+        }
+
+        d.nentries = m;
+
+    }
+
+    else if(d.type == 3) {
+        d.node[1] = vsapi->propGetNode(in, "clipm", 0, &err);
+
+        if(err) {
+            d.node[1] =
+                vsapi->cloneNodeRef(d.node[0]); // default use first clip only
+        }
+
+        d.vi[1] = vsapi->getVideoInfo(d.node[1]);
+
+        if(!isConstantFormat(d.vi[1])) {
+            vsapi->setError(
+                out, "hist accepts for matching const YUV  format clipm only");
+
+            vsapi->freeNode(d.node[0]);
+            vsapi->freeNode(d.node[1]);
+            return;
+        }
+
+        if(d.vi[1]->format->colorFamily != cmYUV) {
+            vsapi->setError(
+                out, "hist accepts for matching clipm YUV  formats only. ");
+            vsapi->freeNode(d.node[0]);
+            vsapi->freeNode(d.node[1]);
+            return;
+        }
+
+        d.mf = vsapi->propGetInt(in, "fm", 0, &err);
+
+        if(err)
+            d.mf = 0;
+
+        if(d.mf < 0 || d.mf >= d.vi[1]->numFrames) {
+            vsapi->setError(out, "hist clip for matching have fewer frames "
+                                 "than Frame number specified");
+
+            vsapi->freeNode(d.node[0]);
+            vsapi->freeNode(d.node[1]);
+            return;
+        }
+    }
+    temp = !!vsapi->propGetInt(in, "window", 0, &err);
+
+    if(err)
+
+        d.window = false; // default use full frame
+
+    else if(temp < 0 || temp > 1) {
+        vsapi->setError(out, "hist window can have a value of 0 or 1 only ");
+
         vsapi->freeNode(d.node[0]);
+        if(d.node[1] != NULL)
+            vsapi->freeNode(d.node[1]);
+
         return;
     }
+    if(temp == 0)
+        d.window = false;
+    else
+        d.window = true;
+
+    d.limit = vsapi->propGetInt(in, "limit", 0, &err);
+
+    if(err)
 
-	if (d.type == 2)
-	{
-		
-
-		int m = vsapi->propNumElements(in, "table");
-
-		if ( m < 4 || (m & 1) != 0 || m > 40 )
-		{
-			vsapi->setError(out,"hist atleast 2 and not more than 20 pairs   of table values for matching to be specified");
-			vsapi->freeNode(d.node[0]);
-			
-			return;
-		}
-
-		for(int i = 0; i < m; i ++)
-			d.table[i] = vsapi->propGetInt(in, "table", i, 0);
-
-		for( int i = 0, j = -1, k = 0; i < m; i += 2)
-		{
-			// check pairs of values
-			if (d.type == 3)
-			{
-				if (d.table[i] <= j || d.table[i] > 100 || d.table[i + 1] < 0 || d.table[i + 1] > 100)
-				{
-					vsapi->setError(out, "hist first member values of  pairs must be in ascending order and not more than 100. the second value of pair must be between 0 and 100");
-					vsapi->freeNode(d.node[0]);
-					return;
-				}
-			}
-
-			else if (d.type == 4)
-			{
-				
-				if (d.table[i] <= j || d.table[i] > 100 || d.table[i + 1] < k || d.table[i + 1] > 100)
-				{
-					vsapi->setError(out, "hist  luma and cummulative populatio values of  pairs. Both must be in ascending order 0 to 100.");
-					vsapi->freeNode(d.node[0]);
-					return;
-				}
-				
-			}
-
-			j = d.table[i];
-			k = d.table[i + 1];
-		}
-
-		d.nentries = m;
-
-	}	
-
-	else if(d.type == 3)
-	{		
-		 d.node[1] = vsapi->propGetNode(in, "clipm", 0, &err);
-		
-		 if (err)
-		 {
-			d.node[1] = vsapi->cloneNodeRef(d.node[0]);	// default use first clip only
-			
-		 }
-
-		 d.vi[1] =  vsapi->getVideoInfo(d.node[1]);
-
-		 if (!isConstantFormat(d.vi[1]) )
-		{
-			vsapi->setError(out,"hist accepts for matching const YUV  format clipm only");
-			
-			vsapi->freeNode(d.node[0]);
-			vsapi->freeNode(d.node[1]);
-			return;
-		}	
-		
-		if(d.vi[1]->format->colorFamily != cmYUV)
-		{
-			vsapi->setError(out,"hist accepts for matching clipm YUV  formats only. ");			
-			vsapi->freeNode(d.node[0]);
-			vsapi->freeNode(d.node[1]);
-			return;
-		}
-		
-		d.mf = vsapi->propGetInt(in, "fm", 0, &err);
-		
-		if (err)
-			d.mf = 0;
-
-		if( d.mf < 0 || d.mf >= d.vi[1]->numFrames )
-		{
-			vsapi->setError(out,"hist clip for matching have fewer frames than Frame number specified");
-			
-			vsapi->freeNode(d.node[0]);
-			vsapi->freeNode(d.node[1]);
-			return;
-		}
-	}
-	temp = !!vsapi->propGetInt(in, "window", 0, &err);
-
-	if (err)
-
-		d.window = false;	// default use full frame
-
-	else if(temp < 0 || temp > 1)
-	{
-		vsapi->setError(out,"hist window can have a value of 0 or 1 only ");
-		
-		vsapi->freeNode(d.node[0]);
-		if (d.node[1] != NULL)
-			vsapi->freeNode(d.node[1]);
-		
-		return;
-	}
-	if (temp == 0)
-		d.window = false;
-	else
-		d.window = true;
-
-		
-	d.limit = vsapi->propGetInt(in, "limit", 0, &err);
-
-	if (err)
-	
-		d.limit  = 0;	// default 100% adjust fully
-
-	
-	if (d.limit < 0 || d.limit > 99 ) 
-	{
-        vsapi->setError(out, "hist: limit a %age value  can be an integer from 0 to 99 only");
-        
-		vsapi->freeNode(d.node[0]);
-		if (d.node[1] != NULL)
-			vsapi->freeNode(d.node[1]);
+        d.limit = 0; // default 100% adjust fully
+
+    if(d.limit < 0 || d.limit > 99) {
+        vsapi->setError(
+            out,
+            "hist: limit a %age value  can be an integer from 0 to 99 only");
+
+        vsapi->freeNode(d.node[0]);
+        if(d.node[1] != NULL)
+            vsapi->freeNode(d.node[1]);
         return;
     }
 
@@ -632,37 +609,34 @@ static void VS_CC histogramadjustCreate(const VSMap *in,
 
     // until all the input validation is done.
 
-  data =  (HistogramAdjustData *) malloc(sizeof(d));
-  *data = d;
-
-  
-
-    // Create a new filter and returns a reference to it. Always pass on the in and out
-    // arguments or unexpected things may happen. The name should be something that's
-    // easy to connect to the filter, like its function name.
-    // The three function pointers handle initialization, frame processing and filter destruction.
-    // The filtermode is very important to get right as it controls how threading of the filter
-    // is handled-> In general you should only use fmParallel whenever possible. This is if you
-    // need to modify no shared data at all when the filter is running.
-    // For more complicated filters fmParallelRequests is usually easier to achieve as an
-    // be prefetched in parallel but the actual processing is serialized->
-    // The others can be considered special cases where fmSerial is useful to source filters and
-    // fmUnordered is useful when a filter's state may change even when deciding which frames to
-    // prefetch (such as a cache filter).
-    // If you filter is really fast (such as a filter that only resorts frames) you should set the
-    // nfNoCache flag to make the caching work smoother.
-    vsapi->createFilter(in, out, "HistogramAdjust", histogramadjustInit, 
-								histogramadjustGetFrame, histogramadjustFree, 
-								fmParallel, 0, data, core);
-   // return;
-
-
+    data = (HistogramAdjustData *) malloc(sizeof(d));
+    *data = d;
+
+    // Create a new filter and returns a reference to it. Always pass on the in
+    // and out arguments or unexpected things may happen. The name should be
+    // something that's easy to connect to the filter, like its function name.
+    // The three function pointers handle initialization, frame processing and
+    // filter destruction. The filtermode is very important to get right as it
+    // controls how threading of the filter is handled-> In general you should
+    // only use fmParallel whenever possible. This is if you need to modify no
+    // shared data at all when the filter is running. For more complicated
+    // filters fmParallelRequests is usually easier to achieve as an be
+    // prefetched in parallel but the actual processing is serialized-> The
+    // others can be considered special cases where fmSerial is useful to source
+    // filters and fmUnordered is useful when a filter's state may change even
+    // when deciding which frames to prefetch (such as a cache filter). If you
+    // filter is really fast (such as a filter that only resorts frames) you
+    // should set the nfNoCache flag to make the caching work smoother.
+    vsapi->createFilter(in, out, "HistogramAdjust", histogramadjustInit,
+                        histogramadjustGetFrame, histogramadjustFree,
+                        fmParallel, 0, data, core);
+    // return;
 }
 
-// This is the entry point that is called when a plugin is loaded-> You are only supposed
-// to call the two provided functions here.
-// configFunc sets the id, namespace, and long name of the plugin (the last 3 arguments
-// never need to be changed for a normal plugin).
+// This is the entry point that is called when a plugin is loaded-> You are only
+// supposed to call the two provided functions here. configFunc sets the id,
+// namespace, and long name of the plugin (the last 3 arguments never need to be
+// changed for a normal plugin).
 //
 // id: Needs to be a "reverse" url and unique among all plugins.
 //   It is inspired by how android packages identify themselves.
@@ -673,18 +647,20 @@ static void VS_CC histogramadjustCreate(const VSMap *in,
 //
 // full name: Any name that describes the plugin nicely.
 //
-// registerFunc is called once for each function you want to register. Function names
-// should be PascalCase. The argument string has this format:
-// name:type; or name:type:flag1:flag2....;
-// All argument name should be lowercase and only use [a-z_].
-// The valid types are int,float,data,clip,frame,func. [] can be appended to allow arrays
-// of type to be passed (numbers:int[])
-// The available flags are opt, to make an argument optional, empty, which controls whether
-// or not empty arrays are accepted and link which will not be explained here.
+// registerFunc is called once for each function you want to register. Function
+// names should be PascalCase. The argument string has this format: name:type;
+// or name:type:flag1:flag2....; All argument name should be lowercase and only
+// use [a-z_]. The valid types are int,float,data,clip,frame,func. [] can be
+// appended to allow arrays of type to be passed (numbers:int[]) The available
+// flags are opt, to make an argument optional, empty, which controls whether or
+// not empty arrays are accepted and link which will not be explained here.
 /*
-VS_EXTERNAL_API(void) VapourSynthPluginInit(VSConfigPlugin configFunc, VSRegisterFunction registerFunc, VSPlugin *plugin)
+VS_EXTERNAL_API(void) VapourSynthPluginInit(VSConfigPlugin configFunc,
+VSRegisterFunction registerFunc, VSPlugin *plugin)
 {
-    configFunc("vc.mohan.histo", "cmv", "VapourSynth Histogram Adjuster", VAPOURSYNTH_API_VERSION, 1, plugin);
-    registerFunc("hist", "clip:clip;clipm:clip:opt;type:int:opt;table:int[]:opt;mf:int:opt;window:int:opt;limit:int:opt", histogramadjustCreate, 0, plugin);
+    configFunc("vc.mohan.histo", "cmv", "VapourSynth Histogram Adjuster",
+VAPOURSYNTH_API_VERSION, 1, plugin); registerFunc("hist",
+"clip:clip;clipm:clip:opt;type:int:opt;table:int[]:opt;mf:int:opt;window:int:opt;limit:int:opt",
+histogramadjustCreate, 0, plugin);
 }
 */
diff --git a/modNeural.cpp b/modNeural.cpp
index 2cbf5f8..62884a1 100644
--- a/modNeural.cpp
+++ b/modNeural.cpp
@@ -1,905 +1,867 @@
 
 /************************************************************
 Neural filter plugin for vapoursynth by V.C.Mohan
-Neural filter trains on input clip using a trainer clip first frames, then 
+Neural filter trains on input clip using a trainer clip first frames, then
 processes input frames. Uses Resilient propogation. Linear type.
-In case of RGB only Green channel while YUV formats Y is used for training.  
+In case of RGB only Green channel while YUV formats Y is used for training.
 Author V.C.Mohan
 Aug 26, 2017, Aug 20, 2020
-********************************************************************************/  
-
+********************************************************************************/
 
 typedef struct {
 
-	VSNodeRef *node, *tnode;
-	const VSVideoInfo *vi, *tvi;
+    VSNodeRef *node, *tnode;
+    const VSVideoInfo *vi, *tvi;
+
+    int xpts; // number of points along x axis to be used.. Only odd numbers 1
+              // to 121
+    int ypts; // number of points along y axis to be used. Only odd numbers 1 to
+              // 121
+    int tlx, tty, trx, tby; // trainer clip window coordinates
+
+    int iter; // number of iterations for training
 
-	int xpts;	// number of points along x axis to be used.. Only odd numbers 1 to 121
-	int ypts;	// number of points along y axis to be used. Only odd numbers 1 to 121
-	int tlx, tty, trx, tby;	// trainer clip window coordinates
+    bool wset; // wset  New set of random numbers start
+    int best;  // use best weights out of this number of different starting
+               // weights
 
-	int iter;	// number of iterations for training
+    int rgb; // color to use in training 0 for red, 1 for green, 2 for blue;
 
-	bool wset;	// wset  New set of random numbers start 
-	int best;	// use best weights out of this number of different starting weights
-	
-	int rgb;	// color to use in training 0 for red, 1 for green, 2 for blue;
-	
-	float *weights;	// weights		
-	int inodes;	//	(xpts*ypts+1)
-	float bias;
+    float *weights; // weights
+    int inodes;     //	(xpts*ypts+1)
+    float bias;
 
-	char txt[8];
-	char  filename[200];	// file to be read or saved
+    char txt[8];
+    char filename[200]; // file to be read or saved
 
 } NeuralData;
 
 //--------------------------------------------------------
 
-	template <typename finc>
-	void getcase(const finc * fp, int * offsets, float * input, int nodes);
-	template <typename finc>
-	finc clampval(const float val, finc min, finc max);
-	float	getOutput(float * input, int inodes, float * weights);
-	int sign(float val);
-	void adjustWeights(float *dwtold, float *dwtnew, float * delta, float * deltaw, float * weights, int inodes,
-		float deltamin, float deltamax, float yetaminus, float yetaplus);
-	void sumdedwt(float err, float *dwtnew, float * input, int inodes);
-	
-	int filloffsets(int pitch, int kb, int * offsets, int xpts, int ypts);
-	
-
- //---------------------------------------------------------------------------------
-// This function is called immediately after vsapi->createFilter(). This is the only place where the video
-// properties may be set. In this case we simply use the same as the input clip. You may pass an array
-// of VSVideoInfo if the filter has more than one output, like rgb+alpha as two separate clips.
-static void VS_CC neuralInit
-(VSMap *in, VSMap *out, void **instanceData,
-VSNode *node, VSCore *core, const VSAPI *vsapi)
-{
-	NeuralData *d = (NeuralData *)* instanceData;
-	vsapi->setVideoInfo(d->vi, 1, node);
-	
-	if (strcmp(d->txt, "read") != 0)
-	{
-		//vsapi->setVideoInfo(d->tvi, 1, node);
-
-		d->inodes = d->xpts* d->ypts + 1;
-		d->bias = 1.0; // / xpts;	// arbitrarily selected
-		float deltamax = 5.0f * 0.001f;
-		float deltamin = exp(-6.0f) * 0.001f;
-		float yetaplus = 1.2f;
-		float yetaminus = 0.5f;
-
-		const VSFrameRef *src = vsapi->getFrame(0, d->node, NULL, NULL);
-		const VSFrameRef *trf = vsapi->getFrame(0, d->tnode, NULL, NULL);
-
-		const VSFormat *fi = d->vi->format;
-		int plane = fi->colorFamily == cmRGB ? 2 - d->rgb : 0;
-
-		const uint8_t *srcp = vsapi->getReadPtr(src, plane);
-		int src_stride = vsapi->getStride(src, plane);
-		const uint8_t *tp = vsapi->getReadPtr(trf, plane);
-		int t_stride = vsapi->getStride(trf, plane);
-		int bht = vsapi->getFrameHeight(src, plane);
-		int bwd = vsapi->getFrameWidth(src, plane);
-		int nbytes = fi->bytesPerSample;
-		int spitch = src_stride / nbytes;
-		int tpitch = t_stride / nbytes;
-		int nbits = fi->bitsPerSample;
-		// number of points available to train in each iteration
-		int xcases = (d->trx - d->tlx - d->xpts + 1);	// along x 
-		int ycases = (d->tby - d->tty - d->ypts + 1);	// along y
-		int cases = xcases*ycases;				// total points to train for each iteration
-		int inodes = d->inodes;
-		d->weights = new float[inodes];		// buffer to hold layer weights and   bias
-		int * offsets = new int[d->xpts * d->ypts];	// offsets from central point for each of Xpts X ypts around it
-		float *buf = new float[d->inodes * 6];
-		float *whcopy = buf;		// buffer to hold best  layer weights plus  bias
-		float *dedwt1 = whcopy + inodes;		// changing wts
-		float *dedwt2 = dedwt1 + inodes;
-		float *deltaw = dedwt2 + inodes;
-		float *delta = deltaw + inodes;
-		float *input = delta + inodes;	// buffer to hold input plus one bias node
-		bool save = false;
-		float *sumerr = NULL;
-		if (strcmp(d->txt, "save") == 0)
-		{
-			// create buffer to show error for each iteration
-
-			sumerr = new float[d->best * d->iter];
-			save = true;
-		}
-
-		time_t seed;
-		// use time for seeding random numbers if wset is true. Else use standard system generated
-		if (d->wset)
-		{
-			time(&seed);
-			srand((seed & 0xfffe) + 1);
-		}
-		else
-		{
-			srand(1);
-		}
-		// generate offsets table
-		filloffsets(spitch, 1, offsets, d->xpts, d->ypts);
-
-		float hf = 0.001f / d->inodes;	// arbitrary value for scaling of random weights
-		input[d->inodes - 1] = d->bias; // bias value. remains same for all cases
-		int best, niter;
-		float minesum;
-
-		for (int b = 0; b < d->best; b++)
-		{
-			for (int i = 0; i < d->inodes; i++)
-			{
-				// input layer weights between -0.5hf and 0.5hf
-				d->weights[i] = (((float)rand()) / RAND_MAX - 0.5) * hf;
-				// initialize buffers
-				delta[i] = deltamin;
-				deltaw[i] = 0;
-				dedwt1[i] = 0;
-			}
-
-
-			// for toggling buffers for each iteration
-			float *dedwtnew, *dedwtold;
-			float esum;	// minimum sum of errors
-
-			for (int i = 0; i < d->iter; i++)
-			{
-				if ((i & 1) == 0)
-				{
-					// toggle buffers for each odd number of iteration
-					dedwtold = dedwt1;
-					dedwtnew = dedwt2;
-				}
-				else
-				{
-					// toggle buffers at each even number of iteration
-					dedwtold = dedwt2;
-					dedwtnew = dedwt1;
-				}
-
-				esum = 0.0;	// initialize error squared sum
-
-				float output, error;
-				// zero de/dw buffer
-				for (int nodes = 0; nodes < d->inodes; nodes++)
-				{
-					dedwtnew[nodes] = 0;
-				}
-
-				// trainer frame ptr and input frame ptrs are to point center of the first rectangle
-				const uint8_t * trp = tp + (d->tty + d->ypts / 2) * t_stride + (d->tlx + d->xpts / 2) * nbytes;
-				const uint8_t * srp = srcp + (d->tty + d->ypts / 2) * src_stride + (d->tlx + d->xpts / 2) * nbytes;
-				// for each input point at center of square find output and sum error square
-
-				for (int h = 0; h < ycases; h++)
-				{
-					for (int w = 0; w < xcases; w++)
-					{
-						if (nbytes == 1)
-						{
-							// get next case for training
-							getcase(srp + w, offsets, input, d->inodes - 1);		// got  input data and bias in input buffer
-							// using current weights get output
-							output = getOutput(input, d->inodes, d->weights);
-							// error for this point using current weights
-							error = *(trp + w) - output;	// error of estimation
-						}
-						else if (nbytes == 2)
-						{
-							getcase((uint16_t*)srp + w, offsets, input, d->inodes - 1);
-
-							output = getOutput(input, d->inodes, d->weights);
-
-							error = *((uint16_t*)trp + w) - output;
-
-						}
-						else if (nbytes == 4)
-						{
-							// get next case for training						 
-							getcase((float*)srp + w, offsets, input, d->inodes - 1);
-
-							output = getOutput(input, d->inodes, d->weights);
-
-							error = *((float*)trp + w) - output;
-						}
-
-						esum += error*error;
-						sumdedwt(error, dedwtnew, input, d->inodes);
-
-						
-					}					
-
-					
-
-					srp += src_stride;
-					trp += t_stride;
-				}
-
-				if (save)
-					sumerr[b * d->iter + i] = esum;
-
-				if (i == 0 && b == 0)
-				{
-					// esum is now error squared sum for first iteration 
-					minesum = esum;	// to get minimum error point
-
-					// in unlikely case first weights are optimum weights
-					for (int nodes = 0; nodes < d->inodes; nodes++)
-						whcopy[nodes] = d->weights[nodes];
-				}
-
-				if (minesum > esum)
-				{
-					for (int nodes = 0; nodes < d->inodes; nodes++)
-						whcopy[nodes] = d->weights[nodes];
-
-					minesum = esum;
-					best = b;
-					niter = i;
-				}
+template <typename finc>
+void getcase(const finc *fp, int *offsets, float *input, int nodes);
+template <typename finc> finc clampval(const float val, finc min, finc max);
+float getOutput(float *input, int inodes, float *weights);
+int sign(float val);
+void adjustWeights(float *dwtold, float *dwtnew, float *delta, float *deltaw,
+                   float *weights, int inodes, float deltamin, float deltamax,
+                   float yetaminus, float yetaplus);
+void sumdedwt(float err, float *dwtnew, float *input, int inodes);
+
+int filloffsets(int pitch, int kb, int *offsets, int xpts, int ypts);
+
+//---------------------------------------------------------------------------------
+// This function is called immediately after vsapi->createFilter(). This is the
+// only place where the video properties may be set. In this case we simply use
+// the same as the input clip. You may pass an array of VSVideoInfo if the
+// filter has more than one output, like rgb+alpha as two separate clips.
+static void VS_CC neuralInit(VSMap *in, VSMap *out, void **instanceData,
+                             VSNode *node, VSCore *core, const VSAPI *vsapi) {
+    NeuralData *d = (NeuralData *) *instanceData;
+    vsapi->setVideoInfo(d->vi, 1, node);
+
+    if(strcmp(d->txt, "read") != 0) {
+        // vsapi->setVideoInfo(d->tvi, 1, node);
+
+        d->inodes = d->xpts * d->ypts + 1;
+        d->bias = 1.0; // / xpts;	// arbitrarily selected
+        float deltamax = 5.0f * 0.001f;
+        float deltamin = exp(-6.0f) * 0.001f;
+        float yetaplus = 1.2f;
+        float yetaminus = 0.5f;
+
+        // Warning
+        // const VSFrameRef *src = vsapi->getFrame(0, d->node, NULL, NULL);
+        // const VSFrameRef *trf = vsapi->getFrame(0, d->tnode, NULL, NULL);
+
+        // Fix
+        const VSFrameRef *src = vsapi->getFrame(0, d->node, NULL, 0);
+        const VSFrameRef *trf = vsapi->getFrame(0, d->tnode, NULL, 0);
+
+        const VSFormat *fi = d->vi->format;
+        int plane = fi->colorFamily == cmRGB ? 2 - d->rgb : 0;
+
+        const uint8_t *srcp = vsapi->getReadPtr(src, plane);
+        int src_stride = vsapi->getStride(src, plane);
+        const uint8_t *tp = vsapi->getReadPtr(trf, plane);
+        int t_stride = vsapi->getStride(trf, plane);
+        int bht = vsapi->getFrameHeight(src, plane);
+        int bwd = vsapi->getFrameWidth(src, plane);
+        int nbytes = fi->bytesPerSample;
+        int spitch = src_stride / nbytes;
+        int tpitch = t_stride / nbytes;
+        int nbits = fi->bitsPerSample;
+        // number of points available to train in each iteration
+        int xcases = (d->trx - d->tlx - d->xpts + 1); // along x
+        int ycases = (d->tby - d->tty - d->ypts + 1); // along y
+        int cases = xcases * ycases; // total points to train for each iteration
+        int inodes = d->inodes;
+        d->weights = new float[inodes]; // buffer to hold layer weights and bias
+        int *offsets =
+            new int[d->xpts * d->ypts]; // offsets from central point for each
+                                        // of Xpts X ypts around it
+        float *buf = new float[d->inodes * 6];
+        float *whcopy = buf; // buffer to hold best  layer weights plus  bias
+        float *dedwt1 = whcopy + inodes; // changing wts
+        float *dedwt2 = dedwt1 + inodes;
+        float *deltaw = dedwt2 + inodes;
+        float *delta = deltaw + inodes;
+        float *input =
+            delta + inodes; // buffer to hold input plus one bias node
+        bool save = false;
+        float *sumerr = NULL;
+        if(strcmp(d->txt, "save") == 0) {
+            // create buffer to show error for each iteration
+
+            sumerr = new float[d->best * d->iter];
+            save = true;
+        }
+
+        time_t seed;
+        // use time for seeding random numbers if wset is true. Else use
+        // standard system generated
+        if(d->wset) {
+            time(&seed);
+            srand((seed & 0xfffe) + 1);
+        } else {
+            srand(1);
+        }
+        // generate offsets table
+        filloffsets(spitch, 1, offsets, d->xpts, d->ypts);
+
+        float hf =
+            0.001f / d->inodes; // arbitrary value for scaling of random weights
+        input[d->inodes - 1] =
+            d->bias; // bias value. remains same for all cases
+        int best, niter;
+        float minesum;
+
+        for(int b = 0; b < d->best; b++) {
+            for(int i = 0; i < d->inodes; i++) {
+                // input layer weights between -0.5hf and 0.5hf
+                d->weights[i] = (((float) rand()) / RAND_MAX - 0.5) * hf;
+                // initialize buffers
+                delta[i] = deltamin;
+                deltaw[i] = 0;
+                dedwt1[i] = 0;
+            }
+
+            // for toggling buffers for each iteration
+            float *dedwtnew, *dedwtold;
+            float esum; // minimum sum of errors
+
+            for(int i = 0; i < d->iter; i++) {
+                if((i & 1) == 0) {
+                    // toggle buffers for each odd number of iteration
+                    dedwtold = dedwt1;
+                    dedwtnew = dedwt2;
+                } else {
+                    // toggle buffers at each even number of iteration
+                    dedwtold = dedwt2;
+                    dedwtnew = dedwt1;
+                }
+
+                esum = 0.0; // initialize error squared sum
+
+                float output, error;
+                // zero de/dw buffer
+                for(int nodes = 0; nodes < d->inodes; nodes++) {
+                    dedwtnew[nodes] = 0;
+                }
+
+                // trainer frame ptr and input frame ptrs are to point center of
+                // the first rectangle
+                const uint8_t *trp = tp + (d->tty + d->ypts / 2) * t_stride +
+                                     (d->tlx + d->xpts / 2) * nbytes;
+                const uint8_t *srp = srcp +
+                                     (d->tty + d->ypts / 2) * src_stride +
+                                     (d->tlx + d->xpts / 2) * nbytes;
+                // for each input point at center of square find output and sum
+                // error square
+
+                for(int h = 0; h < ycases; h++) {
+                    for(int w = 0; w < xcases; w++) {
+                        if(nbytes == 1) {
+                            // get next case for training
+                            getcase(srp + w, offsets, input,
+                                    d->inodes - 1); // got  input data and bias
+                                                    // in input buffer
+                            // using current weights get output
+                            output = getOutput(input, d->inodes, d->weights);
+                            // error for this point using current weights
+                            error = *(trp + w) - output; // error of estimation
+                        } else if(nbytes == 2) {
+                            getcase((uint16_t *) srp + w, offsets, input,
+                                    d->inodes - 1);
+
+                            output = getOutput(input, d->inodes, d->weights);
+
+                            error = *((uint16_t *) trp + w) - output;
+
+                        } else if(nbytes == 4) {
+                            // get next case for training
+                            getcase((float *) srp + w, offsets, input,
+                                    d->inodes - 1);
+
+                            output = getOutput(input, d->inodes, d->weights);
+
+                            error = *((float *) trp + w) - output;
+                        }
+
+                        esum += error * error;
+                        sumdedwt(error, dedwtnew, input, d->inodes);
+                    }
+
+                    srp += src_stride;
+                    trp += t_stride;
+                }
+
+                if(save)
+                    sumerr[b * d->iter + i] = esum;
+
+                if(i == 0 && b == 0) {
+                    // esum is now error squared sum for first iteration
+                    minesum = esum; // to get minimum error point
+
+                    // in unlikely case first weights are optimum weights
+                    for(int nodes = 0; nodes < d->inodes; nodes++)
+                        whcopy[nodes] = d->weights[nodes];
+                }
+
+                if(minesum > esum) {
+                    for(int nodes = 0; nodes < d->inodes; nodes++)
+                        whcopy[nodes] = d->weights[nodes];
+
+                    minesum = esum;
+                    best = b;
+                    niter = i;
+                }
+
+                // adjust weights so that output value comes  closer to desired
+                // value
+                adjustWeights(dedwtold, dedwtnew, delta, deltaw, d->weights,
+                              d->inodes, deltamin, deltamax, yetaminus,
+                              yetaplus);
+
+            } // iterations
+
+        } // best of
+
+        for(int nodes = 0; nodes < inodes; nodes++) {
+            d->weights[nodes] = whcopy[nodes];
+        }
+        delete[] buf;
+        delete[] offsets;
+        vsapi->freeFrame(src);
+        vsapi->freeFrame(trf);
+
+        // training end
 
-				// adjust weights so that output value comes  closer to desired value
-				adjustWeights(dedwtold, dedwtnew, delta, deltaw, d->weights, d->inodes,
-					deltamin, deltamax, yetaminus, yetaplus);
-	
-			}	// iterations
+        if(strcmp(d->txt, "save") == 0) {
 
-		}	// best of
+            std::ofstream ofile;
+            ofile.open(d->filename);
 
-		for (int nodes = 0; nodes < inodes; nodes++)
-		{
-			d->weights[nodes] = whcopy[nodes];
-		}
-		delete[]buf;
-		delete[]offsets;
-		vsapi->freeFrame(src);
-		vsapi->freeFrame(trf);
+            if(!ofile.is_open()) {
+                vsapi->setError(out, "Neural: Could not open output file");
+                vsapi->freeNode(d->node);
+                vsapi->freeNode(d->tnode);
+                return;
+            }
 
-		// training end
+            char nl = '\n';
 
-		if (strcmp(d->txt, "save") == 0)
-		{
-			
-			std::ofstream ofile;
-			ofile.open(d->filename);
+            // Warning
+            // char * title = "vcMod_Neural_xpts_ypts_inodes_and_Weights";
+            // Fix
+            const char *title = "vcMod_Neural_xpts_ypts_inodes_and_Weights";
 
-			if (!ofile.is_open())
-			{
-				vsapi->setError(out, "Neural: Could not open output file");
-				vsapi->freeNode(d->node);
-				vsapi->freeNode(d->tnode);
-				return;
-			}
+            ofile << title << nl;
 
-			char nl = '\n';
+            char space = ' ';
 
-			char * title = "vcMod_Neural_xpts_ypts_inodes_and_Weights";
+            if(fi->colorFamily == cmRGB)
+                ofile << "RGB";
+            else if(fi->colorFamily == cmYUV)
+                ofile << "YUV";
+            else
+                ofile << "GREY";
 
-			ofile << title << nl;
+            ofile << space << "bitdepth" << space << nbits << nl;
 
-			char space = ' ';
+            // ofile << "pixel_type" << space << vi.pixel_type << nl;
 
-			if (fi->colorFamily == cmRGB)
-				ofile << "RGB";
-			else if(fi->colorFamily == cmYUV)
-				ofile << "YUV"; 
-			else
-				ofile << "GREY";	
+            ofile << d->xpts << space << d->ypts << space << d->inodes
+                  << nl; // weights includes bias
+            ofile << "bias" << space << d->bias << nl;
 
-			ofile << space << "bitdepth" << space << nbits << nl;
+            int count = 0;
 
-			// ofile << "pixel_type" << space << vi.pixel_type << nl;
+            for(int i = 0; i < d->inodes; i++) {
 
-			ofile << d->xpts << space << d->ypts << space << d->inodes << nl; // weights includes bias
-			ofile << "bias" << space << d->bias << nl;
+                ofile << d->weights[i] << nl; // float value of weight
+            }
 
+            ofile << "Time Stamp" << nl;
+            time_t timeStamp;
+            time(&timeStamp);
+            ofile << timeStamp << nl;
 
-			int count = 0;
+            ofile << "minimum_esum " << minesum << " at_iter " << niter
+                  << " at_weight_set_no: " << best << " for " << cases
+                  << " training points" << nl;
 
-			for (int i = 0; i < d->inodes; i++)
-			{
+            ofile << "error_sum_at_each_iteration" << nl;
 
-				ofile << d->weights[i] << nl;		// float value of weight
+            int in = 0;
 
+            for(int bi = 0; bi < d->best * d->iter; bi++) {
+                if((bi % d->iter) == 0) {
+                    ofile << nl << "with_weight_set_No:" << bi / d->iter << nl;
+                    in = 0;
+                }
 
-			}
+                if((in % 20) == 0) {
+                    ofile << nl << "error_sums_at" << "iter:" << in << "to"
+                          << space << in + 19 << ":-";
+                }
 
-			ofile << "Time Stamp" << nl;
-			time_t timeStamp;
-			time(&timeStamp);
-			ofile << timeStamp << nl;
+                if((in % 5) == 0) {
+                    ofile << nl;
+                }
 
-			ofile << "minimum_esum " << minesum << " at_iter " << niter << " at_weight_set_no: " << best
-				<< " for " << cases << " training points" << nl;
+                ofile << sumerr[bi] << space;
+                in++;
+            }
 
-			ofile << "error_sum_at_each_iteration" << nl;
+            ofile.close();
 
-			int in = 0;
+            delete[] sumerr;
+        }
+    }
 
-			for (int bi = 0; bi < d->best * d->iter; bi ++)
-			{
-				if ((bi % d->iter) == 0)
-				{
-					ofile << nl << "with_weight_set_No:" << bi / d->iter << nl;
-					in = 0;
-				}
+    else // read from file
+    {
+        std::ifstream ifile;
 
-				if ((in % 20) == 0)
-				{
-					ofile  << nl <<"error_sums_at" << "iter:" << in << "to" << space << in + 19 << ":-" ;
+        ifile.open(d->filename);
 
-				}
+        if(!ifile.is_open()) {
+            vsapi->setError(out, "Neural: Could not open input file");
+            vsapi->freeNode(d->node);
+            return;
+        }
 
-				if ((in % 5) == 0)
-				{
-					ofile << nl;
-				}
+        const VSFormat *fi = d->vi->format;
 
-				ofile << sumerr[bi] << space;
-				in++;
+        // Warning
+        // char * title = "vcMod_Neural_xpts_ypts_inodes_and_Weights";
+        // Fix
+        const char *title = "vcMod_Neural_xpts_ypts_inodes_and_Weights";
+        char buf[256];
+        buf[255] = '\0';
 
-			}
+        ifile >> buf;
 
-			ofile.close();
+        if(strcmp(buf, title) != 0) {
+            ifile.close();
+            vsapi->setError(out, "Neural: Incorrect input file");
+            vsapi->freeNode(d->node);
+            return;
+        }
 
-			delete[]sumerr;
-		}
-	}
+        int bitdepth;
 
-	else	// read from file
-	{
-		std::ifstream ifile;
-		
-		ifile.open(d->filename);
+        ifile >> buf;
 
-		if (!ifile.is_open())
-		{
-			vsapi->setError(out, "Neural: Could not open input file");
-			vsapi->freeNode(d->node);
-			return;
-		}
+        if((strcmp(buf, "RGB") == 0 && fi->colorFamily != cmRGB))
+        //	|| (strcmp(buf, "YUV") == 0 && fi->colorFamily != cmYUV)
+        //	|| (strcmp(buf, "GREY") == 0 && fi->colorFamily != cmGray)
 
-		const VSFormat *fi = d->vi->format;
+        {
 
+            ifile.close();
+            vsapi->setError(out,
+                            "Neural: input file was for different colorFamily");
+            vsapi->freeNode(d->node);
+            return;
+        }
+        ifile >> buf >> bitdepth;
 
-		char * title = "vcMod_Neural_xpts_ypts_inodes_and_Weights";
-		char buf[256];
-		buf[255] = '\0';
+        if(bitdepth != fi->bitsPerSample) {
+            ifile.close();
+            vsapi->setError(out,
+                            "Neural: input file was for different  bit depth");
+            vsapi->freeNode(d->node);
+            return;
+        }
 
-		ifile >> buf;
+        int npoints = 0;
+        ifile >> d->xpts >> d->ypts >> d->inodes >> buf >> d->bias;
 
-		if (strcmp(buf, title) != 0)
-		{
-			ifile.close();
-			vsapi->setError(out, "Neural: Incorrect input file");
-			vsapi->freeNode(d->node);
-			return;
-		}
+        if(d->xpts * d->ypts < 9 || d->xpts * d->ypts > 225 ||
+           ((d->xpts * d->ypts) & 1) == 0 ||
+           d->xpts * d->ypts + 1 != d->inodes) {
+            ifile.close();
+            vsapi->setError(out, "Neural: input file is corrupted");
+            vsapi->freeNode(d->node);
+            return;
+        }
 
-		int bitdepth;
+        d->weights = new float[d->inodes];
 
-		ifile >> buf;
-		
+        int count = 0;
 
-		if ((strcmp(buf, "RGB") == 0 && fi->colorFamily != cmRGB))
-		//	|| (strcmp(buf, "YUV") == 0 && fi->colorFamily != cmYUV)
-		//	|| (strcmp(buf, "GREY") == 0 && fi->colorFamily != cmGray)
-		
-		{
+        for(int i = 0; i < d->inodes && !ifile.eof(); i++) {
+
+            ifile >> d->weights[i]; // float value of weight
+
+            count++;
+        }
 
-			ifile.close();
-			vsapi->setError(out, "Neural: input file was for different colorFamily");
-			vsapi->freeNode(d->node);
-			return;
+        if(count != d->inodes) {
+            ifile.close();
+            vsapi->setError(out, "Neural: input file has fewer weights");
+            delete[] d->weights;
+            vsapi->freeNode(d->node);
+            return;
+        }
 
-		}
-		ifile >> buf >> bitdepth;
-
-		if (bitdepth != fi->bitsPerSample)
-		{
-			ifile.close();
-			vsapi->setError(out, "Neural: input file was for different  bit depth");
-			vsapi->freeNode(d->node);
-			return;
-		}
-
-
-		int npoints = 0;
-		ifile >> d->xpts >> d->ypts >> d->inodes >>buf >> d->bias;
-		
-
-		if (d->xpts * d->ypts < 9 || d->xpts * d->ypts > 225 || ((d->xpts * d->ypts) & 1) == 0 || d->xpts * d->ypts + 1 != d->inodes)
-		{
-			ifile.close();
-			vsapi->setError(out, "Neural: input file is corrupted");
-			vsapi->freeNode(d->node);
-			return;
-		}
-
-		d->weights = new float[d->inodes];
-
-		int count = 0;
-
-		for (int i = 0; i < d->inodes && !ifile.eof(); i++)
-		{
-
-			ifile >> d->weights[i];		// float value of weight
-
-			count++;
-		}
-
-		if (count != d->inodes)
-		{
-			ifile.close();
-			vsapi->setError(out, "Neural: input file has fewer weights");
-			delete[] d->weights;
-			vsapi->freeNode(d->node);
-			return;
-		}
-
-		ifile.close();
-	}
-
-	
- }
-
-/***************************************************************/	
- //---------------------------------------------------------------------------------	
-
- // This is the main function that gets called when a frame should be produced. It will in most cases get
- // called several times to produce one frame. This state is being kept track of by the value of
- // activationReason. The first call to produce a certain frame n is always arInitial. In this state
- // you should request all input frames you need. Always do it i ascending order to play nice with the
- // upstream filters.
- // Once all frames are ready the the filter will be called with arAllFramesReady. It is now time to
- // do the actual processing.
- static const VSFrameRef *VS_CC neuralGetFrame
-	 (int n, int activationReason, void **instanceData,
-	 void **frameData, VSFrameContext *frameCtx,
-	 VSCore *core, const VSAPI *vsapi)
- {
-	NeuralData *d = (NeuralData *)* instanceData;
-
-	 if (activationReason == arInitial)
-	 {
-		 // Request the source frame on the first call
-		 vsapi->requestFrameFilter(n, d->node, frameCtx);
-	 }
-	 else if (activationReason == arAllFramesReady)
-	 {
-		 const VSFrameRef *src = vsapi->getFrameFilter(n, d->node, frameCtx);
-		 // The reason we query this on a per frame basis is because we want our filter
-		 // to accept clips with varying dimensions. If we reject such content using d->vi
-		 // would be better.
-		 const VSFormat *fi = d->vi->format;
-
-		 // When creating a new frame for output it is VERY EXTREMELY SUPER IMPORTANT to
-		 // supply the "dominant" source frame to copy properties from. Frame props
-		 // are an essential part of the filter chain and you should NEVER break it.
-		 VSFrameRef * dst = vsapi->copyFrame(src, core);
-	//	 int * off = (int*)vs_aligned_malloc((size_t)(d->inodes * sizeof(int)), (size_t)32);
-	//	 float * input = (float*)vs_aligned_malloc((size_t)(d->inodes * sizeof(float)), (size_t)64);
-
-		 // get memory from vs and not from system
-		 VSFrameRef *buf = vsapi->newVideoFrame(fi, d->inodes * (sizeof(int) + sizeof(float)), 1, src, core);
-		 uint8_t *bp = vsapi->getWritePtr(buf, 0);
-		 float * input = (float *)bp;
-
-		 int * offs = (int*)(input + d->inodes );
-
-		 int np = fi->colorFamily == cmRGB ? 3 : 1;
-			 
-		 // It's processing loop time!
-		 // Loop over all the planes
-
-		 for (int plane = 0; plane < np; plane++)
-		 {
-
-			 const uint8_t *sp = vsapi->getReadPtr(src, plane);
-			 int src_stride = vsapi->getStride(src, plane);
-			 uint8_t *dp = vsapi->getWritePtr(dst, plane);
-			 int dst_stride = vsapi->getStride(dst, plane);
-			 int bht = vsapi->getFrameHeight(src, plane);
-			 int bwd = vsapi->getFrameWidth(src, plane);
-			 int nbytes = fi->bytesPerSample;
-			 int spitch = src_stride / nbytes;
-			 int dpitch = dst_stride / nbytes;
-			 int nbits = fi->bitsPerSample;
-			 
-
-			 if (plane == 0)
-			 {
-				 filloffsets(spitch, 1, offs, d->xpts, d->ypts);
-			 }
-
-
-			 input[d->inodes - 1] = d->bias;		// bias
-			 // process regular 		
-
-			 sp += (d->ypts / 2) * src_stride;
-			 dp += (d->ypts / 2) * dst_stride;
-
-			 for (int h = d->ypts / 2; h < bht - d->ypts / 2 - 1; h++)
-			 {
-				 //int kbw = kb * (xpts / 2);
-
-				 for (int w = d->xpts / 2; w < bwd - d->xpts / 2 - 1; w++)
-				 {
-					 if (nbytes == 1)
-					 {
-						 // get input data + bias in input buffer
-						 getcase(sp + w, offs, input, d->inodes - 1);
-
-						 float output = getOutput(input, d->inodes, d->weights);
-						 unsigned char min = 0, max = 255;
-						 *(dp + w) = clampval(output, min, max);
-					 }
-					 if (nbytes == 2)
-					 {
-						 // get input data + bias in input buffer
-						 getcase((uint16_t*)sp + w, offs, input, d->inodes - 1);
-
-						 float output = getOutput(input, d->inodes, d->weights);
-
-						 uint16_t min = 0, max = (1 << nbits) - 1;
-
-						 *((uint16_t*)dp + w) = clampval(output, min, max);
-
-					 }
-					 if (nbytes == 4)
-					 {
-						 // get input data + bias in input buffer
-						 getcase((float*)sp + w, offs, input, d->inodes - 1);
-
-						 float output = getOutput(input,  d->inodes, d->weights);
-
-						 float min = 0, max = 1.0f;
-
-						 *((float*)dp + w) = clampval(output, min, max);
-					 }
-
-					 // kbw += kb;
-				 }
-
-				 dp += dst_stride;
-				 sp += src_stride;
-
-			 }
-		 }
-		 
-		 vsapi->freeFrame(buf);
-		 vsapi->freeFrame(src);
-
-		 return dst;
-	 }
-	 return 0;
+        ifile.close();
+    }
+}
+
+/***************************************************************/
+//---------------------------------------------------------------------------------
+
+// This is the main function that gets called when a frame should be produced.
+// It will in most cases get called several times to produce one frame. This
+// state is being kept track of by the value of activationReason. The first call
+// to produce a certain frame n is always arInitial. In this state you should
+// request all input frames you need. Always do it i ascending order to play
+// nice with the upstream filters. Once all frames are ready the the filter will
+// be called with arAllFramesReady. It is now time to do the actual processing.
+static const VSFrameRef *VS_CC neuralGetFrame(
+    int n, int activationReason, void **instanceData, void **frameData,
+    VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) {
+    NeuralData *d = (NeuralData *) *instanceData;
+
+    if(activationReason == arInitial) {
+        // Request the source frame on the first call
+        vsapi->requestFrameFilter(n, d->node, frameCtx);
+    } else if(activationReason == arAllFramesReady) {
+        const VSFrameRef *src = vsapi->getFrameFilter(n, d->node, frameCtx);
+        // The reason we query this on a per frame basis is because we want our
+        // filter to accept clips with varying dimensions. If we reject such
+        // content using d->vi would be better.
+        const VSFormat *fi = d->vi->format;
+
+        // When creating a new frame for output it is VERY EXTREMELY SUPER
+        // IMPORTANT to supply the "dominant" source frame to copy properties
+        // from. Frame props are an essential part of the filter chain and you
+        // should NEVER break it.
+        VSFrameRef *dst = vsapi->copyFrame(src, core);
+        //	 int * off = (int*)vs_aligned_malloc((size_t)(d->inodes *
+        //sizeof(int)), (size_t)32); 	 float * input =
+        //(float*)vs_aligned_malloc((size_t)(d->inodes * sizeof(float)),
+        //(size_t)64);
+
+        // get memory from vs and not from system
+        VSFrameRef *buf = vsapi->newVideoFrame(
+            fi, d->inodes * (sizeof(int) + sizeof(float)), 1, src, core);
+        uint8_t *bp = vsapi->getWritePtr(buf, 0);
+        float *input = (float *) bp;
+
+        int *offs = (int *) (input + d->inodes);
+
+        int np = fi->colorFamily == cmRGB ? 3 : 1;
+
+        // It's processing loop time!
+        // Loop over all the planes
+
+        for(int plane = 0; plane < np; plane++) {
+
+            const uint8_t *sp = vsapi->getReadPtr(src, plane);
+            int src_stride = vsapi->getStride(src, plane);
+            uint8_t *dp = vsapi->getWritePtr(dst, plane);
+            int dst_stride = vsapi->getStride(dst, plane);
+            int bht = vsapi->getFrameHeight(src, plane);
+            int bwd = vsapi->getFrameWidth(src, plane);
+            int nbytes = fi->bytesPerSample;
+            int spitch = src_stride / nbytes;
+            int dpitch = dst_stride / nbytes;
+            int nbits = fi->bitsPerSample;
+
+            if(plane == 0) {
+                filloffsets(spitch, 1, offs, d->xpts, d->ypts);
+            }
+
+            input[d->inodes - 1] = d->bias; // bias
+            // process regular
+
+            sp += (d->ypts / 2) * src_stride;
+            dp += (d->ypts / 2) * dst_stride;
+
+            for(int h = d->ypts / 2; h < bht - d->ypts / 2 - 1; h++) {
+                // int kbw = kb * (xpts / 2);
+
+                for(int w = d->xpts / 2; w < bwd - d->xpts / 2 - 1; w++) {
+                    if(nbytes == 1) {
+                        // get input data + bias in input buffer
+                        getcase(sp + w, offs, input, d->inodes - 1);
+
+                        float output = getOutput(input, d->inodes, d->weights);
+                        unsigned char min = 0, max = 255;
+                        *(dp + w) = clampval(output, min, max);
+                    }
+                    if(nbytes == 2) {
+                        // get input data + bias in input buffer
+                        getcase((uint16_t *) sp + w, offs, input,
+                                d->inodes - 1);
+
+                        float output = getOutput(input, d->inodes, d->weights);
+
+                        uint16_t min = 0, max = (1 << nbits) - 1;
+
+                        *((uint16_t *) dp + w) = clampval(output, min, max);
+                    }
+                    if(nbytes == 4) {
+                        // get input data + bias in input buffer
+                        getcase((float *) sp + w, offs, input, d->inodes - 1);
+
+                        float output = getOutput(input, d->inodes, d->weights);
+
+                        float min = 0, max = 1.0f;
+
+                        *((float *) dp + w) = clampval(output, min, max);
+                    }
+
+                    // kbw += kb;
+                }
+
+                dp += dst_stride;
+                sp += src_stride;
+            }
+        }
+
+        vsapi->freeFrame(buf);
+        vsapi->freeFrame(src);
+
+        return dst;
+    }
+    return 0;
 }
 //-------------------------------------------------------------------
 // Free all allocated data on filter destruction
-static void VS_CC neuralFree(void *instanceData, VSCore *core, const VSAPI *vsapi)
-{
-	NeuralData *d = (NeuralData *)instanceData;
-	vsapi->freeNode(d->node);
-	free(d);
+static void VS_CC neuralFree(void *instanceData, VSCore *core,
+                             const VSAPI *vsapi) {
+    NeuralData *d = (NeuralData *) instanceData;
+    vsapi->freeNode(d->node);
+    free(d);
 }
 
 //------------------------------------------------------------------
-template <typename finc>
-finc clampval(const float val, finc min, finc max)
-{
-	return val > max ? max : val < min ? min : val;
+template <typename finc> finc clampval(const float val, finc min, finc max) {
+    return val > max ? max : val < min ? min : val;
 }
 
-
 //---------------------------------------------------------------
- int filloffsets(int fpitch, int kb, int * offsets, int xpts, int ypts)
-{
-	int n = 0;
-	for (int h = -ypts / 2; h <= ypts / 2; h++)
-	{
-		for (int w = -xpts / 2; w <= xpts / 2; w++)
-		{
-			offsets[n] = h * fpitch + w * kb;
-			n++;
-		}
-	}
-	return n;
+int filloffsets(int fpitch, int kb, int *offsets, int xpts, int ypts) {
+    int n = 0;
+    for(int h = -ypts / 2; h <= ypts / 2; h++) {
+        for(int w = -xpts / 2; w <= xpts / 2; w++) {
+            offsets[n] = h * fpitch + w * kb;
+            n++;
+        }
+    }
+    return n;
 }
 //--------------------------------------------------------------
-float getOutput(float * input , int inodes, float * weights)
-{						
-								
-	float sum=0.0;
-	for ( int in=0; in<inodes; in++)
-	{
-		sum+= input[in] * weights[in];
-	}
-	return(sum);								
+float getOutput(float *input, int inodes, float *weights) {
+
+    float sum = 0.0;
+    for(int in = 0; in < inodes; in++) {
+        sum += input[in] * weights[in];
+    }
+    return (sum);
 }
 //-------------------------------------------------------------------------
 template <typename finc>
-void  getcase(const finc * fp, int * offsets, float * input, int nodes)
-{
-	
-	for (int i = 0; i < nodes; i++)
-	{
-		input[i] = fp[offsets[i]];
-	}
+void getcase(const finc *fp, int *offsets, float *input, int nodes) {
 
-	
+    for(int i = 0; i < nodes; i++) {
+        input[i] = fp[offsets[i]];
+    }
 }
 //----------------------------------------------------------------
-void  sumdedwt(float err, float *dwtnew, float * input, int inodes)
-{
-	for ( int in=0; in<inodes; in++)
-	
-		dwtnew[in]-= err*input[in];
+void sumdedwt(float err, float *dwtnew, float *input, int inodes) {
+    for(int in = 0; in < inodes; in++)
+
+        dwtnew[in] -= err * input[in];
 }
 
 //------------------------------------------------------------------------------------------------------
 
-void  adjustWeights(float *dwtold, float *dwtnew, float * delta, float * deltaw, float * weights, int inodes,
-	float deltamin, float deltamax, float yetaminus, float yetaplus)
-{
-	// resilient propogation
-
-	for (int hn = 0; hn<inodes; hn++)
-	{
-
-		if (dwtold[hn] * dwtnew[hn] >0)
-		{	// the de/dwt has not changed sign
+void adjustWeights(float *dwtold, float *dwtnew, float *delta, float *deltaw,
+                   float *weights, int inodes, float deltamin, float deltamax,
+                   float yetaminus, float yetaplus) {
+    // resilient propogation
 
-			// use minimum of (deltamax and delta[]*yetaplus)
-			delta[hn] = deltamax < delta[hn] * yetaplus ?
-			deltamax : delta[hn] * yetaplus;
-			// sign(val) returns -1, 0 or +1 based on val sign)
-			deltaw[hn] = -sign(dwtnew[hn])* delta[hn];
+    for(int hn = 0; hn < inodes; hn++) {
 
-			weights[hn] += deltaw[hn];
-		}
+        if(dwtold[hn] * dwtnew[hn] > 0) { // the de/dwt has not changed sign
 
-		else if (dwtold[hn] * dwtnew[hn] <0)
-		{
-			// de/dwt has changed sign
-			// use max of ( deltamin and delta[]*yetaminus)
-			delta[hn] = deltamin >= delta[hn] * yetaminus ?
-			deltamin : delta[hn] * yetaminus;
-			weights[hn] -= deltaw[hn];// go back to prev value as we over stepped a minimum
+            // use minimum of (deltamax and delta[]*yetaplus)
+            delta[hn] = deltamax < delta[hn] * yetaplus ? deltamax
+                                                        : delta[hn] * yetaplus;
+            // sign(val) returns -1, 0 or +1 based on val sign)
+            deltaw[hn] = -sign(dwtnew[hn]) * delta[hn];
 
-			dwtnew[hn] = 0;	// to ensure that next iter when we come to this function  no update of this weight occurs
+            weights[hn] += deltaw[hn];
+        }
 
+        else if(dwtold[hn] * dwtnew[hn] < 0) {
+            // de/dwt has changed sign
+            // use max of ( deltamin and delta[]*yetaminus)
+            delta[hn] = deltamin >= delta[hn] * yetaminus
+                            ? deltamin
+                            : delta[hn] * yetaminus;
+            weights[hn] -= deltaw[hn]; // go back to prev value as we over
+                                       // stepped a minimum
 
-		}
+            dwtnew[hn] = 0; // to ensure that next iter when we come to this
+                            // function  no update of this weight occurs
 
-		else // zero
-		{
-			deltaw[hn] = -sign(dwtnew[hn]) * delta[hn];
+        }
 
-			weights[hn] += deltaw[hn];
-		}
-		
-	}
+        else // zero
+        {
+            deltaw[hn] = -sign(dwtnew[hn]) * delta[hn];
 
+            weights[hn] += deltaw[hn];
+        }
+    }
 }
 //---------------------------------------------------------------------
-int sign( float val)
-{
-	if (val > 0)
-		return (1);
-	if(val<0)
-		return (-1);
-	return (0);
+int sign(float val) {
+    if(val > 0)
+        return (1);
+    if(val < 0)
+        return (-1);
+    return (0);
 }
 ///-----------------------------------------------------------------
-// This function is responsible for validating arguments and creating a new filter
-static void VS_CC neuralCreate(const VSMap *in,
-	VSMap *out, void *userData, VSCore *core,
-	const VSAPI *vsapi)
-{
-	NeuralData d;
-	NeuralData *data;
-	int temp;
-	int err;
-	const char * txt, *fname;
-	txt = vsapi->propGetData(in, "txt", 0, &err);
-	if (err)
-		txt = "none";
-	else if (strcmp(txt, "none") != 0 && strcmp(txt, "read") != 0 && strcmp(txt, "save") != 0)
-	{
-		vsapi->setError(out, "neural: txt can be either \"none\" or \"read\" or \"save\" only");
-		return;
-	}
-
-	strcpy_s(d.txt, 8, txt);
-
-	if (strcmp(txt, "none") != 0)
-	{
-		fname = vsapi->propGetData(in, "fname", 0, &err);
-		if (err)
-		{
-			vsapi->setError(out, "neural: fname file name with full path must be specified");
-			return;
-		}
-
-		strcpy_s(d.filename,200, fname);
-	}
-
-	// Get a clip reference from the input arguments. This must be freed later.
-	d.node = vsapi->propGetNode(in, "clip", 0, 0);
-	d.vi = vsapi->getVideoInfo(d.node);
-
-	if (d.vi->format->colorFamily != cmRGB && d.vi->format->colorFamily != cmYUV &&
-		d.vi->format->colorFamily != cmGray)
-	{
-		vsapi->setError(out, "neural: clips can be RGB or YUV or Gray color formats only");
-		vsapi->freeNode(d.node);		
-		return;
-	}
-
-	if (strcmp(txt, "read") != 0)
-	{
-			// for save or none options training is required
-		d.tnode = vsapi->propGetNode(in, "tclip", 0, &err);
-		if (err)
-		{
-			vsapi->setError(out, "neural:  tclip must be specified for this txt option");
-			vsapi->freeNode(d.node);
-			return;
-		}
-
-		d.tvi = vsapi->getVideoInfo(d.tnode);
-
-		if (!isConstantFormat(d.vi) && !isSameFormat(d.vi, d.tvi))
-		{
-			vsapi->setError(out, "neural: input and tclip must have same constant format");
-			vsapi->freeNode(d.node);
-			vsapi->freeNode(d.tnode);
-			return;
-		}
-
-
-		d.xpts = vsapi->propGetInt(in, "xpts", 0, &err);
-		if (err)
-			d.xpts = 3;
-		d.ypts = vsapi->propGetInt(in, "ypts", 0, &err);
-		if (err)
-			d.ypts = d.xpts;
-
-		if (d.xpts < 1 || d.ypts < 1 || d.xpts * d.ypts < 9 || d.xpts * d.ypts > 15 * 15 || ((d.xpts * d.ypts) & 1) == 0)
-		{
-			vsapi->setError(out, "neural: xpts and ypts must be positive odd numbers with a product between 9 and 225. ");
-			vsapi->freeNode(d.node);
-			vsapi->freeNode(d.tnode);
-			return;
-		}
-		if (d.vi->format->colorFamily == cmRGB)
-		{
-			d.rgb = vsapi->propGetInt(in, "rgb", 0, &err);
-			if (err)
-			{
-				d.rgb = 1;
-			}
-
-			else if (d.rgb < 0 || d.rgb > 2)
-			{
-				vsapi->setError(out, "neural: rgb value can be 0 for red, 1 for green and 2 for blue use in training purpose ");
-				vsapi->freeNode(d.node);
-				vsapi->freeNode(d.tnode);
-				return;
-			}
-		}
-
-		
-
-		// Note that
-		// vi->format can be 0 if the input clip can change format midstream.
-		//if (!isConstantFormat(d.vi) || d.vi->format->sampleType != stInteger ) {
-		//    vsapi->setError(out, "AdaptiveMedian: only constant format 8 bit integer input supported");
-		//    vsapi->freeNode(d.node);
-		//    return;
-
-
-		// If a property read fails for some reason (index out of bounds/wrong type)
-		// then err will have flags set to indicate why and 0 will be returned. This
-		// can be very useful to know when having optional arguments. Since we have
-		// strict checking because of what we wrote in the argument string the only reason
-		// this could fail is when the value wasn't set by the user.
-		// And when it's not set we want it to default to preset value.
-
-		d.tlx = vsapi->propGetInt(in, "tlx", 0, &err);
-		if (err)
-			d.tlx = d.xpts;
-		d.tty = vsapi->propGetInt(in, "tty", 0, &err);
-		if (err)
-			d.tty = d.ypts;
-		d.trx = vsapi->propGetInt(in, "trx", 0, &err);
-		if (err)
-			d.trx = d.vi->width - d.xpts;
-		d.tby = vsapi->propGetInt(in, "tby", 0, &err);
-		if (err)
-			d.tby = d.vi->height - d.ypts;
-
-		if (d.tlx < d.xpts / 2 || d.tty < d.ypts / 2
-			|| d.trx > d.vi->width - d.xpts / 2 || d.tby > d.vi->height - d.ypts / 2
-			|| (d.trx - d.tlx) * (d.tby - d.tty) < 10000)
-		{
-			vsapi->setError(out, "neural: trainig window should be in frame with borders of xpts/2 and ypts/2 and have atleast 10000 pixels");
-			vsapi->freeNode(d.node);
-			vsapi->freeNode(d.tnode);
-			return;
-		}
-		d.iter = vsapi->propGetInt(in, "iter", 0, &err);
-		if (err)
-			d.iter = 200;
-
-		if (d.iter < 1)
-		{
-			vsapi->setError(out, "neural: number of iterations iter for trainig should be a sufficiently large positive number");
-			vsapi->freeNode(d.node);
-			vsapi->freeNode(d.tnode);
-			return;
-		}
-		d.best = vsapi->propGetInt(in, "bestof", 0, &err);
-		if (err)
-			d.best = 1;
-
-		if (d.best < 1 || d.best > 10)
-		{
-			vsapi->setError(out, "neural: bestof can be 1 to 10 only");
-			vsapi->freeNode(d.node);
-			vsapi->freeNode(d.tnode);
-			return;
-		}
-
-		temp = vsapi->propGetInt(in, "wset", 0, &err);
-		if (err)
-		{
-			d.wset = false;
-		}
-
-		else if (temp < 0 || temp > 1)
-		{
-			vsapi->setError(out, "neural: wset can have a value of 0 or 1 only ");
-			vsapi->freeNode(d.node);
-			vsapi->freeNode(d.tnode);
-			return;
-		}
-		else
-			d.wset = temp == 1 ? true : false;
-	}
-	
-	data = (NeuralData *)malloc(sizeof(d));
-	*data = d;
-
-	// Create a new filter and returns a reference to it. Always pass on the in and out
-	// arguments or unexpected things may happen. The name should be something that's
-	// easy to connect to the filter, like its function name.
-	// The three function pointers handle initialization, frame processing and filter destruction.
-	// The filtermode is very important to get right as it controls how threading of the filter
-	// is handled. In general you should only use fmParallel whenever possible. This is if you
-	// need to modify no shared data at all when the filter is running.
-	// For more complicated filters fmParallelRequests is usually easier to achieve as an
-	// be prefetched in parallel but the actual processing is serialized.
-	// The others can be considered special cases where fmSerial is useful to source filters and
-	// fmUnordered is useful when a filter's state may change even when deciding which frames to
-	// prefetch (such as a cache filter).
-	// If you filter is really fast (such as a filter that only resorts frames) you should set the
-	// nfNoCache flag to make the caching work smoother.
-	vsapi->createFilter(in, out, "neural", neuralInit,
-		neuralGetFrame, neuralFree,
-		fmParallel, 0, data, core);
-	return;
+// This function is responsible for validating arguments and creating a new
+// filter
+static void VS_CC neuralCreate(const VSMap *in, VSMap *out, void *userData,
+                               VSCore *core, const VSAPI *vsapi) {
+    NeuralData d;
+    NeuralData *data;
+    int temp;
+    int err;
+    const char *txt, *fname;
+    txt = vsapi->propGetData(in, "txt", 0, &err);
+    if(err)
+        txt = "none";
+    else if(strcmp(txt, "none") != 0 && strcmp(txt, "read") != 0 &&
+            strcmp(txt, "save") != 0) {
+        vsapi->setError(
+            out,
+            "neural: txt can be either \"none\" or \"read\" or \"save\" only");
+        return;
+    }
+
+    // Error
+    // strcpy_s(d.txt, 8, txt);
+
+    // Fix
+    snprintf(d.txt, sizeof(d.txt), "%s", txt);
+
+    if(strcmp(txt, "none") != 0) {
+        fname = vsapi->propGetData(in, "fname", 0, &err);
+        if(err) {
+            vsapi->setError(
+                out,
+                "neural: fname file name with full path must be specified");
+            return;
+        }
+        // Error
+        // strcpy_s(d.filename,200, fname);
+        // Fix
+        snprintf(d.filename, sizeof(d.filename), "%s", fname);
+    }
+
+    // Get a clip reference from the input arguments. This must be freed later.
+    d.node = vsapi->propGetNode(in, "clip", 0, 0);
+    d.vi = vsapi->getVideoInfo(d.node);
+
+    if(d.vi->format->colorFamily != cmRGB &&
+       d.vi->format->colorFamily != cmYUV &&
+       d.vi->format->colorFamily != cmGray) {
+        vsapi->setError(
+            out, "neural: clips can be RGB or YUV or Gray color formats only");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    if(strcmp(txt, "read") != 0) {
+        // for save or none options training is required
+        d.tnode = vsapi->propGetNode(in, "tclip", 0, &err);
+        if(err) {
+            vsapi->setError(
+                out, "neural:  tclip must be specified for this txt option");
+            vsapi->freeNode(d.node);
+            return;
+        }
+
+        d.tvi = vsapi->getVideoInfo(d.tnode);
+
+        if(!isConstantFormat(d.vi) && !isSameFormat(d.vi, d.tvi)) {
+            vsapi->setError(
+                out, "neural: input and tclip must have same constant format");
+            vsapi->freeNode(d.node);
+            vsapi->freeNode(d.tnode);
+            return;
+        }
+
+        d.xpts = vsapi->propGetInt(in, "xpts", 0, &err);
+        if(err)
+            d.xpts = 3;
+        d.ypts = vsapi->propGetInt(in, "ypts", 0, &err);
+        if(err)
+            d.ypts = d.xpts;
+
+        if(d.xpts < 1 || d.ypts < 1 || d.xpts * d.ypts < 9 ||
+           d.xpts * d.ypts > 15 * 15 || ((d.xpts * d.ypts) & 1) == 0) {
+            vsapi->setError(out, "neural: xpts and ypts must be positive odd "
+                                 "numbers with a product between 9 and 225. ");
+            vsapi->freeNode(d.node);
+            vsapi->freeNode(d.tnode);
+            return;
+        }
+        if(d.vi->format->colorFamily == cmRGB) {
+            d.rgb = vsapi->propGetInt(in, "rgb", 0, &err);
+            if(err) {
+                d.rgb = 1;
+            }
+
+            else if(d.rgb < 0 || d.rgb > 2) {
+                vsapi->setError(
+                    out, "neural: rgb value can be 0 for red, 1 for green and "
+                         "2 for blue use in training purpose ");
+                vsapi->freeNode(d.node);
+                vsapi->freeNode(d.tnode);
+                return;
+            }
+        }
+
+        // Note that
+        // vi->format can be 0 if the input clip can change format midstream.
+        // if (!isConstantFormat(d.vi) || d.vi->format->sampleType != stInteger
+        // ) {
+        //    vsapi->setError(out, "AdaptiveMedian: only constant format 8 bit
+        //    integer input supported"); vsapi->freeNode(d.node); return;
+
+        // If a property read fails for some reason (index out of bounds/wrong
+        // type) then err will have flags set to indicate why and 0 will be
+        // returned. This can be very useful to know when having optional
+        // arguments. Since we have strict checking because of what we wrote in
+        // the argument string the only reason this could fail is when the value
+        // wasn't set by the user. And when it's not set we want it to default
+        // to preset value.
+
+        d.tlx = vsapi->propGetInt(in, "tlx", 0, &err);
+        if(err)
+            d.tlx = d.xpts;
+        d.tty = vsapi->propGetInt(in, "tty", 0, &err);
+        if(err)
+            d.tty = d.ypts;
+        d.trx = vsapi->propGetInt(in, "trx", 0, &err);
+        if(err)
+            d.trx = d.vi->width - d.xpts;
+        d.tby = vsapi->propGetInt(in, "tby", 0, &err);
+        if(err)
+            d.tby = d.vi->height - d.ypts;
+
+        if(d.tlx < d.xpts / 2 || d.tty < d.ypts / 2 ||
+           d.trx > d.vi->width - d.xpts / 2 ||
+           d.tby > d.vi->height - d.ypts / 2 ||
+           (d.trx - d.tlx) * (d.tby - d.tty) < 10000) {
+            vsapi->setError(
+                out, "neural: trainig window should be in frame with borders "
+                     "of xpts/2 and ypts/2 and have atleast 10000 pixels");
+            vsapi->freeNode(d.node);
+            vsapi->freeNode(d.tnode);
+            return;
+        }
+        d.iter = vsapi->propGetInt(in, "iter", 0, &err);
+        if(err)
+            d.iter = 200;
+
+        if(d.iter < 1) {
+            vsapi->setError(out,
+                            "neural: number of iterations iter for trainig "
+                            "should be a sufficiently large positive number");
+            vsapi->freeNode(d.node);
+            vsapi->freeNode(d.tnode);
+            return;
+        }
+        d.best = vsapi->propGetInt(in, "bestof", 0, &err);
+        if(err)
+            d.best = 1;
+
+        if(d.best < 1 || d.best > 10) {
+            vsapi->setError(out, "neural: bestof can be 1 to 10 only");
+            vsapi->freeNode(d.node);
+            vsapi->freeNode(d.tnode);
+            return;
+        }
+
+        temp = vsapi->propGetInt(in, "wset", 0, &err);
+        if(err) {
+            d.wset = false;
+        }
+
+        else if(temp < 0 || temp > 1) {
+            vsapi->setError(out,
+                            "neural: wset can have a value of 0 or 1 only ");
+            vsapi->freeNode(d.node);
+            vsapi->freeNode(d.tnode);
+            return;
+        } else
+            d.wset = temp == 1 ? true : false;
+    }
+
+    data = (NeuralData *) malloc(sizeof(d));
+    *data = d;
+
+    // Create a new filter and returns a reference to it. Always pass on the in
+    // and out arguments or unexpected things may happen. The name should be
+    // something that's easy to connect to the filter, like its function name.
+    // The three function pointers handle initialization, frame processing and
+    // filter destruction. The filtermode is very important to get right as it
+    // controls how threading of the filter is handled. In general you should
+    // only use fmParallel whenever possible. This is if you need to modify no
+    // shared data at all when the filter is running. For more complicated
+    // filters fmParallelRequests is usually easier to achieve as an be
+    // prefetched in parallel but the actual processing is serialized. The
+    // others can be considered special cases where fmSerial is useful to source
+    // filters and fmUnordered is useful when a filter's state may change even
+    // when deciding which frames to prefetch (such as a cache filter). If you
+    // filter is really fast (such as a filter that only resorts frames) you
+    // should set the nfNoCache flag to make the caching work smoother.
+    vsapi->createFilter(in, out, "neural", neuralInit, neuralGetFrame,
+                        neuralFree, fmParallel, 0, data, core);
+    return;
 }
 /*
-VS_EXTERNAL_API(void) VapourSynthPluginInit(VSConfigPlugin configFunc, VSRegisterFunction registerFunc, VSPlugin *plugin)
+VS_EXTERNAL_API(void) VapourSynthPluginInit(VSConfigPlugin configFunc,
+VSRegisterFunction registerFunc, VSPlugin *plugin)
 {
-configFunc("vc.mohan.dns", "neural", "VapourSynth Neural", VAPOURSYNTH_API_VERSION, 1, plugin);
-registerFunc("neural", "clip:clip;tclip:clip;xpts:int:opt;ypts:int:opt;tlx:int:opt;tty:int:opt;trx:int:opt;tby:int:opt;"
-"iter:int:opt;bestof:int:opt;wset:int:opt;rgb:int:opt;txt:Data:opt;fname:Data:opt", neuralCreate, 0, plugin);
+configFunc("vc.mohan.dns", "neural", "VapourSynth Neural",
+VAPOURSYNTH_API_VERSION, 1, plugin); registerFunc("neural",
+"clip:clip;tclip:clip;xpts:int:opt;ypts:int:opt;tlx:int:opt;tty:int:opt;trx:int:opt;tby:int:opt;"
+"iter:int:opt;bestof:int:opt;wset:int:opt;rgb:int:opt;txt:Data:opt;fname:Data:opt",
+neuralCreate, 0, plugin);
 }
 */
diff --git a/moveDeBarrel.cpp b/moveDeBarrel.cpp
index 085f106..2fc2458 100644
--- a/moveDeBarrel.cpp
+++ b/moveDeBarrel.cpp
@@ -1,15 +1,16 @@
 /******************************************************************************
 DeBarrel filter plugin for vapoursynth by V.C.Mohan
 DeBarrel corrects input image from barrel or pin cushion type distortion
-given parametrs a, b, c in mode 1 and c in mode 2. In test mode draws barrel or pincushion type 
-lines on input frame corresponding to the constants . This feature enables to determine values for a,b and or c.
+given parametrs a, b, c in mode 1 and c in mode 2. In test mode draws barrel or
+pincushion type lines on input frame corresponding to the constants . This
+feature enables to determine values for a,b and or c.
 
-distortion where  x axis distortion  is independant of y axis distortion also can be corrected.
-(included at a request from an user)
+distortion where  x axis distortion  is independant of y axis distortion also
+can be corrected. (included at a request from an user)
 
-vhr parameter corrects for unequal distortions along height and width of frame 
+vhr parameter corrects for unequal distortions along height and width of frame
  seen on some anamorphic projections.
- 
+
  Author V.C.Mohan
 
   sep 2014, modified on 20 Aug 2020 20 Oct 2021
@@ -28,538 +29,542 @@ Copyright (C) <2020 - 2021>  <V.C.Mohan>
     A copy of the GNU General Public License is at
     see <http://www.gnu.org/licenses/>.
 
-	
 
 
-********************************************************************************/ 
+
+********************************************************************************/
 /*
-#include <stdlib.h>
-#include "VapourSynth.h"
 #include "VSHelper.h"
-#include "math.h"
+#include "VapourSynth.h"
 #include "interpolationMethods.h"
+#include "math.h"
+#include <stdlib.h>
 */
 typedef struct {
 
-		VSNodeRef *node;
-		const VSVideoInfo *vi;
-				
-		float abc[3];
-		int q;
-		bool pin;	// whether pincushion type  or  barrel type
-		bool test;	// whether a test run		
-		int method;		// formula type 1. uses a,b and c 2. Uses c ( and yc) only			
-		int dots;	// in test
-		int ddensity;
-		float dim;
-		
-		float * iCoeff;	// interpolation coefficients	
-		int quantile;		// accuracy of interpolation
-		int span;			// span of lanczos 6 (X6)
-		int* xyAndQ;
-		int nEntries;
-		
-		uint8_t col[12];
-	
-}DeBarrelData;	
-
-	
+    VSNodeRef *node;
+    const VSVideoInfo *vi;
+
+    float abc[3];
+    int q;
+    bool pin;   // whether pincushion type  or  barrel type
+    bool test;  // whether a test run
+    int method; // formula type 1. uses a,b and c 2. Uses c ( and yc) only
+    int dots;   // in test
+    int ddensity;
+    float dim;
+
+    float *iCoeff; // interpolation coefficients
+    int quantile;  // accuracy of interpolation
+    int span;      // span of lanczos 6 (X6)
+    int *xyAndQ;
+    int nEntries;
+
+    uint8_t col[12];
+
+} DeBarrelData;
+
 /*--------------------------------------------------
- * The following is the implementation 
+ * The following is the implementation
  * of the defined functions.
  --------------------------------------------------*/
-//Here is the init code used			
-			
+// Here is the init code used
+
 static void VS_CC debarrelInit(VSMap *in, VSMap *out, void **instanceData,
-	VSNode *node, VSCore *core, const VSAPI *vsapi)
-{
-    DeBarrelData *d = (DeBarrelData *) * instanceData;
+                               VSNode *node, VSCore *core, const VSAPI *vsapi) {
+    DeBarrelData *d = (DeBarrelData *) *instanceData;
     vsapi->setVideoInfo(d->vi, 1, node);
 
-	// input frame dimensions
-	const int width = d->vi->width;
-	const int height = d->vi->height;
-	const VSFormat* fi = d->vi->format;
-	int nbytes = fi->bytesPerSample;
-	int nbits = fi->bitsPerSample;
-	d->quantile = 64;
-	d->nEntries = d->test ? 2 : d->q == 1 ? 3 : 4;
-
-	d->xyAndQ = (int*)vs_aligned_malloc<int>(sizeof(int) * (width / 2) * (height / 2) * d->nEntries, 32);
-
-	int* xyQ = d->xyAndQ;
-	float xy[2];
-	int x, y, qx, qy;
-
-	d->iCoeff = NULL;
-
-	if (!d->test)
-		d->iCoeff = setInterpolationScheme(d->q, d->quantile, &d->span);	
-	
-	
-	if (!d->pin)
-	{
-		for (int i = 0; i < 3; i++)
-			d->abc[i] = -d->abc[i];			
-	}
-	float rNorm = (float)sqrt((double)(width * width + height * height) / 4);
-	// create a look up table
-	for ( int h = 0; h < height / 2; h ++)
-	{
-		int hoff = h * width / 2 *  d->nEntries;
-
-		for( int w = 0; w < width / 2; w ++)
-		{
-			int woff = w * d->nEntries;
-			getSourceCoord(xy, (float) w, (float)h, d->method, rNorm, d->abc);
-
-			x = (int)floor(xy[0]);
-			y = (int)floor(xy[1]);
-
-			
-			if (x >= width / 2 || y >= height / 2 || x < 0 || y < 0)
-			{
-				xyQ[hoff + woff] = -1;
-			}
-			else
-			{
-				xyQ[hoff + woff] = x;
-				xyQ[hoff + woff + 1] = y;
-
-				if (!d->test)
-				{
-					// calculate nearest quantile of the fraction
-					qx = (int)((xy[0] - x) * d->quantile);
-					qy = (int)((xy[1] - y) * d->quantile);				
-				
-					if (d->q > 1)
-					{
-						xyQ[hoff + woff + 2] = qx;
-						xyQ[hoff + woff + 3] = qy;
-					}
-					else
-						// index value
-						xyQ[hoff + woff + 2] = bestOfNineIndex(qx, qy, d->quantile);
-				}
-			}
-		}
-	}
-
-	// color to blacken out of area points
-	uint8_t bgr[] = { 0,0,0 }, yuv[] = { 16,128,128 };
-
-	if (d->test)
-	{
-		// will have white dots
-		d->ddensity = (5 - d->dots) * 16;
-		bgr[0] = 255;
-		bgr[1] = 255;
-		bgr[2] = 255;
-	}
-
-	convertBGRforInputFormat(d->col, bgr, fi);
+    // input frame dimensions
+    const int width = d->vi->width;
+    const int height = d->vi->height;
+    const VSFormat *fi = d->vi->format;
+    int nbytes = fi->bytesPerSample;
+    int nbits = fi->bitsPerSample;
+    d->quantile = 64;
+    d->nEntries = d->test ? 2 : d->q == 1 ? 3 : 4;
+
+    d->xyAndQ = (int *) vs_aligned_malloc<int>(
+        sizeof(int) * (width / 2) * (height / 2) * d->nEntries, 32);
 
+    int *xyQ = d->xyAndQ;
+    float xy[2];
+    int x, y, qx, qy;
+
+    d->iCoeff = NULL;
+
+    if(!d->test)
+        d->iCoeff = setInterpolationScheme(d->q, d->quantile, &d->span);
+
+    if(!d->pin) {
+        for(int i = 0; i < 3; i++)
+            d->abc[i] = -d->abc[i];
+    }
+    float rNorm = (float) sqrt((double) (width * width + height * height) / 4);
+    // create a look up table
+    for(int h = 0; h < height / 2; h++) {
+        int hoff = h * width / 2 * d->nEntries;
+
+        for(int w = 0; w < width / 2; w++) {
+            int woff = w * d->nEntries;
+            getSourceCoord(xy, (float) w, (float) h, d->method, rNorm, d->abc);
+
+            x = (int) floor(xy[0]);
+            y = (int) floor(xy[1]);
+
+            if(x >= width / 2 || y >= height / 2 || x < 0 || y < 0) {
+                xyQ[hoff + woff] = -1;
+            } else {
+                xyQ[hoff + woff] = x;
+                xyQ[hoff + woff + 1] = y;
+
+                if(!d->test) {
+                    // calculate nearest quantile of the fraction
+                    qx = (int) ((xy[0] - x) * d->quantile);
+                    qy = (int) ((xy[1] - y) * d->quantile);
+
+                    if(d->q > 1) {
+                        xyQ[hoff + woff + 2] = qx;
+                        xyQ[hoff + woff + 3] = qy;
+                    } else
+                        // index value
+                        xyQ[hoff + woff + 2] =
+                            bestOfNineIndex(qx, qy, d->quantile);
+                }
+            }
+        }
+    }
+
+    // color to blacken out of area points
+    uint8_t bgr[] = {0, 0, 0}, yuv[] = {16, 128, 128};
+
+    if(d->test) {
+        // will have white dots
+        d->ddensity = (5 - d->dots) * 16;
+        bgr[0] = 255;
+        bgr[1] = 255;
+        bgr[2] = 255;
+    }
+
+    convertBGRforInputFormat(d->col, bgr, fi);
 }
 
-	// This is the main function that gets called when a frame should be produced. It will, in most cases, get
-// called several times to produce one frame. This state is being kept track of by the value of
-// activationReason. The first call to produce a certain frame n is always arInitial. In this state
-// you should request all the input frames you need. Always do it in ascending order to play nice with the
-// upstream filters.
-// Once all frames are ready, the filter will be called with arAllFramesReady. It is now time to
-// do the actual processing.
-static const VSFrameRef *VS_CC debarrelGetFrame(int n, int activationReason, void **instanceData, 
-	void **frameData, VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi)
-{
-    DeBarrelData *d = (DeBarrelData *) * instanceData;
-
-    if (activationReason == arInitial)
-	{
-		
+// This is the main function that gets called when a frame should be produced.
+// It will, in most cases, get
+// called several times to produce one frame. This state is being kept track of
+// by the value of activationReason. The first call to produce a certain frame n
+// is always arInitial. In this state you should request all the input frames
+// you need. Always do it in ascending order to play nice with the upstream
+// filters. Once all frames are ready, the filter will be called with
+// arAllFramesReady. It is now time to do the actual processing.
+static const VSFrameRef *VS_CC debarrelGetFrame(
+    int n, int activationReason, void **instanceData, void **frameData,
+    VSFrameContext *frameCtx, VSCore *core, const VSAPI *vsapi) {
+    DeBarrelData *d = (DeBarrelData *) *instanceData;
+
+    if(activationReason == arInitial) {
+
         // Request the source frame on the first call
         vsapi->requestFrameFilter(n, d->node, frameCtx);
-    }
-	else if (activationReason == arAllFramesReady) 
-	{
+    } else if(activationReason == arAllFramesReady) {
         const VSFrameRef *src = vsapi->getFrameFilter(n, d->node, frameCtx);
-		VSFrameRef *dst;
-        // The reason we query this on a per frame basis is because we want our filter
-        // to accept clips with varying dimensions. If we reject such content using d->vi
-        // would be better.
+        VSFrameRef *dst;
+        // The reason we query this on a per frame basis is because we want our
+        // filter to accept clips with varying dimensions. If we reject such
+        // content using d->vi would be better.
         const VSFormat *fi = d->vi->format;
-		int height = vsapi->getFrameHeight(src, 0);
-        int width = vsapi->getFrameWidth(src, 0);		
-
-		// When creating a new frame for output it is VERY EXTREMELY SUPER IMPORTANT to
-        // supply the "dominant" source frame to copy properties from. Frame props
-        // are an essential part of the filter chain and you should NEVER break it.       
-
-		int nbits = (fi->sampleType == stInteger) ? fi->bitsPerSample : 0;
-		int	nbytes = fi->bytesPerSample;
-
-		if (d->test)
-		{
-			// copy input frame on to dst
-			dst = vsapi->copyFrame(src, core);
-			// we will draw a distortion grid on to the frame
-
-			for (int plane = 0; plane < fi->numPlanes; plane++)
-			{
-				const uint8_t* sp = vsapi->getReadPtr(src, plane);
-				uint8_t* dp = vsapi->getWritePtr(dst, plane);
-				int spitch = vsapi->getStride(src, plane) / nbytes; // this is in pixels. Required for uint16 and float pointers
-				// note that if a frame has the same dimensions and format, the stride is guaranteed to be the same. int dst_stride = src_stride would be fine too in this filter.
-				int dpitch = spitch;
-
-				int iCenter = height / 2 * dpitch + width / 2;	// offset to center	
-				if (fi->colorFamily == cmRGB)
-				{
-					if (nbytes == 1)
-						dimplaneRGB(dp, sp, spitch, width, height, d->dim);
-					else if (nbytes == 2)
-						dimplaneRGB((uint16_t*)dp, (uint16_t*)sp, spitch, width, height, d->dim);
-					else if (nbytes == 4)
-						dimplaneRGB((float*)dp, (float*)sp, spitch, width, height, d->dim);
-				}
-
-				else if (plane == 0 && fi->colorFamily == cmYUV)
-				{
-					if (nbytes == 1)
-					{
-						uint8_t limit = (uint8_t)16;
-						dimplaneYUV(dp, dp, dpitch, width, height, d->dim, limit);
-					}
-					else if (nbytes == 2)
-					{
-						uint16_t limit = (uint16_t)(16 << (nbits - 8));
-						dimplaneYUV((uint16_t*)dp, (uint16_t*)dp, dpitch, width, height, d->dim, limit);
-					}
-					else if (nbytes == 4)
-						dimplaneYUV((float*)dp, (float*)dp, dpitch, width, height, d->dim, 0.0f);
-				}
-				int p = plane;
-				// we will mark every  pixelperdot
-				for (int h = d->ddensity / 2; h < height / 2; h += d->ddensity)
-				{
-					int hoff = h * width / 2 * d->nEntries;
-
-					for (int w = d->ddensity / 2; w < width / 2; w += d->ddensity)
-					{
-						int woff = w * d->nEntries;
-						// for each point get the coordinates of distorted image
-						int x = d->xyAndQ[hoff + woff];
-						if (x < 0)
-							continue;
-						int y = d->xyAndQ[hoff + woff + 1];
-
-						// paint dots 4 fold symmetry.
-						if (nbytes == 1)
-							paint4FoldSym(dp + iCenter, dpitch, 1, x, y, d->col[p]);
-						else if (nbytes == 2)
-							paint4FoldSym((uint16_t*)dp + iCenter, dpitch, 1, x, y, *((uint16_t*)d->col + p));
-						else if (nbytes == 4)
-							paint4FoldSym((float*)dp + iCenter, dpitch, 1, x, y, *((float*)d->col + p));
-					}
-				}
-			}
-		}						
-
-		else	// not test. normal processing
-		{
-			dst = vsapi->newVideoFrame(fi, width, height, src, core);
-
-			for (int plane = 0; plane < fi->numPlanes; plane++)
-			{
-				const uint8_t *sp = vsapi->getReadPtr(src, plane);
-				int spitch = vsapi->getStride(src, plane) / nbytes;
-				uint8_t *dp = vsapi->getWritePtr(dst, plane);
-				int dpitch = vsapi->getStride(dst, plane) / nbytes;
-
-				int iCenter = (height / 2) * spitch + width / 2;	// offset from left top to center of frame
-				int oCenter = iCenter;
-				uint8_t min8 = 0, max8 = (uint8_t)255;
-				uint16_t min16 = (uint16_t)(fi->colorFamily == cmYUV ? 16 << (nbits - 8) : 0);
-				uint16_t max16 = (uint16_t)((fi->colorFamily == cmYUV ? 235 : 255 << (nbits - 8)) << (nbits - 8));
-				float minf = 0, maxf = 1.0f;
-
-				if (plane > 0 && fi->colorFamily == cmYUV)
-				{
-					minf = -0.5f;
-					maxf = 0.5f;
-				}
-				int x, y, qx, qy, span2 = d->span / 2;
-				int hoff, woff;
-				int index;
-				int p = plane;
-
-				for (int h = 0; h < height / 2; h++)
-				{
-					hoff = h * d->nEntries * width / 2;
-
-					for (int w = 0; w < width / 2; w++)
-					{
-						woff = w * d->nEntries;
-						// for each point get the coordinates of distorted image
-
-						x = d->xyAndQ[hoff + woff];
-
-						if (x < 0)
-						{
-							
-							// points are outside  src or fish. So make the point black
-							if (nbytes == 1)
-								paint4FoldSym(dp + oCenter, dpitch, 1, w, h, d->col[p]);
-							else if (nbytes == 2)
-								paint4FoldSym((uint16_t*)dp + oCenter, dpitch, 1, w, h, *((uint16_t*)d->col + p));
-							else if (nbytes == 4)
-								paint4FoldSym((float*)dp + oCenter, dpitch, 1, w, h, *((float*)d->col + p));
-						}
-
-						else
-						{
-							
-							y = d->xyAndQ[hoff + woff + 1];
-
-							if (d->q > 1)
-							{
-								qx = d->xyAndQ[hoff + woff + 2];
-								qy = d->xyAndQ[hoff + woff + 3];
-							}
-							else
-								index = d->xyAndQ[hoff + woff + 2];
-
-							if (x >= width / 2 - span2 - 1 || y >= height / 2 - span2 - 1)
-							{
-								
-								//  interpolation does not have sufficient points
-								// points are within src frame
-								if (nbytes == 1)
-								{
-									// near point
-									copy4FoldSym(dp + oCenter, dpitch, sp + iCenter, spitch, 1, w, h, x, y);
-								}
-								else if (nbytes == 2)
-								{
-									copy4FoldSym((uint16_t*)dp + oCenter, dpitch, (uint16_t*)sp + iCenter, spitch, 1, w, h, x, y);
-								}
-								else if (nbytes == 4)
-								{
-
-									// near point
-									copy4FoldSym((float*)dp + oCenter, dpitch, (float*)sp + iCenter, spitch, 1, w, h, x, y);
-								}
-							}
-
-							else
-							{
-								
-								// sufficient points for interpolation are available
-								if (nbytes == 1)
-								{
-									if (d->q == 1)
-									{
-										//continue;
-										interpolate9pt4FoldSym(dp + oCenter, dpitch, sp + iCenter, spitch,
-											1, w, h, x, y, index);
-									}
-									else
-									{
-										
-										//bilinear 2x2 or cubic 4x4 or lanczos 6x6
-										interpolate4FoldSym(dp + oCenter, dpitch, sp + iCenter, spitch,
-											1, w, h, x, y, qx, qy, d->span, d->iCoeff, min8, max8);
-									}
-
-								}
-
-								else if (nbytes == 2)
-								{
-									if (d->q == 1)
-										interpolate9pt4FoldSym((uint16_t*)dp + oCenter, dpitch, (uint16_t*)sp + iCenter, spitch,
-											1, w, h, x, y, index);
-									else
-
-										interpolate4FoldSym((uint16_t*)dp + oCenter, dpitch, (uint16_t*)sp + iCenter, spitch,
-											1, w, h, x, y, qx, qy, d->span, d->iCoeff, min16, max16);
-
-								}
-
-								else if (nbytes == 4)
-								{
-									if (d->q == 1)
-										interpolate9pt4FoldSym((float*)dp + oCenter, dpitch, (float*)sp + iCenter, spitch,
-											1, w, h, x, y, index);
-									else
-
-										interpolate4FoldSym((float*)dp + oCenter, dpitch, (float*)sp + iCenter, spitch,
-											1, w, h, x, y, qx, qy, d->span, d->iCoeff, minf, maxf);
-
-								}
-							}
-						}
-					}
-				}
-
-			}	// for plane
-		}	// not test
-		
-			// activation reason arAllFramesReady processing completed
-		vsapi->freeFrame (src);
-		return dst;		
-	}	// activation reason
-	return 0;
+        int height = vsapi->getFrameHeight(src, 0);
+        int width = vsapi->getFrameWidth(src, 0);
+
+        // When creating a new frame for output it is VERY EXTREMELY SUPER
+        // IMPORTANT to supply the "dominant" source frame to copy properties
+        // from. Frame props are an essential part of the filter chain and you
+        // should NEVER break it.
+
+        int nbits = (fi->sampleType == stInteger) ? fi->bitsPerSample : 0;
+        int nbytes = fi->bytesPerSample;
+
+        if(d->test) {
+            // copy input frame on to dst
+            dst = vsapi->copyFrame(src, core);
+            // we will draw a distortion grid on to the frame
+
+            for(int plane = 0; plane < fi->numPlanes; plane++) {
+                const uint8_t *sp = vsapi->getReadPtr(src, plane);
+                uint8_t *dp = vsapi->getWritePtr(dst, plane);
+                int spitch = vsapi->getStride(src, plane) /
+                             nbytes; // this is in pixels. Required for uint16
+                                     // and float pointers
+                // note that if a frame has the same dimensions and format, the
+                // stride is guaranteed to be the same. int dst_stride =
+                // src_stride would be fine too in this filter.
+                int dpitch = spitch;
+
+                int iCenter =
+                    height / 2 * dpitch + width / 2; // offset to center
+                if(fi->colorFamily == cmRGB) {
+                    if(nbytes == 1)
+                        dimplaneRGB(dp, sp, spitch, width, height, d->dim);
+                    else if(nbytes == 2)
+                        dimplaneRGB((uint16_t *) dp, (uint16_t *) sp, spitch,
+                                    width, height, d->dim);
+                    else if(nbytes == 4)
+                        dimplaneRGB((float *) dp, (float *) sp, spitch, width,
+                                    height, d->dim);
+                }
+
+                else if(plane == 0 && fi->colorFamily == cmYUV) {
+                    if(nbytes == 1) {
+                        uint8_t limit = (uint8_t) 16;
+                        dimplaneYUV(dp, dp, dpitch, width, height, d->dim,
+                                    limit);
+                    } else if(nbytes == 2) {
+                        uint16_t limit = (uint16_t) (16 << (nbits - 8));
+                        dimplaneYUV((uint16_t *) dp, (uint16_t *) dp, dpitch,
+                                    width, height, d->dim, limit);
+                    } else if(nbytes == 4)
+                        dimplaneYUV((float *) dp, (float *) dp, dpitch, width,
+                                    height, d->dim, 0.0f);
+                }
+                int p = plane;
+                // we will mark every  pixelperdot
+                for(int h = d->ddensity / 2; h < height / 2; h += d->ddensity) {
+                    int hoff = h * width / 2 * d->nEntries;
+
+                    for(int w = d->ddensity / 2; w < width / 2;
+                        w += d->ddensity) {
+                        int woff = w * d->nEntries;
+                        // for each point get the coordinates of distorted image
+                        int x = d->xyAndQ[hoff + woff];
+                        if(x < 0)
+                            continue;
+                        int y = d->xyAndQ[hoff + woff + 1];
+
+                        // paint dots 4 fold symmetry.
+                        if(nbytes == 1)
+                            paint4FoldSym(dp + iCenter, dpitch, 1, x, y,
+                                          d->col[p]);
+                        else if(nbytes == 2)
+                            paint4FoldSym((uint16_t *) dp + iCenter, dpitch, 1,
+                                          x, y, *((uint16_t *) d->col + p));
+                        else if(nbytes == 4)
+                            paint4FoldSym((float *) dp + iCenter, dpitch, 1, x,
+                                          y, *((float *) d->col + p));
+                    }
+                }
+            }
+        }
+
+        else // not test. normal processing
+        {
+            dst = vsapi->newVideoFrame(fi, width, height, src, core);
+
+            for(int plane = 0; plane < fi->numPlanes; plane++) {
+                const uint8_t *sp = vsapi->getReadPtr(src, plane);
+                int spitch = vsapi->getStride(src, plane) / nbytes;
+                uint8_t *dp = vsapi->getWritePtr(dst, plane);
+                int dpitch = vsapi->getStride(dst, plane) / nbytes;
+
+                int iCenter =
+                    (height / 2) * spitch +
+                    width / 2; // offset from left top to center of frame
+                int oCenter = iCenter;
+                uint8_t min8 = 0, max8 = (uint8_t) 255;
+                uint16_t min16 =
+                    (uint16_t) (fi->colorFamily == cmYUV ? 16 << (nbits - 8)
+                                                         : 0);
+                uint16_t max16 =
+                    (uint16_t) ((fi->colorFamily == cmYUV ? 235
+                                                          : 255 << (nbits - 8))
+                                << (nbits - 8));
+                float minf = 0, maxf = 1.0f;
+
+                if(plane > 0 && fi->colorFamily == cmYUV) {
+                    minf = -0.5f;
+                    maxf = 0.5f;
+                }
+                int x, y, qx, qy, span2 = d->span / 2;
+                int hoff, woff;
+                int index;
+                int p = plane;
+
+                for(int h = 0; h < height / 2; h++) {
+                    hoff = h * d->nEntries * width / 2;
+
+                    for(int w = 0; w < width / 2; w++) {
+                        woff = w * d->nEntries;
+                        // for each point get the coordinates of distorted image
+
+                        x = d->xyAndQ[hoff + woff];
+
+                        if(x < 0) {
+
+                            // points are outside  src or fish. So make the
+                            // point black
+                            if(nbytes == 1)
+                                paint4FoldSym(dp + oCenter, dpitch, 1, w, h,
+                                              d->col[p]);
+                            else if(nbytes == 2)
+                                paint4FoldSym((uint16_t *) dp + oCenter, dpitch,
+                                              1, w, h,
+                                              *((uint16_t *) d->col + p));
+                            else if(nbytes == 4)
+                                paint4FoldSym((float *) dp + oCenter, dpitch, 1,
+                                              w, h, *((float *) d->col + p));
+                        }
+
+                        else {
+
+                            y = d->xyAndQ[hoff + woff + 1];
+
+                            if(d->q > 1) {
+                                qx = d->xyAndQ[hoff + woff + 2];
+                                qy = d->xyAndQ[hoff + woff + 3];
+                            } else
+                                index = d->xyAndQ[hoff + woff + 2];
+
+                            if(x >= width / 2 - span2 - 1 ||
+                               y >= height / 2 - span2 - 1) {
+
+                                //  interpolation does not have sufficient
+                                //  points
+                                // points are within src frame
+                                if(nbytes == 1) {
+                                    // near point
+                                    copy4FoldSym(dp + oCenter, dpitch,
+                                                 sp + iCenter, spitch, 1, w, h,
+                                                 x, y);
+                                } else if(nbytes == 2) {
+                                    copy4FoldSym((uint16_t *) dp + oCenter,
+                                                 dpitch,
+                                                 (uint16_t *) sp + iCenter,
+                                                 spitch, 1, w, h, x, y);
+                                } else if(nbytes == 4) {
+
+                                    // near point
+                                    copy4FoldSym((float *) dp + oCenter, dpitch,
+                                                 (float *) sp + iCenter, spitch,
+                                                 1, w, h, x, y);
+                                }
+                            }
+
+                            else {
+
+                                // sufficient points for interpolation are
+                                // available
+                                if(nbytes == 1) {
+                                    if(d->q == 1) {
+                                        // continue;
+                                        interpolate9pt4FoldSym(
+                                            dp + oCenter, dpitch, sp + iCenter,
+                                            spitch, 1, w, h, x, y, index);
+                                    } else {
+
+                                        // bilinear 2x2 or cubic 4x4 or lanczos
+                                        // 6x6
+                                        interpolate4FoldSym(
+                                            dp + oCenter, dpitch, sp + iCenter,
+                                            spitch, 1, w, h, x, y, qx, qy,
+                                            d->span, d->iCoeff, min8, max8);
+                                    }
+
+                                }
+
+                                else if(nbytes == 2) {
+                                    if(d->q == 1)
+                                        interpolate9pt4FoldSym(
+                                            (uint16_t *) dp + oCenter, dpitch,
+                                            (uint16_t *) sp + iCenter, spitch,
+                                            1, w, h, x, y, index);
+                                    else
+
+                                        interpolate4FoldSym(
+                                            (uint16_t *) dp + oCenter, dpitch,
+                                            (uint16_t *) sp + iCenter, spitch,
+                                            1, w, h, x, y, qx, qy, d->span,
+                                            d->iCoeff, min16, max16);
+
+                                }
+
+                                else if(nbytes == 4) {
+                                    if(d->q == 1)
+                                        interpolate9pt4FoldSym(
+                                            (float *) dp + oCenter, dpitch,
+                                            (float *) sp + iCenter, spitch, 1,
+                                            w, h, x, y, index);
+                                    else
+
+                                        interpolate4FoldSym(
+                                            (float *) dp + oCenter, dpitch,
+                                            (float *) sp + iCenter, spitch, 1,
+                                            w, h, x, y, qx, qy, d->span,
+                                            d->iCoeff, minf, maxf);
+                                }
+                            }
+                        }
+                    }
+                }
+
+            } // for plane
+        } // not test
+
+        // activation reason arAllFramesReady processing completed
+        vsapi->freeFrame(src);
+        return dst;
+    } // activation reason
+    return 0;
 }
 //---------------------------------------------------------------------
-static void VS_CC debarrelFree(void* instanceData, VSCore* core, const VSAPI* vsapi)
-{
-	DeBarrelData* d = (DeBarrelData*)instanceData;
-	vsapi->freeNode(d->node);
-
-	vs_aligned_free(d->xyAndQ);
-	if (!d->iCoeff == NULL)
-		vs_aligned_free(d->iCoeff);
-
-	free(d);
+static void VS_CC debarrelFree(void *instanceData, VSCore *core,
+                               const VSAPI *vsapi) {
+    DeBarrelData *d = (DeBarrelData *) instanceData;
+    vsapi->freeNode(d->node);
+
+    vs_aligned_free(d->xyAndQ);
+    // Warning
+    // if (!d->iCoeff == NULL)
+    // Fix
+    if(d->iCoeff != NULL)
+        vs_aligned_free(d->iCoeff);
+
+    free(d);
 }
 
-
 /***************************************************************/
-// This is the function that created the filter, when the filter has been called.
-// This can be used for simple parameter checking, so it is possible to create different filters,
+// This is the function that created the filter, when the filter has been
+// called. This can be used for simple parameter checking, so it is possible to
+// create different filters,
 
-static void VS_CC debarrelCreate(const VSMap *in, VSMap *out, void *userData, VSCore *core, const VSAPI *vsapi)
-{
+static void VS_CC debarrelCreate(const VSMap *in, VSMap *out, void *userData,
+                                 VSCore *core, const VSAPI *vsapi) {
     DeBarrelData d;
     DeBarrelData *data;
     int err;
-	int temp;	// used to convert int to bool
+    int temp; // used to convert int to bool
     // Get a clip reference from the input arguments. This must be freed later.
     d.node = vsapi->propGetNode(in, "clip", 0, 0);
     d.vi = vsapi->getVideoInfo(d.node);
 
-    // In this first version we only want to handle 8bit integer formats. Note that
-    // vi->format can be 0 if the input clip can change format midstream.
-    if (!isConstantFormat(d.vi) || d.vi->width == 0 || d.vi->height == 0 || d.vi->format->subSamplingH != 0 || d.vi->format->subSamplingW != 0)
-	{
-        vsapi->setError(out, "DeBarrel: only RGB or those YUV formats that have no subsampling are supported. Frame dimensions should remain constant");
+    // In this first version we only want to handle 8bit integer formats. Note
+    // that vi->format can be 0 if the input clip can change format midstream.
+    if(!isConstantFormat(d.vi) || d.vi->width == 0 || d.vi->height == 0 ||
+       d.vi->format->subSamplingH != 0 || d.vi->format->subSamplingW != 0) {
+        vsapi->setError(
+            out,
+            "DeBarrel: only RGB or those YUV formats that have no subsampling "
+            "are supported. Frame dimensions should remain constant");
         vsapi->freeNode(d.node);
         return;
     }
 
-	if (d.vi->format->colorFamily != cmRGB && d.vi->format->colorFamily != cmYUV && d.vi->format->colorFamily != cmGray)
-	{
-		vsapi->setError(out, "DeBarrel: RGB, YUV and Gray color formats only for input allowed ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-	if (d.vi->format->sampleType == stFloat && d.vi->format->bitsPerSample == 16)
-	{
-		vsapi->setError(out, "DeBarrel: Half float formats not allowed ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-
-	d.method = int64ToIntS(vsapi->propGetInt(in, "method", 0, &err));
-	if (err)
-		d.method = 2;
-	if (d.method < 1 || d.method > 2)
-	{
-		vsapi->setError(out, "DeBarrel: method can be 1 or 2 ");
-		vsapi->freeNode(d.node);
-		return;
-	}
-
-	if (d.method == 1)
-	{
-		for (int i = 0; i < 3; i++)
-		{
-			d.abc[i] = (float)vsapi->propGetFloat(in, "abc", i, 0);
-			if (d.abc[i] < 0.0 || d.abc[i] > 0.5)
-			{
-				vsapi->setError(out, "DeBarrel: abc[] values can be zero to less than 0.5 only");
-				vsapi->freeNode(d.node);
-				return;
-			}
-		}
-
-		if (d.abc[0] + d.abc[1] + d.abc[2] > 1.0)
-		{
-			vsapi->setError(out, "DeBarrel: sum of all three abc array values must be less than 1.0 ");
-			vsapi->freeNode(d.node);
-			return;
-		}
-	}
-
-	else
-	{
-		for (int i = 0; i < 3; i++)
-		{
-			d.abc[i] = (float)vsapi->propGetFloat(in, "abc", i, 0);
-		}
-
-		if (d.abc[2] < 0.0 || d.abc[2] >= 0.5f)
-		{
-			vsapi->setError(out, "DeBarrel: third value of abc[]  can be zero to less than 0.5");
-			vsapi->freeNode(d.node);
-			return;
-		}
-	}
-
-	temp = !!int64ToIntS(vsapi->propGetInt(in, "pin", 0, &err));
-
-	if (err)
-		temp = 0;
-
-	if (temp == 0)
-		d.pin = false;
-	else
-		d.pin = true;
-	d.q = int64ToIntS(vsapi->propGetInt(in, "q", 0, &err));
-	if (err)
-		d.q = 1;
-	else if(d.q < 0 || d.q > 4)
-	{
-		vsapi->setError(out, "DeBarrel: q  can be 1 to 4 only");
-		vsapi->freeNode(d.node);
-		return;
-	}
-	
-	// d.test
-	temp = !!int64ToIntS(vsapi->propGetInt(in, "test", 0, &err));
-
-	if (err)
-		temp = 0;
-
-	if (temp == 0)
-		d.test = false;
-	else
-		d.test = true;
-
-	if (d.test)
-	{
-		d.dots = int64ToIntS(vsapi->propGetInt(in, "dots", 0, &err));
-
-		if (err)
-			d.dots = 2;
-		if (d.dots < 0 || d.dots > 4)			
-		{
-			vsapi->setError(out, "DeBarrel: dots can be 1 to 4 only.");
-			vsapi->freeNode(d.node);
-			return;
-		}
-
-		d.dim = (float)( 1.0 - vsapi->propGetFloat(in, "dots", 0, &err));
-		if (err)
-			d.dim = 0.75;
-		else if (d.dim < 0 || d.dim > 1.0f)
-		{
-			vsapi->setError(out, "DeBarrel: dim can be 0 to 1.0 only.");
-			vsapi->freeNode(d.node);
-			return;
-		}
-
-	}	// if test
+    if(d.vi->format->colorFamily != cmRGB &&
+       d.vi->format->colorFamily != cmYUV &&
+       d.vi->format->colorFamily != cmGray) {
+        vsapi->setError(out, "DeBarrel: RGB, YUV and Gray color formats only "
+                             "for input allowed ");
+        vsapi->freeNode(d.node);
+        return;
+    }
+    if(d.vi->format->sampleType == stFloat &&
+       d.vi->format->bitsPerSample == 16) {
+        vsapi->setError(out, "DeBarrel: Half float formats not allowed ");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    d.method = int64ToIntS(vsapi->propGetInt(in, "method", 0, &err));
+    if(err)
+        d.method = 2;
+    if(d.method < 1 || d.method > 2) {
+        vsapi->setError(out, "DeBarrel: method can be 1 or 2 ");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    if(d.method == 1) {
+        for(int i = 0; i < 3; i++) {
+            d.abc[i] = (float) vsapi->propGetFloat(in, "abc", i, 0);
+            if(d.abc[i] < 0.0 || d.abc[i] > 0.5) {
+                vsapi->setError(
+                    out,
+                    "DeBarrel: abc[] values can be zero to less than 0.5 only");
+                vsapi->freeNode(d.node);
+                return;
+            }
+        }
+
+        if(d.abc[0] + d.abc[1] + d.abc[2] > 1.0) {
+            vsapi->setError(out, "DeBarrel: sum of all three abc array values "
+                                 "must be less than 1.0 ");
+            vsapi->freeNode(d.node);
+            return;
+        }
+    }
+
+    else {
+        for(int i = 0; i < 3; i++) {
+            d.abc[i] = (float) vsapi->propGetFloat(in, "abc", i, 0);
+        }
+
+        if(d.abc[2] < 0.0 || d.abc[2] >= 0.5f) {
+            vsapi->setError(
+                out,
+                "DeBarrel: third value of abc[]  can be zero to less than 0.5");
+            vsapi->freeNode(d.node);
+            return;
+        }
+    }
 
+    temp = !!int64ToIntS(vsapi->propGetInt(in, "pin", 0, &err));
+
+    if(err)
+        temp = 0;
+
+    if(temp == 0)
+        d.pin = false;
+    else
+        d.pin = true;
+    d.q = int64ToIntS(vsapi->propGetInt(in, "q", 0, &err));
+    if(err)
+        d.q = 1;
+    else if(d.q < 0 || d.q > 4) {
+        vsapi->setError(out, "DeBarrel: q  can be 1 to 4 only");
+        vsapi->freeNode(d.node);
+        return;
+    }
+
+    // d.test
+    temp = !!int64ToIntS(vsapi->propGetInt(in, "test", 0, &err));
+
+    if(err)
+        temp = 0;
+
+    if(temp == 0)
+        d.test = false;
+    else
+        d.test = true;
+
+    if(d.test) {
+        d.dots = int64ToIntS(vsapi->propGetInt(in, "dots", 0, &err));
+
+        if(err)
+            d.dots = 2;
+        if(d.dots < 0 || d.dots > 4) {
+            vsapi->setError(out, "DeBarrel: dots can be 1 to 4 only.");
+            vsapi->freeNode(d.node);
+            return;
+        }
+
+        d.dim = (float) (1.0 - vsapi->propGetFloat(in, "dots", 0, &err));
+        if(err)
+            d.dim = 0.75;
+        else if(d.dim < 0 || d.dim > 1.0f) {
+            vsapi->setError(out, "DeBarrel: dim can be 0 to 1.0 only.");
+            vsapi->freeNode(d.node);
+            return;
+        }
+
+    } // if test
 
     // If a property read fails for some reason (index out of bounds/wrong type)
     // then err will have flags set to indicate why and 0 will be returned. This
@@ -567,34 +572,35 @@ static void VS_CC debarrelCreate(const VSMap *in, VSMap *out, void *userData, VS
     // strict checking because of what we wrote in the argument string, the only
     // reason this could fail is when the value wasn't set by the user.
     // And when it's not set we want it to default to enabled.
- 
-	
-	data = (DeBarrelData *) malloc(sizeof(d));
+
+    data = (DeBarrelData *) malloc(sizeof(d));
     *data = d;
 
-    // Creates a new filter and returns a reference to it. Always pass on the in and out
-    // arguments or unexpected things may happen. The name should be something that's
-    // easy to connect to the filter, like its function name.
-    // The three function pointers handle initialization, frame processing and filter destruction.
-    // The filtermode is very important to get right as it controls how threading of the filter
-    // is handled. In general you should only use fmParallel whenever possible. This is if you
-    // need to modify no shared data at all when the filter is running.
-    // For more complicated filters, fmParallelRequests is usually easier to achieve as it can
-    // be prefetched in parallel but the actual processing is serialized.
-    // The others can be considered special cases where fmSerial is useful to source filters and
-    // fmUnordered is useful when a filter's state may change even when deciding which frames to
-    // prefetch (such as a cache filter).
-    // If your filter is really fast (such as a filter that only resorts frames) you should set the
-    // nfNoCache flag to make the caching work smoother.
-    vsapi->createFilter(in, out, "DeBarrel", debarrelInit, debarrelGetFrame, debarrelFree, fmParallel, 0, data, core);
+    // Creates a new filter and returns a reference to it. Always pass on the in
+    // and out arguments or unexpected things may happen. The name should be
+    // something that's easy to connect to the filter, like its function name.
+    // The three function pointers handle initialization, frame processing and
+    // filter destruction. The filtermode is very important to get right as it
+    // controls how threading of the filter is handled. In general you should
+    // only use fmParallel whenever possible. This is if you need to modify no
+    // shared data at all when the filter is running. For more complicated
+    // filters, fmParallelRequests is usually easier to achieve as it can be
+    // prefetched in parallel but the actual processing is serialized. The
+    // others can be considered special cases where fmSerial is useful to source
+    // filters and fmUnordered is useful when a filter's state may change even
+    // when deciding which frames to prefetch (such as a cache filter). If your
+    // filter is really fast (such as a filter that only resorts frames) you
+    // should set the nfNoCache flag to make the caching work smoother.
+    vsapi->createFilter(in, out, "DeBarrel", debarrelInit, debarrelGetFrame,
+                        debarrelFree, fmParallel, 0, data, core);
 }
 //////////////////////////////////////////
 // Init
 
-// This is the entry point that is called when a plugin is loaded. You are only supposed
-// to call the two provided functions here.
-// configFunc sets the id, namespace, and long name of the plugin (the last 3 arguments
-// never need to be changed for a normal plugin).
+// This is the entry point that is called when a plugin is loaded. You are only
+// supposed to call the two provided functions here. configFunc sets the id,
+// namespace, and long name of the plugin (the last 3 arguments never need to be
+// changed for a normal plugin).
 //
 // id: Needs to be a "reverse" url and unique among all plugins.
 // It is inspired by how android packages identify themselves.
@@ -605,20 +611,20 @@ static void VS_CC debarrelCreate(const VSMap *in, VSMap *out, void *userData, VS
 //
 // full name: Any name that describes the plugin nicely.
 //
-// registerFunc is called once for each function you want to register. Function names
-// should be PascalCase. The argument string has this format:
-// name:type; or name:type:flag1:flag2....;
-// All argument name should be lowercase and only use [a-z_].
-// The valid types are int,float,data,clip,frame,func. [] can be appended to allow arrays
-// of type to be passed (numbers:int[])
-// The available flags are opt, to make an argument optional, empty, which controls whether
-// or not empty arrays are accepted
+// registerFunc is called once for each function you want to register. Function
+// names should be PascalCase. The argument string has this format: name:type;
+// or name:type:flag1:flag2....; All argument name should be lowercase and only
+// use [a-z_]. The valid types are int,float,data,clip,frame,func. [] can be
+// appended to allow arrays of type to be passed (numbers:int[]) The available
+// flags are opt, to make an argument optional, empty, which controls whether or
+// not empty arrays are accepted
 /*
-VS_EXTERNAL_API(void) VapourSynthPluginInit(VSConfigPlugin configFunc, VSRegisterFunction registerFunc, VSPlugin *plugin) {
-    configFunc("in.vcmohan.repo", "geom", "VapourSynth DeBarrel plugin", VAPOURSYNTH_API_VERSION, 1, plugin);
-    registerFunc("DeBarrel", "clip:clip;abc:float[];method:int:opt;pin:int:opt;q:int:opt;"
-	"test:int:opt;dots:data:opt; dim:float:opt;", debarrelCreate, 0, plugin);
+VS_EXTERNAL_API(void) VapourSynthPluginInit(VSConfigPlugin configFunc,
+VSRegisterFunction registerFunc, VSPlugin *plugin) {
+    configFunc("in.vcmohan.repo", "geom", "VapourSynth DeBarrel plugin",
+VAPOURSYNTH_API_VERSION, 1, plugin); registerFunc("DeBarrel",
+"clip:clip;abc:float[];method:int:opt;pin:int:opt;q:int:opt;"
+    "test:int:opt;dots:data:opt; dim:float:opt;", debarrelCreate, 0, plugin);
 }
 
 */
-
diff --git a/spotlightDim.h b/spotlightDim.h
index 48d7a56..52c3345 100644
--- a/spotlightDim.h
+++ b/spotlightDim.h
@@ -2,131 +2,109 @@
 #ifndef SPOTLIGHT_DIM_A_COLOR_PLANE_V_C_MOHAN
 #define SPOTLIGHT_DIM_A_COLOR_PLANE_V_C_MOHAN
 
-// dims a color plane 
+// dims a color plane
 
 template <typename finc>
-void dimplaneRGB(finc* dp, const finc* sp, int pitch,
-						int wd, int ht, float dim);
+void dimplaneRGB(finc *dp, const finc *sp, int pitch, int wd, int ht,
+                 float dim);
 
 template <typename finc>
-void dimplaneYUV(finc* dp, const finc* sp, int pitch,
-	int wd, int ht, float dim, finc limit);
+void dimplaneYUV(finc *dp, const finc *sp, int pitch, int wd, int ht, float dim,
+                 finc limit);
 
 template <typename finc>
-void YUVspotLight(finc* dp, const finc* sp, int pitch,
-	int x, int y, int r, int wd, int ht, int subW, int subH,
-	finc gray, finc color);
+void YUVspotLight(finc *dp, const finc *sp, int pitch, int x, int y, int r,
+                  int wd, int ht, int subW, int subH, finc gray, finc color);
 
 template <typename finc>
-void RGBspotLight(finc* dp, const finc* sp, int pitch,
-	int x, int y, int r, int wd, int ht, finc color);
-
+void RGBspotLight(finc *dp, const finc *sp, int pitch, int x, int y, int r,
+                  int wd, int ht, finc color);
 
 //---------------------------------------------------------------
 template <typename finc>
-void dimplaneRGB(finc* dp, const finc* sp, int pitch,
-	int wd, int ht, float dim)
-{
-	for (int h = 0; h < ht; h++)
-	{
-		for (int w = 0; w < wd; w++)
-		{
-			dp[w] = (finc)(sp[w] * dim);
-		}
-		dp += pitch;
-		sp += pitch;
-	}
+void dimplaneRGB(finc *dp, const finc *sp, int pitch, int wd, int ht,
+                 float dim) {
+    for(int h = 0; h < ht; h++) {
+        for(int w = 0; w < wd; w++) {
+            dp[w] = (finc) (sp[w] * dim);
+        }
+        dp += pitch;
+        sp += pitch;
+    }
 }
 
 template <typename finc>
-void dimplaneYUV(finc* dp, const finc* sp, int pitch,
-	int wd, int ht, float dim, finc limit)
-{
-	for (int h = 0; h < ht; h++)
-	{
-		for (int w = 0; w < wd; w++)
-		{
-			dp[w] = (finc)((sp[w] - limit) * dim) + limit;
-		}
-		dp += pitch;
-		sp += pitch;
-	}
+void dimplaneYUV(finc *dp, const finc *sp, int pitch, int wd, int ht, float dim,
+                 finc limit) {
+    for(int h = 0; h < ht; h++) {
+        for(int w = 0; w < wd; w++) {
+            dp[w] = (finc) ((sp[w] - limit) * dim) + limit;
+        }
+        dp += pitch;
+        sp += pitch;
+    }
 }
 //------------------------------------------------------------
 template <typename finc>
-void RGBspotLight(finc* dp, const finc* sp, int pitch,
-	int x, int y, int r, int wd, int ht, finc color)
-{
-	int sx = VSMIN(VSMAX(x - r, 0), wd - 1);
-	int ex = VSMIN(VSMAX(x + r, 0), wd - 1);
-
-	int sy = VSMIN(VSMAX(y - r, 0), ht - 1);
-	int ey = VSMIN(VSMAX(y + r, 0), ht - 1);
-	int rsq = r * r;
-
-	for (int h = sy; h < ey; h++)
-	{
-		int hsq = (h - y) * (h - y);
-
-		for (int w = sx; w < ex; w++)
-		{
-			if (hsq + (w - x) * (w - x) <= rsq)
-			{				
-				finc col = *(sp + (h * pitch + w));
-				if ( color < col)
-				{
-
-					*(dp + h * pitch + w) = color;
-				}
-				else
-				{
-					*(dp + h * pitch + w) = col;
-				}
-			}
-		}
-	}
-
+void RGBspotLight(finc *dp, const finc *sp, int pitch, int x, int y, int r,
+                  int wd, int ht, finc color) {
+    int sx = VSMIN(VSMAX(x - r, 0), wd - 1);
+    int ex = VSMIN(VSMAX(x + r, 0), wd - 1);
+
+    int sy = VSMIN(VSMAX(y - r, 0), ht - 1);
+    int ey = VSMIN(VSMAX(y + r, 0), ht - 1);
+    int rsq = r * r;
+
+    for(int h = sy; h < ey; h++) {
+        int hsq = (h - y) * (h - y);
+
+        for(int w = sx; w < ex; w++) {
+            if(hsq + (w - x) * (w - x) <= rsq) {
+                finc col = *(sp + (h * pitch + w));
+                if(color < col) {
+
+                    *(dp + h * pitch + w) = color;
+                } else {
+                    *(dp + h * pitch + w) = col;
+                }
+            }
+        }
+    }
 }
 //--------------------------------------------------------------------------------------------------
 template <typename finc>
-void YUVspotLight(finc* dp, const finc* sp, int pitch,
-	int x, int y, int r, int wd, int ht, int subW, int subH,
-	finc gray, finc color)
-{	
-	// x, y, r , wd, ht are values for y plane. 
-	// gray will be 0 for y and some value for u, v
-	int sx = (VSMIN(VSMAX(x - r, 0), wd - 1)) >> subW;
-	int ex = (VSMIN(VSMAX(x + r, 0), wd - 1)) >> subW;
-
-	int sy = (VSMIN(VSMAX(y - r, 0), ht - 1)) >> subH;
-	int ey = (VSMIN(VSMAX(y + r, 0), ht - 1)) >> subH;
-	// initialize pointers
-
-	int rsq = r * r;
-	int rsubW = r >> subW, rsubH = r >> subH;
-
-	//finc yuv[] = { yuvCol[3 * colFlag], yuvCol[3 * colFlag + 1], yuvCol[3 * colFlag + 2] };
-
-	for (int h = sy; h < ey; h++)
-	{
-		int hsq = ( ((h << subH) - y) * ((h << subH) - y) );
-
-		for (int w = sx; w < ex; w++)
-		{
-			int wsq = ( ((w << subW) - x) * ((w << subW) - x) );
-
-			if (hsq + wsq <= rsq)
-			{				
-				finc col = *(sp + h * pitch + w);
-				*(dp + h * pitch + w)
-					= col >= gray && color > gray ||  
-					 col <= gray && color < gray ? (col + color)/2
-					:(col);				
-			}
-		}
-	}
-
+void YUVspotLight(finc *dp, const finc *sp, int pitch, int x, int y, int r,
+                  int wd, int ht, int subW, int subH, finc gray, finc color) {
+    // x, y, r , wd, ht are values for y plane.
+    // gray will be 0 for y and some value for u, v
+    int sx = (VSMIN(VSMAX(x - r, 0), wd - 1)) >> subW;
+    int ex = (VSMIN(VSMAX(x + r, 0), wd - 1)) >> subW;
+
+    int sy = (VSMIN(VSMAX(y - r, 0), ht - 1)) >> subH;
+    int ey = (VSMIN(VSMAX(y + r, 0), ht - 1)) >> subH;
+    // initialize pointers
+
+    int rsq = r * r;
+    int rsubW = r >> subW, rsubH = r >> subH;
+
+    // finc yuv[] = { yuvCol[3 * colFlag], yuvCol[3 * colFlag + 1], yuvCol[3 *
+    // colFlag + 2] };
+
+    for(int h = sy; h < ey; h++) {
+        int hsq = (((h << subH) - y) * ((h << subH) - y));
+
+        for(int w = sx; w < ex; w++) {
+            int wsq = (((w << subW) - x) * ((w << subW) - x));
+
+            if(hsq + wsq <= rsq) {
+                finc col = *(sp + h * pitch + w);
+                *(dp + h * pitch + w) =
+                    col >= gray && color > gray || col <= gray && color < gray
+                        ? (col + color) / 2
+                        : (col);
+            }
+        }
+    }
 }
 
 #endif
-
diff --git a/statsAndOffsets.h b/statsAndOffsets.h
index 089afbb..ca97e5f 100644
--- a/statsAndOffsets.h
+++ b/statsAndOffsets.h
@@ -2,141 +2,125 @@
 #ifndef STATS_AND_OFFSETS_LOOK_UP_TABLES_V_C_MOHAN
 #define STATS_AND_OFFSETS_LOOK_UP_TABLES_V_C_MOHAN
 //------------------------------------------------------------
-//Look up tables for rectangular and circular grids
-//Variance, average of grid
+// Look up tables for rectangular and circular grids
+// Variance, average of grid
 //-----------------------------------------------------------------
-int makeLinearLUT(int* offsets, int pitch, int xcoord, int ycoord );
-int makeRectGridLUT(int* offsets, int pitch, int xgrid, int ygrid = 0, int coffset = 0);
-int makeCircularLUT(int* offsets, int pitch, int rad, int coffset = 0);
+int makeLinearLUT(int *offsets, int pitch, int xcoord, int ycoord);
+int makeRectGridLUT(int *offsets, int pitch, int xgrid, int ygrid = 0,
+                    int coffset = 0);
+int makeCircularLUT(int *offsets, int pitch, int rad, int coffset = 0);
 template <typename finc>
-float getMeanValue(const finc* sp, int* offsets, int noff);
+float getMeanValue(const finc *sp, int *offsets, int noff);
 template <typename finc>
-float getVariance(finc* sp, int* Offsets, int noff, float avg);
-
+float getVariance(finc *sp, int *Offsets, int noff, float avg);
 
 //---------------------------------------------------------------------
 
-int makeLinearLUT(int* offsets, int pitch, int xcoord, int ycoord)
-{
-	int count = 0, npoints = 0;
-	
-	int absx = abs(xcoord), absy = abs(ycoord);
-
-	if (absx < absy)
-	{
-		npoints = 2 * absy + 1;
-
-		if (xcoord == 0)
-		{
-			// xcoord = 0. So avoid divide by zero
-			for (int i = 0; i < npoints; i++)
-			{
-				offsets[i] = (i - npoints / 2) * pitch;
-				count++;
-			}
-		}
-
-		else
-		{
-			for (int i = 0; i < npoints; i++)
-			{
-				offsets[i] = (absy / ycoord) * (i - npoints / 2) * pitch
-					+ absx / xcoord * (((i - npoints / 2) * absx
-						+ (absy / 2)) / absy);
-				count++;
-			}
-		}
-
-	}
-	else
-	{
-		npoints = 2 * absx + 1;
-		if (ycoord == 0)	// avoid div by zero
-		{
-
-			for (int i = 0; i < npoints; i++)
-			{
-				offsets[i] = (i - npoints / 2);
-				count++;
-			}
-		}
-
-		else
-		{
-			for (int i = 0; i < npoints; i++)
-			{
-				offsets[i] = (absx / xcoord) * (i - npoints / 2)
-					+ (absy / ycoord) * pitch * (((i - npoints / 2) * absy
-						+ (absx / 2)) / absx);
-				count++;
-			}
-		}
-	}
-
-	return count;
+int makeLinearLUT(int *offsets, int pitch, int xcoord, int ycoord) {
+    int count = 0, npoints = 0;
+
+    int absx = abs(xcoord), absy = abs(ycoord);
+
+    if(absx < absy) {
+        npoints = 2 * absy + 1;
+
+        if(xcoord == 0) {
+            // xcoord = 0. So avoid divide by zero
+            for(int i = 0; i < npoints; i++) {
+                offsets[i] = (i - npoints / 2) * pitch;
+                count++;
+            }
+        }
+
+        else {
+            for(int i = 0; i < npoints; i++) {
+                offsets[i] =
+                    (absy / ycoord) * (i - npoints / 2) * pitch +
+                    absx / xcoord *
+                        (((i - npoints / 2) * absx + (absy / 2)) / absy);
+                count++;
+            }
+        }
+
+    } else {
+        npoints = 2 * absx + 1;
+        if(ycoord == 0) // avoid div by zero
+        {
+
+            for(int i = 0; i < npoints; i++) {
+                offsets[i] = (i - npoints / 2);
+                count++;
+            }
+        }
+
+        else {
+            for(int i = 0; i < npoints; i++) {
+                offsets[i] =
+                    (absx / xcoord) * (i - npoints / 2) +
+                    (absy / ycoord) * pitch *
+                        (((i - npoints / 2) * absy + (absx / 2)) / absx);
+                count++;
+            }
+        }
+    }
+
+    return count;
 }
-		//definitions
-// makes offsets table from left top corner of grid and adds coffset to bring them to any point required
-int makeRectGridLUT(int* offsets, int pitch, int xgrid, int ygrid, int coffset)
-{
-	if (ygrid == 0)
-		ygrid = xgrid;
-
-	int i = 0;
-
-	for (int h = 0; h < ygrid; h++)
-	{
-		for (int w = 0; w < xgrid; w++)
-		{
-			offsets[i] = h * pitch + w  + coffset;
-			i++;
-		}
-	}
-	return i;
+// definitions
+// makes offsets table from left top corner of grid and adds coffset to bring
+// them to any point required
+int makeRectGridLUT(int *offsets, int pitch, int xgrid, int ygrid,
+                    int coffset) {
+    if(ygrid == 0)
+        ygrid = xgrid;
+
+    int i = 0;
+
+    for(int h = 0; h < ygrid; h++) {
+        for(int w = 0; w < xgrid; w++) {
+            offsets[i] = h * pitch + w + coffset;
+            i++;
+        }
+    }
+    return i;
 }
-// makes offset table from center of circle and adds required offset to move ref to any point
-int makeCircularLUT(int* cOff, int pitch, int rad, int coffset)
-{
-	int count = 0;
-	int rsq = rad * rad;
-
-	for (int h = -rad; h <= rad; h++)
-	{
-		int hsq = h * h;
-		for (int w = -rad; w <= rad; w++)
-		{
-			if (hsq + (w * w) <= rsq)
-			{
-				cOff[count] = h * pitch + w  + coffset;
-				count++;
-			}
-
-		}
-	}
-	return count;
+// makes offset table from center of circle and adds required offset to move ref
+// to any point
+int makeCircularLUT(int *cOff, int pitch, int rad, int coffset) {
+    int count = 0;
+    int rsq = rad * rad;
+
+    for(int h = -rad; h <= rad; h++) {
+        int hsq = h * h;
+        for(int w = -rad; w <= rad; w++) {
+            if(hsq + (w * w) <= rsq) {
+                cOff[count] = h * pitch + w + coffset;
+                count++;
+            }
+        }
+    }
+    return count;
 }
 
 // get mean value of a grid/ disc given offsets LUT pointer and number offsets
 template <typename finc>
-float getMeanValue(const finc* sp, int* offsets, int noff)
-{
-	float sum = 0;
+float getMeanValue(const finc *sp, int *offsets, int noff) {
+    float sum = 0;
 
-	for (int i = 0; i < noff; i++)
+    for(int i = 0; i < noff; i++)
 
-		sum += (float)sp[offsets[i]];
+        sum += (float) sp[offsets[i]];
 
-	return (sum / noff);
+    return (sum / noff);
 }
-// gives variance of given grid/ area with offsetsLUT, n offsets and average of grid / area
+// gives variance of given grid/ area with offsetsLUT, n offsets and average of
+// grid / area
 template <typename finc>
-float getVariance(finc* sp, int* offsets, int noff, float avg)
-{
-	float sum = 0.0f;
-	for (int i = 0; i < noff; i++)
-	{
-		sum += (avg - sp[offsets[i]]) * (avg - sp[offsets[i]]);
-	}
-	return sum / noff;
+float getVariance(finc *sp, int *offsets, int noff, float avg) {
+    float sum = 0.0f;
+    for(int i = 0; i < noff; i++) {
+        sum += (avg - sp[offsets[i]]) * (avg - sp[offsets[i]]);
+    }
+    return sum / noff;
 }
 #endif
diff --git a/vcm.cpp b/vcm.cpp
index bc13a1b..33ac3ee 100644
--- a/vcm.cpp
+++ b/vcm.cpp
@@ -31,7 +31,7 @@ This program is free software: you can redistribute it and/or modify
 -----------------------------------------------------------------------------*/
 #include <stdlib.h>
 #ifdef _WIN32
-#include <Windows.h>
+#include <windows.h>
 #else
 #include <dlfcn.h>
 #include <string>
@@ -159,4 +159,4 @@ VS_EXTERNAL_API(void) VapourSynthPluginInit(VSConfigPlugin configFunc, VSRegiste
 		"segmenthor:int:opt;segmentvert:int:opt;limit:int:opt;", stepfilterCreate, 0, plugin);
 	registerFunc("Circles", "clip:clip;xo:int:opt;yo:int:opt;frad:int:opt;cint:int:opt;dots:int:opt;rgb:int[]:opt;dim:float:opt;", circlesCreate, 0, plugin);
 
-}
\ No newline at end of file
+}
